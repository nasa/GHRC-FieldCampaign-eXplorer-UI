define(["exports","./when-54c2dc71","./Check-6c0211bc","./Math-1124a290","./Cartesian2-36f5627e","./Transforms-441ed215","./ComponentDatatype-a26dd044","./GeometryAttribute-c636bf20","./GeometryAttributes-4fcfcf40","./IndexDatatype-25023891","./GeometryOffsetAttribute-d746452d","./VertexFormat-4d8b817a"],function(e,ue,d,le,fe,ce,de,pe,Ce,ye,he,p){"use strict";var _e=new fe.Cartesian3,ve=new fe.Cartesian3,Ae=new fe.Cartesian3,xe=new fe.Cartesian3,we=new fe.Cartesian3,l=new fe.Cartesian3(1,1,1),be=Math.cos,ke=Math.sin;function C(e){e=ue.defaultValue(e,ue.defaultValue.EMPTY_OBJECT);var t=ue.defaultValue(e.radii,l),a=ue.defaultValue(e.innerRadii,t),r=ue.defaultValue(e.minimumClock,0),i=ue.defaultValue(e.maximumClock,le.CesiumMath.TWO_PI),n=ue.defaultValue(e.minimumCone,0),o=ue.defaultValue(e.maximumCone,le.CesiumMath.PI),m=Math.round(ue.defaultValue(e.stackPartitions,64)),s=Math.round(ue.defaultValue(e.slicePartitions,64)),u=ue.defaultValue(e.vertexFormat,p.VertexFormat.DEFAULT);if(s<3)throw new d.DeveloperError("options.slicePartitions cannot be less than three.");if(m<3)throw new d.DeveloperError("options.stackPartitions cannot be less than three.");this._radii=fe.Cartesian3.clone(t),this._innerRadii=fe.Cartesian3.clone(a),this._minimumClock=r,this._maximumClock=i,this._minimumCone=n,this._maximumCone=o,this._stackPartitions=m,this._slicePartitions=s,this._vertexFormat=p.VertexFormat.clone(u),this._offsetAttribute=e.offsetAttribute,this._workerName="createEllipsoidGeometry"}C.packedLength=2*fe.Cartesian3.packedLength+p.VertexFormat.packedLength+7,C.pack=function(e,t,a){if(!ue.defined(e))throw new d.DeveloperError("value is required");if(!ue.defined(t))throw new d.DeveloperError("array is required");return a=ue.defaultValue(a,0),fe.Cartesian3.pack(e._radii,t,a),a+=fe.Cartesian3.packedLength,fe.Cartesian3.pack(e._innerRadii,t,a),a+=fe.Cartesian3.packedLength,p.VertexFormat.pack(e._vertexFormat,t,a),a+=p.VertexFormat.packedLength,t[a++]=e._minimumClock,t[a++]=e._maximumClock,t[a++]=e._minimumCone,t[a++]=e._maximumCone,t[a++]=e._stackPartitions,t[a++]=e._slicePartitions,t[a]=ue.defaultValue(e._offsetAttribute,-1),t};var t,y=new fe.Cartesian3,h=new fe.Cartesian3,_=new p.VertexFormat,v={radii:y,innerRadii:h,vertexFormat:_,minimumClock:void 0,maximumClock:void 0,minimumCone:void 0,maximumCone:void 0,stackPartitions:void 0,slicePartitions:void 0,offsetAttribute:void 0};C.unpack=function(e,t,a){if(!ue.defined(e))throw new d.DeveloperError("array is required");t=ue.defaultValue(t,0);var r=fe.Cartesian3.unpack(e,t,y);t+=fe.Cartesian3.packedLength;var i=fe.Cartesian3.unpack(e,t,h);t+=fe.Cartesian3.packedLength;var n=p.VertexFormat.unpack(e,t,_);t+=p.VertexFormat.packedLength;var o=e[t++],m=e[t++],s=e[t++],u=e[t++],l=e[t++],f=e[t++],c=e[t];return ue.defined(a)?(a._radii=fe.Cartesian3.clone(r,a._radii),a._innerRadii=fe.Cartesian3.clone(i,a._innerRadii),a._vertexFormat=p.VertexFormat.clone(n,a._vertexFormat),a._minimumClock=o,a._maximumClock=m,a._minimumCone=s,a._maximumCone=u,a._stackPartitions=l,a._slicePartitions=f,a._offsetAttribute=-1===c?void 0:c,a):(v.minimumClock=o,v.maximumClock=m,v.minimumCone=s,v.maximumCone=u,v.stackPartitions=l,v.slicePartitions=f,v.offsetAttribute=-1===c?void 0:c,new C(v))},C.createGeometry=function(e){var t=e._radii;if(!(t.x<=0||t.y<=0||t.z<=0)){var a=e._innerRadii;if(!(a.x<=0||a.y<=0||a.z<=0)){var r=e._minimumClock,i=e._maximumClock,n=e._minimumCone,o=e._maximumCone,m=e._vertexFormat,s=e._slicePartitions+1,u=e._stackPartitions+1;(s=Math.round(s*Math.abs(i-r)/le.CesiumMath.TWO_PI))<2&&(s=2),(u=Math.round(u*Math.abs(o-n)/le.CesiumMath.PI))<2&&(u=2);var l=0,f=[n],c=[r];for(W=0;W<u;W++)f.push(n+W*(o-n)/(u-1));for(f.push(o),I=0;I<s;I++)c.push(r+I*(i-r)/(s-1));c.push(i);var d=f.length,p=c.length,C=0,y=1,h=a.x!==t.x||a.y!==t.y||a.z!==t.z,_=!1,v=!1,A=!1;h&&(y=2,0<n&&(_=!0,C+=s-1),o<Math.PI&&(v=!0,C+=s-1),(i-r)%le.CesiumMath.TWO_PI?(A=!0,C+=2*(u-1)+1):C+=1);var x=p*d*y,w=new Float64Array(3*x),b=he.arrayFill(new Array(x),!1),k=he.arrayFill(new Array(x),!1),P=s*u*y,F=6*(P+C+1-(s+u)*y),g=ye.IndexDatatype.createTypedArray(P,F),V=m.normal?new Float32Array(3*x):void 0,D=m.tangent?new Float32Array(3*x):void 0,M=m.bitangent?new Float32Array(3*x):void 0,T=m.st?new Float32Array(2*x):void 0,E=new Array(d),G=new Array(d);for(W=0;W<d;W++)E[W]=ke(f[W]),G[W]=be(f[W]);for(var L=new Array(p),O=new Array(p),I=0;I<p;I++)O[I]=be(c[I]),L[I]=ke(c[I]);for(W=0;W<d;W++)for(I=0;I<p;I++)w[l++]=t.x*E[W]*O[I],w[l++]=t.y*E[W]*L[I],w[l++]=t.z*G[W];var z,N,R,U,S=x/2;if(h)for(W=0;W<d;W++)for(I=0;I<p;I++)w[l++]=a.x*E[W]*O[I],w[l++]=a.y*E[W]*L[I],w[l++]=a.z*G[W],b[S]=!0,0<W&&W!==d-1&&0!==I&&I!==p-1&&(k[S]=!0),S++;for(l=0,W=1;W<d-2;W++)for(z=W*p,N=(W+1)*p,I=1;I<p-2;I++)g[l++]=N+I,g[l++]=N+I+1,g[l++]=z+I+1,g[l++]=N+I,g[l++]=z+I+1,g[l++]=z+I;if(h)for(var B=d*p,W=1;W<d-2;W++)for(z=B+W*p,N=B+(W+1)*p,I=1;I<p-2;I++)g[l++]=N+I,g[l++]=z+I,g[l++]=z+I+1,g[l++]=N+I,g[l++]=z+I+1,g[l++]=N+I+1;if(h){if(_)for(U=d*p,W=1;W<p-2;W++)g[l++]=W,g[l++]=W+1,g[l++]=U+W+1,g[l++]=W,g[l++]=U+W+1,g[l++]=U+W;if(v)for(R=d*p-p,U=d*p*y-p,W=1;W<p-2;W++)g[l++]=R+W+1,g[l++]=R+W,g[l++]=U+W,g[l++]=R+W+1,g[l++]=U+W,g[l++]=U+W+1}if(A){for(W=1;W<d-2;W++)U=p*d+p*W,R=p*W,g[l++]=U,g[l++]=R+p,g[l++]=R,g[l++]=U,g[l++]=U+p,g[l++]=R+p;for(W=1;W<d-2;W++)U=p*d+p*(W+1)-1,R=p*(W+1)-1,g[l++]=R+p,g[l++]=U,g[l++]=R,g[l++]=R+p,g[l++]=U+p,g[l++]=U}var q=new Ce.GeometryAttributes;m.position&&(q.position=new pe.GeometryAttribute({componentDatatype:de.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:w}));var Y,J,X,Z,j=0,H=0,K=0,Q=0,$=x/2,ee=fe.Ellipsoid.fromCartesian3(t),te=fe.Ellipsoid.fromCartesian3(a);if(m.st||m.normal||m.tangent||m.bitangent){for(W=0;W<x;W++){Y=b[W]?te:ee;var ae,re,ie,ne,oe,me=fe.Cartesian3.fromArray(w,3*W,_e),se=Y.geodeticSurfaceNormal(me,ve);k[W]&&fe.Cartesian3.negate(se,se),m.st&&(ae=fe.Cartesian2.negate(se,we),T[j++]=Math.atan2(ae.y,ae.x)/le.CesiumMath.TWO_PI+.5,T[j++]=Math.asin(se.z)/Math.PI+.5),m.normal&&(V[H++]=se.x,V[H++]=se.y,V[H++]=se.z),(m.tangent||m.bitangent)&&(re=Ae,ie=0,b[W]&&(ie=$),ne=!_&&ie<=W&&W<ie+2*p?fe.Cartesian3.UNIT_X:fe.Cartesian3.UNIT_Z,fe.Cartesian3.cross(ne,se,re),fe.Cartesian3.normalize(re,re),m.tangent&&(D[K++]=re.x,D[K++]=re.y,D[K++]=re.z),m.bitangent&&(oe=fe.Cartesian3.cross(se,re,xe),fe.Cartesian3.normalize(oe,oe),M[Q++]=oe.x,M[Q++]=oe.y,M[Q++]=oe.z))}m.st&&(q.st=new pe.GeometryAttribute({componentDatatype:de.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:T})),m.normal&&(q.normal=new pe.GeometryAttribute({componentDatatype:de.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:V})),m.tangent&&(q.tangent=new pe.GeometryAttribute({componentDatatype:de.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:D})),m.bitangent&&(q.bitangent=new pe.GeometryAttribute({componentDatatype:de.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:M}))}return ue.defined(e._offsetAttribute)&&(J=w.length,X=new Uint8Array(J/3),Z=e._offsetAttribute===he.GeometryOffsetAttribute.NONE?0:1,he.arrayFill(X,Z),q.applyOffset=new pe.GeometryAttribute({componentDatatype:de.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:X})),new pe.Geometry({attributes:q,indices:g,primitiveType:pe.PrimitiveType.TRIANGLES,boundingSphere:ce.BoundingSphere.fromEllipsoid(ee),offsetAttribute:e._offsetAttribute})}}},C.getUnitEllipsoid=function(){return ue.defined(t)||(t=C.createGeometry(new C({radii:new fe.Cartesian3(1,1,1),vertexFormat:p.VertexFormat.POSITION_ONLY}))),t},e.EllipsoidGeometry=C});
//# sourceMappingURL=EllipsoidGeometry-26fabc7c.js.map
