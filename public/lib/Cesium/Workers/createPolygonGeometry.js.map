{"version":3,"file":"createPolygonGeometry.js","sources":["../../../../Source/Core/PolygonGeometry.js","../../../../Source/WorkersES6/createPolygonGeometry.js"],"sourcesContent":["import ArcType from \"./ArcType.js\";\nimport arrayFill from \"./arrayFill.js\";\nimport BoundingRectangle from \"./BoundingRectangle.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport EllipsoidGeodesic from \"./EllipsoidGeodesic.js\";\nimport EllipsoidTangentPlane from \"./EllipsoidTangentPlane.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryInstance from \"./GeometryInstance.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport GeometryPipeline from \"./GeometryPipeline.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport PolygonGeometryLibrary from \"./PolygonGeometryLibrary.js\";\nimport PolygonPipeline from \"./PolygonPipeline.js\";\nimport Quaternion from \"./Quaternion.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport VertexFormat from \"./VertexFormat.js\";\nimport WindingOrder from \"./WindingOrder.js\";\n\nvar scratchCarto1 = new Cartographic();\nvar scratchCarto2 = new Cartographic();\nfunction adjustPosHeightsForNormal(position, p1, p2, ellipsoid) {\n  var carto1 = ellipsoid.cartesianToCartographic(position, scratchCarto1);\n  var height = carto1.height;\n  var p1Carto = ellipsoid.cartesianToCartographic(p1, scratchCarto2);\n  p1Carto.height = height;\n  ellipsoid.cartographicToCartesian(p1Carto, p1);\n\n  var p2Carto = ellipsoid.cartesianToCartographic(p2, scratchCarto2);\n  p2Carto.height = height - 100;\n  ellipsoid.cartographicToCartesian(p2Carto, p2);\n}\n\nvar scratchBoundingRectangle = new BoundingRectangle();\nvar scratchPosition = new Cartesian3();\nvar scratchNormal = new Cartesian3();\nvar scratchTangent = new Cartesian3();\nvar scratchBitangent = new Cartesian3();\nvar p1Scratch = new Cartesian3();\nvar p2Scratch = new Cartesian3();\nvar scratchPerPosNormal = new Cartesian3();\nvar scratchPerPosTangent = new Cartesian3();\nvar scratchPerPosBitangent = new Cartesian3();\n\nvar appendTextureCoordinatesOrigin = new Cartesian2();\nvar appendTextureCoordinatesCartesian2 = new Cartesian2();\nvar appendTextureCoordinatesCartesian3 = new Cartesian3();\nvar appendTextureCoordinatesQuaternion = new Quaternion();\nvar appendTextureCoordinatesMatrix3 = new Matrix3();\nvar tangentMatrixScratch = new Matrix3();\n\nfunction computeAttributes(options) {\n  var vertexFormat = options.vertexFormat;\n  var geometry = options.geometry;\n  var shadowVolume = options.shadowVolume;\n  var flatPositions = geometry.attributes.position.values;\n  var length = flatPositions.length;\n  var wall = options.wall;\n  var top = options.top || wall;\n  var bottom = options.bottom || wall;\n  if (\n    vertexFormat.st ||\n    vertexFormat.normal ||\n    vertexFormat.tangent ||\n    vertexFormat.bitangent ||\n    shadowVolume\n  ) {\n    // PERFORMANCE_IDEA: Compute before subdivision, then just interpolate during subdivision.\n    // PERFORMANCE_IDEA: Compute with createGeometryFromPositions() for fast path when there's no holes.\n    var boundingRectangle = options.boundingRectangle;\n    var tangentPlane = options.tangentPlane;\n    var ellipsoid = options.ellipsoid;\n    var stRotation = options.stRotation;\n    var perPositionHeight = options.perPositionHeight;\n\n    var origin = appendTextureCoordinatesOrigin;\n    origin.x = boundingRectangle.x;\n    origin.y = boundingRectangle.y;\n\n    var textureCoordinates = vertexFormat.st\n      ? new Float32Array(2 * (length / 3))\n      : undefined;\n    var normals;\n    if (vertexFormat.normal) {\n      if (perPositionHeight && top && !wall) {\n        normals = geometry.attributes.normal.values;\n      } else {\n        normals = new Float32Array(length);\n      }\n    }\n    var tangents = vertexFormat.tangent ? new Float32Array(length) : undefined;\n    var bitangents = vertexFormat.bitangent\n      ? new Float32Array(length)\n      : undefined;\n    var extrudeNormals = shadowVolume ? new Float32Array(length) : undefined;\n\n    var textureCoordIndex = 0;\n    var attrIndex = 0;\n\n    var normal = scratchNormal;\n    var tangent = scratchTangent;\n    var bitangent = scratchBitangent;\n    var recomputeNormal = true;\n\n    var textureMatrix = appendTextureCoordinatesMatrix3;\n    var tangentRotationMatrix = tangentMatrixScratch;\n    if (stRotation !== 0.0) {\n      var rotation = Quaternion.fromAxisAngle(\n        tangentPlane._plane.normal,\n        stRotation,\n        appendTextureCoordinatesQuaternion\n      );\n      textureMatrix = Matrix3.fromQuaternion(rotation, textureMatrix);\n\n      rotation = Quaternion.fromAxisAngle(\n        tangentPlane._plane.normal,\n        -stRotation,\n        appendTextureCoordinatesQuaternion\n      );\n      tangentRotationMatrix = Matrix3.fromQuaternion(\n        rotation,\n        tangentRotationMatrix\n      );\n    } else {\n      textureMatrix = Matrix3.clone(Matrix3.IDENTITY, textureMatrix);\n      tangentRotationMatrix = Matrix3.clone(\n        Matrix3.IDENTITY,\n        tangentRotationMatrix\n      );\n    }\n\n    var bottomOffset = 0;\n    var bottomOffset2 = 0;\n\n    if (top && bottom) {\n      bottomOffset = length / 2;\n      bottomOffset2 = length / 3;\n\n      length /= 2;\n    }\n\n    for (var i = 0; i < length; i += 3) {\n      var position = Cartesian3.fromArray(\n        flatPositions,\n        i,\n        appendTextureCoordinatesCartesian3\n      );\n\n      if (vertexFormat.st) {\n        var p = Matrix3.multiplyByVector(\n          textureMatrix,\n          position,\n          scratchPosition\n        );\n        p = ellipsoid.scaleToGeodeticSurface(p, p);\n        var st = tangentPlane.projectPointOntoPlane(\n          p,\n          appendTextureCoordinatesCartesian2\n        );\n        Cartesian2.subtract(st, origin, st);\n\n        var stx = CesiumMath.clamp(st.x / boundingRectangle.width, 0, 1);\n        var sty = CesiumMath.clamp(st.y / boundingRectangle.height, 0, 1);\n        if (bottom) {\n          textureCoordinates[textureCoordIndex + bottomOffset2] = stx;\n          textureCoordinates[textureCoordIndex + 1 + bottomOffset2] = sty;\n        }\n        if (top) {\n          textureCoordinates[textureCoordIndex] = stx;\n          textureCoordinates[textureCoordIndex + 1] = sty;\n        }\n\n        textureCoordIndex += 2;\n      }\n\n      if (\n        vertexFormat.normal ||\n        vertexFormat.tangent ||\n        vertexFormat.bitangent ||\n        shadowVolume\n      ) {\n        var attrIndex1 = attrIndex + 1;\n        var attrIndex2 = attrIndex + 2;\n\n        if (wall) {\n          if (i + 3 < length) {\n            var p1 = Cartesian3.fromArray(flatPositions, i + 3, p1Scratch);\n\n            if (recomputeNormal) {\n              var p2 = Cartesian3.fromArray(\n                flatPositions,\n                i + length,\n                p2Scratch\n              );\n              if (perPositionHeight) {\n                adjustPosHeightsForNormal(position, p1, p2, ellipsoid);\n              }\n              Cartesian3.subtract(p1, position, p1);\n              Cartesian3.subtract(p2, position, p2);\n              normal = Cartesian3.normalize(\n                Cartesian3.cross(p2, p1, normal),\n                normal\n              );\n              recomputeNormal = false;\n            }\n\n            if (Cartesian3.equalsEpsilon(p1, position, CesiumMath.EPSILON10)) {\n              // if we've reached a corner\n              recomputeNormal = true;\n            }\n          }\n\n          if (vertexFormat.tangent || vertexFormat.bitangent) {\n            bitangent = ellipsoid.geodeticSurfaceNormal(position, bitangent);\n            if (vertexFormat.tangent) {\n              tangent = Cartesian3.normalize(\n                Cartesian3.cross(bitangent, normal, tangent),\n                tangent\n              );\n            }\n          }\n        } else {\n          normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n          if (vertexFormat.tangent || vertexFormat.bitangent) {\n            if (perPositionHeight) {\n              scratchPerPosNormal = Cartesian3.fromArray(\n                normals,\n                attrIndex,\n                scratchPerPosNormal\n              );\n              scratchPerPosTangent = Cartesian3.cross(\n                Cartesian3.UNIT_Z,\n                scratchPerPosNormal,\n                scratchPerPosTangent\n              );\n              scratchPerPosTangent = Cartesian3.normalize(\n                Matrix3.multiplyByVector(\n                  tangentRotationMatrix,\n                  scratchPerPosTangent,\n                  scratchPerPosTangent\n                ),\n                scratchPerPosTangent\n              );\n              if (vertexFormat.bitangent) {\n                scratchPerPosBitangent = Cartesian3.normalize(\n                  Cartesian3.cross(\n                    scratchPerPosNormal,\n                    scratchPerPosTangent,\n                    scratchPerPosBitangent\n                  ),\n                  scratchPerPosBitangent\n                );\n              }\n            }\n\n            tangent = Cartesian3.cross(Cartesian3.UNIT_Z, normal, tangent);\n            tangent = Cartesian3.normalize(\n              Matrix3.multiplyByVector(tangentRotationMatrix, tangent, tangent),\n              tangent\n            );\n            if (vertexFormat.bitangent) {\n              bitangent = Cartesian3.normalize(\n                Cartesian3.cross(normal, tangent, bitangent),\n                bitangent\n              );\n            }\n          }\n        }\n\n        if (vertexFormat.normal) {\n          if (options.wall) {\n            normals[attrIndex + bottomOffset] = normal.x;\n            normals[attrIndex1 + bottomOffset] = normal.y;\n            normals[attrIndex2 + bottomOffset] = normal.z;\n          } else if (bottom) {\n            normals[attrIndex + bottomOffset] = -normal.x;\n            normals[attrIndex1 + bottomOffset] = -normal.y;\n            normals[attrIndex2 + bottomOffset] = -normal.z;\n          }\n\n          if ((top && !perPositionHeight) || wall) {\n            normals[attrIndex] = normal.x;\n            normals[attrIndex1] = normal.y;\n            normals[attrIndex2] = normal.z;\n          }\n        }\n\n        if (shadowVolume) {\n          if (wall) {\n            normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n          }\n          extrudeNormals[attrIndex + bottomOffset] = -normal.x;\n          extrudeNormals[attrIndex1 + bottomOffset] = -normal.y;\n          extrudeNormals[attrIndex2 + bottomOffset] = -normal.z;\n        }\n\n        if (vertexFormat.tangent) {\n          if (options.wall) {\n            tangents[attrIndex + bottomOffset] = tangent.x;\n            tangents[attrIndex1 + bottomOffset] = tangent.y;\n            tangents[attrIndex2 + bottomOffset] = tangent.z;\n          } else if (bottom) {\n            tangents[attrIndex + bottomOffset] = -tangent.x;\n            tangents[attrIndex1 + bottomOffset] = -tangent.y;\n            tangents[attrIndex2 + bottomOffset] = -tangent.z;\n          }\n\n          if (top) {\n            if (perPositionHeight) {\n              tangents[attrIndex] = scratchPerPosTangent.x;\n              tangents[attrIndex1] = scratchPerPosTangent.y;\n              tangents[attrIndex2] = scratchPerPosTangent.z;\n            } else {\n              tangents[attrIndex] = tangent.x;\n              tangents[attrIndex1] = tangent.y;\n              tangents[attrIndex2] = tangent.z;\n            }\n          }\n        }\n\n        if (vertexFormat.bitangent) {\n          if (bottom) {\n            bitangents[attrIndex + bottomOffset] = bitangent.x;\n            bitangents[attrIndex1 + bottomOffset] = bitangent.y;\n            bitangents[attrIndex2 + bottomOffset] = bitangent.z;\n          }\n          if (top) {\n            if (perPositionHeight) {\n              bitangents[attrIndex] = scratchPerPosBitangent.x;\n              bitangents[attrIndex1] = scratchPerPosBitangent.y;\n              bitangents[attrIndex2] = scratchPerPosBitangent.z;\n            } else {\n              bitangents[attrIndex] = bitangent.x;\n              bitangents[attrIndex1] = bitangent.y;\n              bitangents[attrIndex2] = bitangent.z;\n            }\n          }\n        }\n        attrIndex += 3;\n      }\n    }\n\n    if (vertexFormat.st) {\n      geometry.attributes.st = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 2,\n        values: textureCoordinates,\n      });\n    }\n\n    if (vertexFormat.normal) {\n      geometry.attributes.normal = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n        values: normals,\n      });\n    }\n\n    if (vertexFormat.tangent) {\n      geometry.attributes.tangent = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n        values: tangents,\n      });\n    }\n\n    if (vertexFormat.bitangent) {\n      geometry.attributes.bitangent = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n        values: bitangents,\n      });\n    }\n\n    if (shadowVolume) {\n      geometry.attributes.extrudeDirection = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n        values: extrudeNormals,\n      });\n    }\n  }\n\n  if (options.extrude && defined(options.offsetAttribute)) {\n    var size = flatPositions.length / 3;\n    var offsetAttribute = new Uint8Array(size);\n\n    if (options.offsetAttribute === GeometryOffsetAttribute.TOP) {\n      if ((top && bottom) || wall) {\n        offsetAttribute = arrayFill(offsetAttribute, 1, 0, size / 2);\n      } else if (top) {\n        offsetAttribute = arrayFill(offsetAttribute, 1);\n      }\n    } else {\n      var offsetValue =\n        options.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n      offsetAttribute = arrayFill(offsetAttribute, offsetValue);\n    }\n\n    geometry.attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: offsetAttribute,\n    });\n  }\n\n  return geometry;\n}\n\nvar startCartographicScratch = new Cartographic();\nvar endCartographicScratch = new Cartographic();\nvar idlCross = {\n  westOverIDL: 0.0,\n  eastOverIDL: 0.0,\n};\nvar ellipsoidGeodesic = new EllipsoidGeodesic();\nfunction computeRectangle(positions, ellipsoid, arcType, granularity, result) {\n  result = defaultValue(result, new Rectangle());\n  if (!defined(positions) || positions.length < 3) {\n    result.west = 0.0;\n    result.north = 0.0;\n    result.south = 0.0;\n    result.east = 0.0;\n    return result;\n  }\n\n  if (arcType === ArcType.RHUMB) {\n    return Rectangle.fromCartesianArray(positions, ellipsoid, result);\n  }\n\n  if (!ellipsoidGeodesic.ellipsoid.equals(ellipsoid)) {\n    ellipsoidGeodesic = new EllipsoidGeodesic(undefined, undefined, ellipsoid);\n  }\n\n  result.west = Number.POSITIVE_INFINITY;\n  result.east = Number.NEGATIVE_INFINITY;\n  result.south = Number.POSITIVE_INFINITY;\n  result.north = Number.NEGATIVE_INFINITY;\n\n  idlCross.westOverIDL = Number.POSITIVE_INFINITY;\n  idlCross.eastOverIDL = Number.NEGATIVE_INFINITY;\n\n  var inverseChordLength =\n    1.0 / CesiumMath.chordLength(granularity, ellipsoid.maximumRadius);\n  var positionsLength = positions.length;\n  var endCartographic = ellipsoid.cartesianToCartographic(\n    positions[0],\n    endCartographicScratch\n  );\n  var startCartographic = startCartographicScratch;\n  var swap;\n\n  for (var i = 1; i < positionsLength; i++) {\n    swap = startCartographic;\n    startCartographic = endCartographic;\n    endCartographic = ellipsoid.cartesianToCartographic(positions[i], swap);\n    ellipsoidGeodesic.setEndPoints(startCartographic, endCartographic);\n    interpolateAndGrowRectangle(\n      ellipsoidGeodesic,\n      inverseChordLength,\n      result,\n      idlCross\n    );\n  }\n\n  swap = startCartographic;\n  startCartographic = endCartographic;\n  endCartographic = ellipsoid.cartesianToCartographic(positions[0], swap);\n  ellipsoidGeodesic.setEndPoints(startCartographic, endCartographic);\n  interpolateAndGrowRectangle(\n    ellipsoidGeodesic,\n    inverseChordLength,\n    result,\n    idlCross\n  );\n\n  if (result.east - result.west > idlCross.eastOverIDL - idlCross.westOverIDL) {\n    result.west = idlCross.westOverIDL;\n    result.east = idlCross.eastOverIDL;\n\n    if (result.east > CesiumMath.PI) {\n      result.east = result.east - CesiumMath.TWO_PI;\n    }\n    if (result.west > CesiumMath.PI) {\n      result.west = result.west - CesiumMath.TWO_PI;\n    }\n  }\n\n  return result;\n}\n\nvar interpolatedCartographicScratch = new Cartographic();\nfunction interpolateAndGrowRectangle(\n  ellipsoidGeodesic,\n  inverseChordLength,\n  result,\n  idlCross\n) {\n  var segmentLength = ellipsoidGeodesic.surfaceDistance;\n\n  var numPoints = Math.ceil(segmentLength * inverseChordLength);\n  var subsegmentDistance =\n    numPoints > 0 ? segmentLength / (numPoints - 1) : Number.POSITIVE_INFINITY;\n  var interpolationDistance = 0.0;\n\n  for (var i = 0; i < numPoints; i++) {\n    var interpolatedCartographic = ellipsoidGeodesic.interpolateUsingSurfaceDistance(\n      interpolationDistance,\n      interpolatedCartographicScratch\n    );\n    interpolationDistance += subsegmentDistance;\n    var longitude = interpolatedCartographic.longitude;\n    var latitude = interpolatedCartographic.latitude;\n\n    result.west = Math.min(result.west, longitude);\n    result.east = Math.max(result.east, longitude);\n    result.south = Math.min(result.south, latitude);\n    result.north = Math.max(result.north, latitude);\n\n    var lonAdjusted =\n      longitude >= 0 ? longitude : longitude + CesiumMath.TWO_PI;\n    idlCross.westOverIDL = Math.min(idlCross.westOverIDL, lonAdjusted);\n    idlCross.eastOverIDL = Math.max(idlCross.eastOverIDL, lonAdjusted);\n  }\n}\n\nvar createGeometryFromPositionsExtrudedPositions = [];\n\nfunction createGeometryFromPositionsExtruded(\n  ellipsoid,\n  polygon,\n  granularity,\n  hierarchy,\n  perPositionHeight,\n  closeTop,\n  closeBottom,\n  vertexFormat,\n  arcType\n) {\n  var geos = {\n    walls: [],\n  };\n  var i;\n\n  if (closeTop || closeBottom) {\n    var topGeo = PolygonGeometryLibrary.createGeometryFromPositions(\n      ellipsoid,\n      polygon,\n      granularity,\n      perPositionHeight,\n      vertexFormat,\n      arcType\n    );\n\n    var edgePoints = topGeo.attributes.position.values;\n    var indices = topGeo.indices;\n    var numPositions;\n    var newIndices;\n\n    if (closeTop && closeBottom) {\n      var topBottomPositions = edgePoints.concat(edgePoints);\n\n      numPositions = topBottomPositions.length / 3;\n\n      newIndices = IndexDatatype.createTypedArray(\n        numPositions,\n        indices.length * 2\n      );\n      newIndices.set(indices);\n      var ilength = indices.length;\n\n      var length = numPositions / 2;\n\n      for (i = 0; i < ilength; i += 3) {\n        var i0 = newIndices[i] + length;\n        var i1 = newIndices[i + 1] + length;\n        var i2 = newIndices[i + 2] + length;\n\n        newIndices[i + ilength] = i2;\n        newIndices[i + 1 + ilength] = i1;\n        newIndices[i + 2 + ilength] = i0;\n      }\n\n      topGeo.attributes.position.values = topBottomPositions;\n      if (perPositionHeight && vertexFormat.normal) {\n        var normals = topGeo.attributes.normal.values;\n        topGeo.attributes.normal.values = new Float32Array(\n          topBottomPositions.length\n        );\n        topGeo.attributes.normal.values.set(normals);\n      }\n      topGeo.indices = newIndices;\n    } else if (closeBottom) {\n      numPositions = edgePoints.length / 3;\n      newIndices = IndexDatatype.createTypedArray(numPositions, indices.length);\n\n      for (i = 0; i < indices.length; i += 3) {\n        newIndices[i] = indices[i + 2];\n        newIndices[i + 1] = indices[i + 1];\n        newIndices[i + 2] = indices[i];\n      }\n\n      topGeo.indices = newIndices;\n    }\n\n    geos.topAndBottom = new GeometryInstance({\n      geometry: topGeo,\n    });\n  }\n\n  var outerRing = hierarchy.outerRing;\n  var tangentPlane = EllipsoidTangentPlane.fromPoints(outerRing, ellipsoid);\n  var positions2D = tangentPlane.projectPointsOntoPlane(\n    outerRing,\n    createGeometryFromPositionsExtrudedPositions\n  );\n\n  var windingOrder = PolygonPipeline.computeWindingOrder2D(positions2D);\n  if (windingOrder === WindingOrder.CLOCKWISE) {\n    outerRing = outerRing.slice().reverse();\n  }\n\n  var wallGeo = PolygonGeometryLibrary.computeWallGeometry(\n    outerRing,\n    ellipsoid,\n    granularity,\n    perPositionHeight,\n    arcType\n  );\n  geos.walls.push(\n    new GeometryInstance({\n      geometry: wallGeo,\n    })\n  );\n\n  var holes = hierarchy.holes;\n  for (i = 0; i < holes.length; i++) {\n    var hole = holes[i];\n\n    tangentPlane = EllipsoidTangentPlane.fromPoints(hole, ellipsoid);\n    positions2D = tangentPlane.projectPointsOntoPlane(\n      hole,\n      createGeometryFromPositionsExtrudedPositions\n    );\n\n    windingOrder = PolygonPipeline.computeWindingOrder2D(positions2D);\n    if (windingOrder === WindingOrder.COUNTER_CLOCKWISE) {\n      hole = hole.slice().reverse();\n    }\n\n    wallGeo = PolygonGeometryLibrary.computeWallGeometry(\n      hole,\n      ellipsoid,\n      granularity,\n      perPositionHeight,\n      arcType\n    );\n    geos.walls.push(\n      new GeometryInstance({\n        geometry: wallGeo,\n      })\n    );\n  }\n\n  return geos;\n}\n\n/**\n * A description of a polygon on the ellipsoid. The polygon is defined by a polygon hierarchy. Polygon geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.\n *\n * @alias PolygonGeometry\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {PolygonHierarchy} options.polygonHierarchy A polygon hierarchy that can include holes.\n * @param {Number} [options.height=0.0] The distance in meters between the polygon and the ellipsoid surface.\n * @param {Number} [options.extrudedHeight] The distance in meters between the polygon's extruded face and the ellipsoid surface.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n * @param {Number} [options.stRotation=0.0] The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {Boolean} [options.perPositionHeight=false] Use the height of options.positions for each position instead of using options.height to determine the height.\n * @param {Boolean} [options.closeTop=true] When false, leaves off the top of an extruded polygon open.\n * @param {Boolean} [options.closeBottom=true] When false, leaves off the bottom of an extruded polygon open.\n * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polygon edges must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\n *\n * @see PolygonGeometry#createGeometry\n * @see PolygonGeometry#fromPositions\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Polygon.html|Cesium Sandcastle Polygon Demo}\n *\n * @example\n * // 1. create a polygon from points\n * var polygon = new Cesium.PolygonGeometry({\n *   polygonHierarchy : new Cesium.PolygonHierarchy(\n *     Cesium.Cartesian3.fromDegreesArray([\n *       -72.0, 40.0,\n *       -70.0, 35.0,\n *       -75.0, 30.0,\n *       -70.0, 30.0,\n *       -68.0, 40.0\n *     ])\n *   )\n * });\n * var geometry = Cesium.PolygonGeometry.createGeometry(polygon);\n *\n * // 2. create a nested polygon with holes\n * var polygonWithHole = new Cesium.PolygonGeometry({\n *   polygonHierarchy : new Cesium.PolygonHierarchy(\n *     Cesium.Cartesian3.fromDegreesArray([\n *       -109.0, 30.0,\n *       -95.0, 30.0,\n *       -95.0, 40.0,\n *       -109.0, 40.0\n *     ]),\n *     [new Cesium.PolygonHierarchy(\n *       Cesium.Cartesian3.fromDegreesArray([\n *         -107.0, 31.0,\n *         -107.0, 39.0,\n *         -97.0, 39.0,\n *         -97.0, 31.0\n *       ]),\n *       [new Cesium.PolygonHierarchy(\n *         Cesium.Cartesian3.fromDegreesArray([\n *           -105.0, 33.0,\n *           -99.0, 33.0,\n *           -99.0, 37.0,\n *           -105.0, 37.0\n *         ]),\n *         [new Cesium.PolygonHierarchy(\n *           Cesium.Cartesian3.fromDegreesArray([\n *             -103.0, 34.0,\n *             -101.0, 34.0,\n *             -101.0, 36.0,\n *             -103.0, 36.0\n *           ])\n *         )]\n *       )]\n *     )]\n *   )\n * });\n * var geometry = Cesium.PolygonGeometry.createGeometry(polygonWithHole);\n *\n * // 3. create extruded polygon\n * var extrudedPolygon = new Cesium.PolygonGeometry({\n *   polygonHierarchy : new Cesium.PolygonHierarchy(\n *     Cesium.Cartesian3.fromDegreesArray([\n *       -72.0, 40.0,\n *       -70.0, 35.0,\n *       -75.0, 30.0,\n *       -70.0, 30.0,\n *       -68.0, 40.0\n *     ])\n *   ),\n *   extrudedHeight: 300000\n * });\n * var geometry = Cesium.PolygonGeometry.createGeometry(extrudedPolygon);\n */\nfunction PolygonGeometry(options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options\", options);\n  Check.typeOf.object(\"options.polygonHierarchy\", options.polygonHierarchy);\n  if (\n    defined(options.perPositionHeight) &&\n    options.perPositionHeight &&\n    defined(options.height)\n  ) {\n    throw new DeveloperError(\n      \"Cannot use both options.perPositionHeight and options.height\"\n    );\n  }\n  if (\n    defined(options.arcType) &&\n    options.arcType !== ArcType.GEODESIC &&\n    options.arcType !== ArcType.RHUMB\n  ) {\n    throw new DeveloperError(\n      \"Invalid arcType. Valid options are ArcType.GEODESIC and ArcType.RHUMB.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var polygonHierarchy = options.polygonHierarchy;\n  var vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);\n  var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n  var granularity = defaultValue(\n    options.granularity,\n    CesiumMath.RADIANS_PER_DEGREE\n  );\n  var stRotation = defaultValue(options.stRotation, 0.0);\n  var perPositionHeight = defaultValue(options.perPositionHeight, false);\n  var perPositionHeightExtrude =\n    perPositionHeight && defined(options.extrudedHeight);\n  var height = defaultValue(options.height, 0.0);\n  var extrudedHeight = defaultValue(options.extrudedHeight, height);\n\n  if (!perPositionHeightExtrude) {\n    var h = Math.max(height, extrudedHeight);\n    extrudedHeight = Math.min(height, extrudedHeight);\n    height = h;\n  }\n\n  this._vertexFormat = VertexFormat.clone(vertexFormat);\n  this._ellipsoid = Ellipsoid.clone(ellipsoid);\n  this._granularity = granularity;\n  this._stRotation = stRotation;\n  this._height = height;\n  this._extrudedHeight = extrudedHeight;\n  this._closeTop = defaultValue(options.closeTop, true);\n  this._closeBottom = defaultValue(options.closeBottom, true);\n  this._polygonHierarchy = polygonHierarchy;\n  this._perPositionHeight = perPositionHeight;\n  this._perPositionHeightExtrude = perPositionHeightExtrude;\n  this._shadowVolume = defaultValue(options.shadowVolume, false);\n  this._workerName = \"createPolygonGeometry\";\n  this._offsetAttribute = options.offsetAttribute;\n  this._arcType = defaultValue(options.arcType, ArcType.GEODESIC);\n\n  this._rectangle = undefined;\n  this._textureCoordinateRotationPoints = undefined;\n\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {Number}\n   */\n  this.packedLength =\n    PolygonGeometryLibrary.computeHierarchyPackedLength(polygonHierarchy) +\n    Ellipsoid.packedLength +\n    VertexFormat.packedLength +\n    12;\n}\n\n/**\n * A description of a polygon from an array of positions. Polygon geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.\n *\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions An array of positions that defined the corner points of the polygon.\n * @param {Number} [options.height=0.0] The height of the polygon.\n * @param {Number} [options.extrudedHeight] The height of the polygon extrusion.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n * @param {Number} [options.stRotation=0.0] The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {Boolean} [options.perPositionHeight=false] Use the height of options.positions for each position instead of using options.height to determine the height.\n * @param {Boolean} [options.closeTop=true] When false, leaves off the top of an extruded polygon open.\n * @param {Boolean} [options.closeBottom=true] When false, leaves off the bottom of an extruded polygon open.\n * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polygon edges must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\n * @returns {PolygonGeometry}\n *\n *\n * @example\n * // create a polygon from points\n * var polygon = Cesium.PolygonGeometry.fromPositions({\n *   positions : Cesium.Cartesian3.fromDegreesArray([\n *     -72.0, 40.0,\n *     -70.0, 35.0,\n *     -75.0, 30.0,\n *     -70.0, 30.0,\n *     -68.0, 40.0\n *   ])\n * });\n * var geometry = Cesium.PolygonGeometry.createGeometry(polygon);\n *\n * @see PolygonGeometry#createGeometry\n */\nPolygonGeometry.fromPositions = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.positions\", options.positions);\n  //>>includeEnd('debug');\n\n  var newOptions = {\n    polygonHierarchy: {\n      positions: options.positions,\n    },\n    height: options.height,\n    extrudedHeight: options.extrudedHeight,\n    vertexFormat: options.vertexFormat,\n    stRotation: options.stRotation,\n    ellipsoid: options.ellipsoid,\n    granularity: options.granularity,\n    perPositionHeight: options.perPositionHeight,\n    closeTop: options.closeTop,\n    closeBottom: options.closeBottom,\n    offsetAttribute: options.offsetAttribute,\n    arcType: options.arcType,\n  };\n  return new PolygonGeometry(newOptions);\n};\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {PolygonGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nPolygonGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  startingIndex = PolygonGeometryLibrary.packPolygonHierarchy(\n    value._polygonHierarchy,\n    array,\n    startingIndex\n  );\n\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n\n  VertexFormat.pack(value._vertexFormat, array, startingIndex);\n  startingIndex += VertexFormat.packedLength;\n\n  array[startingIndex++] = value._height;\n  array[startingIndex++] = value._extrudedHeight;\n  array[startingIndex++] = value._granularity;\n  array[startingIndex++] = value._stRotation;\n  array[startingIndex++] = value._perPositionHeightExtrude ? 1.0 : 0.0;\n  array[startingIndex++] = value._perPositionHeight ? 1.0 : 0.0;\n  array[startingIndex++] = value._closeTop ? 1.0 : 0.0;\n  array[startingIndex++] = value._closeBottom ? 1.0 : 0.0;\n  array[startingIndex++] = value._shadowVolume ? 1.0 : 0.0;\n  array[startingIndex++] = defaultValue(value._offsetAttribute, -1);\n  array[startingIndex++] = value._arcType;\n  array[startingIndex] = value.packedLength;\n\n  return array;\n};\n\nvar scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\nvar scratchVertexFormat = new VertexFormat();\n\n//Only used to avoid inability to default construct.\nvar dummyOptions = {\n  polygonHierarchy: {},\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {PolygonGeometry} [result] The object into which to store the result.\n */\nPolygonGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  var polygonHierarchy = PolygonGeometryLibrary.unpackPolygonHierarchy(\n    array,\n    startingIndex\n  );\n  startingIndex = polygonHierarchy.startingIndex;\n  delete polygonHierarchy.startingIndex;\n\n  var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += Ellipsoid.packedLength;\n\n  var vertexFormat = VertexFormat.unpack(\n    array,\n    startingIndex,\n    scratchVertexFormat\n  );\n  startingIndex += VertexFormat.packedLength;\n\n  var height = array[startingIndex++];\n  var extrudedHeight = array[startingIndex++];\n  var granularity = array[startingIndex++];\n  var stRotation = array[startingIndex++];\n  var perPositionHeightExtrude = array[startingIndex++] === 1.0;\n  var perPositionHeight = array[startingIndex++] === 1.0;\n  var closeTop = array[startingIndex++] === 1.0;\n  var closeBottom = array[startingIndex++] === 1.0;\n  var shadowVolume = array[startingIndex++] === 1.0;\n  var offsetAttribute = array[startingIndex++];\n  var arcType = array[startingIndex++];\n  var packedLength = array[startingIndex];\n\n  if (!defined(result)) {\n    result = new PolygonGeometry(dummyOptions);\n  }\n\n  result._polygonHierarchy = polygonHierarchy;\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n  result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n  result._height = height;\n  result._extrudedHeight = extrudedHeight;\n  result._granularity = granularity;\n  result._stRotation = stRotation;\n  result._perPositionHeightExtrude = perPositionHeightExtrude;\n  result._perPositionHeight = perPositionHeight;\n  result._closeTop = closeTop;\n  result._closeBottom = closeBottom;\n  result._shadowVolume = shadowVolume;\n  result._offsetAttribute =\n    offsetAttribute === -1 ? undefined : offsetAttribute;\n  result._arcType = arcType;\n  result.packedLength = packedLength;\n  return result;\n};\n\n/**\n * Returns the bounding rectangle given the provided options\n *\n * @param {Object} options Object with the following properties:\n * @param {PolygonHierarchy} options.polygonHierarchy A polygon hierarchy that can include holes.\n * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions sampled.\n * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polygon edges must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n * @param {Rectangle} [result] An object in which to store the result.\n *\n * @returns {Rectangle} The result rectangle\n */\nPolygonGeometry.computeRectangle = function (options, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options\", options);\n  Check.typeOf.object(\"options.polygonHierarchy\", options.polygonHierarchy);\n  //>>includeEnd('debug');\n\n  var granularity = defaultValue(\n    options.granularity,\n    CesiumMath.RADIANS_PER_DEGREE\n  );\n  var arcType = defaultValue(options.arcType, ArcType.GEODESIC);\n  //>>includeStart('debug', pragmas.debug);\n  if (arcType !== ArcType.GEODESIC && arcType !== ArcType.RHUMB) {\n    throw new DeveloperError(\n      \"Invalid arcType. Valid options are ArcType.GEODESIC and ArcType.RHUMB.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var polygonHierarchy = options.polygonHierarchy;\n  var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n\n  return computeRectangle(\n    polygonHierarchy.positions,\n    ellipsoid,\n    arcType,\n    granularity,\n    result\n  );\n};\n\n/**\n * Computes the geometric representation of a polygon, including its vertices, indices, and a bounding sphere.\n *\n * @param {PolygonGeometry} polygonGeometry A description of the polygon.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nPolygonGeometry.createGeometry = function (polygonGeometry) {\n  var vertexFormat = polygonGeometry._vertexFormat;\n  var ellipsoid = polygonGeometry._ellipsoid;\n  var granularity = polygonGeometry._granularity;\n  var stRotation = polygonGeometry._stRotation;\n  var polygonHierarchy = polygonGeometry._polygonHierarchy;\n  var perPositionHeight = polygonGeometry._perPositionHeight;\n  var closeTop = polygonGeometry._closeTop;\n  var closeBottom = polygonGeometry._closeBottom;\n  var arcType = polygonGeometry._arcType;\n\n  var outerPositions = polygonHierarchy.positions;\n  if (outerPositions.length < 3) {\n    return;\n  }\n\n  var tangentPlane = EllipsoidTangentPlane.fromPoints(\n    outerPositions,\n    ellipsoid\n  );\n\n  var results = PolygonGeometryLibrary.polygonsFromHierarchy(\n    polygonHierarchy,\n    tangentPlane.projectPointsOntoPlane.bind(tangentPlane),\n    !perPositionHeight,\n    ellipsoid\n  );\n\n  var hierarchy = results.hierarchy;\n  var polygons = results.polygons;\n\n  if (hierarchy.length === 0) {\n    return;\n  }\n\n  outerPositions = hierarchy[0].outerRing;\n  var boundingRectangle = PolygonGeometryLibrary.computeBoundingRectangle(\n    tangentPlane.plane.normal,\n    tangentPlane.projectPointOntoPlane.bind(tangentPlane),\n    outerPositions,\n    stRotation,\n    scratchBoundingRectangle\n  );\n\n  var geometries = [];\n\n  var height = polygonGeometry._height;\n  var extrudedHeight = polygonGeometry._extrudedHeight;\n  var extrude =\n    polygonGeometry._perPositionHeightExtrude ||\n    !CesiumMath.equalsEpsilon(height, extrudedHeight, 0, CesiumMath.EPSILON2);\n\n  var options = {\n    perPositionHeight: perPositionHeight,\n    vertexFormat: vertexFormat,\n    geometry: undefined,\n    tangentPlane: tangentPlane,\n    boundingRectangle: boundingRectangle,\n    ellipsoid: ellipsoid,\n    stRotation: stRotation,\n    bottom: false,\n    top: true,\n    wall: false,\n    extrude: false,\n    arcType: arcType,\n  };\n\n  var i;\n\n  if (extrude) {\n    options.extrude = true;\n    options.top = closeTop;\n    options.bottom = closeBottom;\n    options.shadowVolume = polygonGeometry._shadowVolume;\n    options.offsetAttribute = polygonGeometry._offsetAttribute;\n    for (i = 0; i < polygons.length; i++) {\n      var splitGeometry = createGeometryFromPositionsExtruded(\n        ellipsoid,\n        polygons[i],\n        granularity,\n        hierarchy[i],\n        perPositionHeight,\n        closeTop,\n        closeBottom,\n        vertexFormat,\n        arcType\n      );\n\n      var topAndBottom;\n      if (closeTop && closeBottom) {\n        topAndBottom = splitGeometry.topAndBottom;\n        options.geometry = PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(\n          topAndBottom.geometry,\n          height,\n          extrudedHeight,\n          ellipsoid,\n          perPositionHeight\n        );\n      } else if (closeTop) {\n        topAndBottom = splitGeometry.topAndBottom;\n        topAndBottom.geometry.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(\n          topAndBottom.geometry.attributes.position.values,\n          height,\n          ellipsoid,\n          !perPositionHeight\n        );\n        options.geometry = topAndBottom.geometry;\n      } else if (closeBottom) {\n        topAndBottom = splitGeometry.topAndBottom;\n        topAndBottom.geometry.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(\n          topAndBottom.geometry.attributes.position.values,\n          extrudedHeight,\n          ellipsoid,\n          true\n        );\n        options.geometry = topAndBottom.geometry;\n      }\n      if (closeTop || closeBottom) {\n        options.wall = false;\n        topAndBottom.geometry = computeAttributes(options);\n        geometries.push(topAndBottom);\n      }\n\n      var walls = splitGeometry.walls;\n      options.wall = true;\n      for (var k = 0; k < walls.length; k++) {\n        var wall = walls[k];\n        options.geometry = PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(\n          wall.geometry,\n          height,\n          extrudedHeight,\n          ellipsoid,\n          perPositionHeight\n        );\n        wall.geometry = computeAttributes(options);\n        geometries.push(wall);\n      }\n    }\n  } else {\n    for (i = 0; i < polygons.length; i++) {\n      var geometryInstance = new GeometryInstance({\n        geometry: PolygonGeometryLibrary.createGeometryFromPositions(\n          ellipsoid,\n          polygons[i],\n          granularity,\n          perPositionHeight,\n          vertexFormat,\n          arcType\n        ),\n      });\n      geometryInstance.geometry.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(\n        geometryInstance.geometry.attributes.position.values,\n        height,\n        ellipsoid,\n        !perPositionHeight\n      );\n      options.geometry = geometryInstance.geometry;\n      geometryInstance.geometry = computeAttributes(options);\n\n      if (defined(polygonGeometry._offsetAttribute)) {\n        var length =\n          geometryInstance.geometry.attributes.position.values.length;\n        var applyOffset = new Uint8Array(length / 3);\n        var offsetValue =\n          polygonGeometry._offsetAttribute === GeometryOffsetAttribute.NONE\n            ? 0\n            : 1;\n        arrayFill(applyOffset, offsetValue);\n        geometryInstance.geometry.attributes.applyOffset = new GeometryAttribute(\n          {\n            componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n            componentsPerAttribute: 1,\n            values: applyOffset,\n          }\n        );\n      }\n\n      geometries.push(geometryInstance);\n    }\n  }\n\n  var geometry = GeometryPipeline.combineInstances(geometries)[0];\n  geometry.attributes.position.values = new Float64Array(\n    geometry.attributes.position.values\n  );\n  geometry.indices = IndexDatatype.createTypedArray(\n    geometry.attributes.position.values.length / 3,\n    geometry.indices\n  );\n\n  var attributes = geometry.attributes;\n  var boundingSphere = BoundingSphere.fromVertices(attributes.position.values);\n\n  if (!vertexFormat.position) {\n    delete attributes.position;\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: geometry.indices,\n    primitiveType: geometry.primitiveType,\n    boundingSphere: boundingSphere,\n    offsetAttribute: polygonGeometry._offsetAttribute,\n  });\n};\n\n/**\n * @private\n */\nPolygonGeometry.createShadowVolume = function (\n  polygonGeometry,\n  minHeightFunc,\n  maxHeightFunc\n) {\n  var granularity = polygonGeometry._granularity;\n  var ellipsoid = polygonGeometry._ellipsoid;\n\n  var minHeight = minHeightFunc(granularity, ellipsoid);\n  var maxHeight = maxHeightFunc(granularity, ellipsoid);\n\n  return new PolygonGeometry({\n    polygonHierarchy: polygonGeometry._polygonHierarchy,\n    ellipsoid: ellipsoid,\n    stRotation: polygonGeometry._stRotation,\n    granularity: granularity,\n    perPositionHeight: false,\n    extrudedHeight: minHeight,\n    height: maxHeight,\n    vertexFormat: VertexFormat.POSITION_ONLY,\n    shadowVolume: true,\n    arcType: polygonGeometry._arcType,\n  });\n};\n\nfunction textureCoordinateRotationPoints(polygonGeometry) {\n  var stRotation = -polygonGeometry._stRotation;\n  if (stRotation === 0.0) {\n    return [0, 0, 0, 1, 1, 0];\n  }\n  var ellipsoid = polygonGeometry._ellipsoid;\n  var positions = polygonGeometry._polygonHierarchy.positions;\n  var boundingRectangle = polygonGeometry.rectangle;\n  return Geometry._textureCoordinateRotationPoints(\n    positions,\n    stRotation,\n    ellipsoid,\n    boundingRectangle\n  );\n}\n\nObject.defineProperties(PolygonGeometry.prototype, {\n  /**\n   * @private\n   */\n  rectangle: {\n    get: function () {\n      if (!defined(this._rectangle)) {\n        var positions = this._polygonHierarchy.positions;\n        this._rectangle = computeRectangle(\n          positions,\n          this._ellipsoid,\n          this._arcType,\n          this._granularity\n        );\n      }\n\n      return this._rectangle;\n    },\n  },\n  /**\n   * For remapping texture coordinates when rendering PolygonGeometries as GroundPrimitives.\n   * @private\n   */\n  textureCoordinateRotationPoints: {\n    get: function () {\n      if (!defined(this._textureCoordinateRotationPoints)) {\n        this._textureCoordinateRotationPoints = textureCoordinateRotationPoints(\n          this\n        );\n      }\n      return this._textureCoordinateRotationPoints;\n    },\n  },\n});\nexport default PolygonGeometry;\n","import defined from \"../Core/defined.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport PolygonGeometry from \"../Core/PolygonGeometry.js\";\n\nfunction createPolygonGeometry(polygonGeometry, offset) {\n  if (defined(offset)) {\n    polygonGeometry = PolygonGeometry.unpack(polygonGeometry, offset);\n  }\n  polygonGeometry._ellipsoid = Ellipsoid.clone(polygonGeometry._ellipsoid);\n  return PolygonGeometry.createGeometry(polygonGeometry);\n}\nexport default createPolygonGeometry;\n"],"names":["scratchCarto1","Cartographic","scratchCarto2","scratchBoundingRectangle","BoundingRectangle","scratchPosition","Cartesian3","scratchNormal","scratchTangent","scratchBitangent","p1Scratch","p2Scratch","scratchPerPosNormal","scratchPerPosTangent","scratchPerPosBitangent","appendTextureCoordinatesOrigin","Cartesian2","appendTextureCoordinatesCartesian2","appendTextureCoordinatesCartesian3","appendTextureCoordinatesQuaternion","Quaternion","appendTextureCoordinatesMatrix3","Matrix3","tangentMatrixScratch","computeAttributes","options","size","offsetValue","offsetAttribute","vertexFormat","geometry","shadowVolume","flatPositions","attributes","position","values","length","wall","top","bottom","st","normal","tangent","bitangent","boundingRectangle","tangentPlane","ellipsoid","stRotation","perPositionHeight","origin","x","y","normals","textureCoordinates","Float32Array","undefined","rotation","tangents","bitangents","extrudeNormals","textureCoordIndex","attrIndex","recomputeNormal","textureMatrix","tangentRotationMatrix","fromAxisAngle","_plane","fromQuaternion","clone","IDENTITY","bottomOffset","bottomOffset2","i","p","stx","sty","attrIndex1","attrIndex2","p1","p2","fromArray","multiplyByVector","scaleToGeodeticSurface","projectPointOntoPlane","subtract","CesiumMath","clamp","width","height","cartesianToCartographic","p1Carto","cartographicToCartesian","p2Carto","adjustPosHeightsForNormal","normalize","cross","equalsEpsilon","EPSILON10","geodeticSurfaceNormal","UNIT_Z","z","GeometryAttribute","componentDatatype","ComponentDatatype","FLOAT","componentsPerAttribute","extrudeDirection","extrude","defined","Uint8Array","GeometryOffsetAttribute","TOP","arrayFill","NONE","applyOffset","UNSIGNED_BYTE","startCartographicScratch","endCartographicScratch","idlCross","westOverIDL","eastOverIDL","ellipsoidGeodesic","EllipsoidGeodesic","computeRectangle","positions","arcType","granularity","result","defaultValue","Rectangle","west","north","south","east","ArcType","RHUMB","fromCartesianArray","equals","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","swap","inverseChordLength","chordLength","maximumRadius","positionsLength","endCartographic","startCartographic","setEndPoints","interpolateAndGrowRectangle","PI","TWO_PI","interpolatedCartographicScratch","segmentLength","surfaceDistance","numPoints","Math","ceil","subsegmentDistance","interpolationDistance","interpolatedCartographic","interpolateUsingSurfaceDistance","longitude","latitude","min","max","lonAdjusted","createGeometryFromPositionsExtrudedPositions","PolygonGeometry","Check","typeOf","object","polygonHierarchy","DeveloperError","GEODESIC","h","VertexFormat","DEFAULT","Ellipsoid","WGS84","RADIANS_PER_DEGREE","perPositionHeightExtrude","extrudedHeight","this","_vertexFormat","_ellipsoid","_granularity","_stRotation","_height","_extrudedHeight","_closeTop","closeTop","_closeBottom","closeBottom","_polygonHierarchy","_perPositionHeight","_perPositionHeightExtrude","_shadowVolume","_workerName","_offsetAttribute","_arcType","_rectangle","_textureCoordinateRotationPoints","packedLength","PolygonGeometryLibrary","computeHierarchyPackedLength","fromPositions","EMPTY_OBJECT","pack","value","array","startingIndex","packPolygonHierarchy","scratchEllipsoid","UNIT_SPHERE","scratchVertexFormat","dummyOptions","unpack","unpackPolygonHierarchy","createGeometry","polygonGeometry","outerPositions","EllipsoidTangentPlane","fromPoints","results","polygonsFromHierarchy","projectPointsOntoPlane","bind","hierarchy","polygons","outerRing","computeBoundingRectangle","plane","geometries","EPSILON2","topAndBottom","splitGeometry","polygon","geos","walls","topGeo","createGeometryFromPositions","edgePoints","indices","newIndices","topBottomPositions","concat","numPositions","IndexDatatype","createTypedArray","set","ilength","i0","i1","i2","GeometryInstance","positions2D","PolygonPipeline","computeWindingOrder2D","WindingOrder","CLOCKWISE","slice","reverse","wallGeo","computeWallGeometry","push","holes","hole","COUNTER_CLOCKWISE","createGeometryFromPositionsExtruded","scaleToGeodeticHeightExtruded","scaleToGeodeticHeight","k","geometryInstance","GeometryPipeline","combineInstances","Float64Array","boundingSphere","BoundingSphere","fromVertices","Geometry","primitiveType","createShadowVolume","minHeightFunc","maxHeightFunc","minHeight","maxHeight","POSITION_ONLY","Object","defineProperties","prototype","rectangle","get","textureCoordinateRotationPoints","offset"],"mappings":"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"}