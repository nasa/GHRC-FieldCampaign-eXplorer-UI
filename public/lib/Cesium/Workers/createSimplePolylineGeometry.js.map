{"version":3,"file":"createSimplePolylineGeometry.js","sources":["../../../../Source/Core/SimplePolylineGeometry.js","../../../../Source/WorkersES6/createSimplePolylineGeometry.js"],"sourcesContent":["import ArcType from \"./ArcType.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Color from \"./Color.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport PolylinePipeline from \"./PolylinePipeline.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\n\nfunction interpolateColors(p0, p1, color0, color1, minDistance, array, offset) {\n  var numPoints = PolylinePipeline.numberOfPoints(p0, p1, minDistance);\n  var i;\n\n  var r0 = color0.red;\n  var g0 = color0.green;\n  var b0 = color0.blue;\n  var a0 = color0.alpha;\n\n  var r1 = color1.red;\n  var g1 = color1.green;\n  var b1 = color1.blue;\n  var a1 = color1.alpha;\n\n  if (Color.equals(color0, color1)) {\n    for (i = 0; i < numPoints; i++) {\n      array[offset++] = Color.floatToByte(r0);\n      array[offset++] = Color.floatToByte(g0);\n      array[offset++] = Color.floatToByte(b0);\n      array[offset++] = Color.floatToByte(a0);\n    }\n    return offset;\n  }\n\n  var redPerVertex = (r1 - r0) / numPoints;\n  var greenPerVertex = (g1 - g0) / numPoints;\n  var bluePerVertex = (b1 - b0) / numPoints;\n  var alphaPerVertex = (a1 - a0) / numPoints;\n\n  var index = offset;\n  for (i = 0; i < numPoints; i++) {\n    array[index++] = Color.floatToByte(r0 + i * redPerVertex);\n    array[index++] = Color.floatToByte(g0 + i * greenPerVertex);\n    array[index++] = Color.floatToByte(b0 + i * bluePerVertex);\n    array[index++] = Color.floatToByte(a0 + i * alphaPerVertex);\n  }\n\n  return index;\n}\n\n/**\n * A description of a polyline modeled as a line strip; the first two positions define a line segment,\n * and each additional position defines a line segment from the previous position.\n *\n * @alias SimplePolylineGeometry\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions An array of {@link Cartesian3} defining the positions in the polyline as a line strip.\n * @param {Color[]} [options.colors] An Array of {@link Color} defining the per vertex or per segment colors.\n * @param {Boolean} [options.colorsPerVertex=false] A boolean that determines whether the colors will be flat across each segment of the line or interpolated across the vertices.\n * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polyline segments must follow.\n * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude if options.arcType is not ArcType.NONE. Determines the number of positions in the buffer.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n *\n * @exception {DeveloperError} At least two positions are required.\n * @exception {DeveloperError} colors has an invalid length.\n *\n * @see SimplePolylineGeometry#createGeometry\n *\n * @example\n * // A polyline with two connected line segments\n * var polyline = new Cesium.SimplePolylineGeometry({\n *   positions : Cesium.Cartesian3.fromDegreesArray([\n *     0.0, 0.0,\n *     5.0, 0.0,\n *     5.0, 5.0\n *   ])\n * });\n * var geometry = Cesium.SimplePolylineGeometry.createGeometry(polyline);\n */\nfunction SimplePolylineGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var positions = options.positions;\n  var colors = options.colors;\n  var colorsPerVertex = defaultValue(options.colorsPerVertex, false);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(positions) || positions.length < 2) {\n    throw new DeveloperError(\"At least two positions are required.\");\n  }\n  if (\n    defined(colors) &&\n    ((colorsPerVertex && colors.length < positions.length) ||\n      (!colorsPerVertex && colors.length < positions.length - 1))\n  ) {\n    throw new DeveloperError(\"colors has an invalid length.\");\n  }\n  //>>includeEnd('debug');\n\n  this._positions = positions;\n  this._colors = colors;\n  this._colorsPerVertex = colorsPerVertex;\n\n  this._arcType = defaultValue(options.arcType, ArcType.GEODESIC);\n  this._granularity = defaultValue(\n    options.granularity,\n    CesiumMath.RADIANS_PER_DEGREE\n  );\n  this._ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n  this._workerName = \"createSimplePolylineGeometry\";\n\n  var numComponents = 1 + positions.length * Cartesian3.packedLength;\n  numComponents += defined(colors) ? 1 + colors.length * Color.packedLength : 1;\n\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {Number}\n   */\n  this.packedLength = numComponents + Ellipsoid.packedLength + 3;\n}\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {SimplePolylineGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nSimplePolylineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required\");\n  }\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  var i;\n\n  var positions = value._positions;\n  var length = positions.length;\n  array[startingIndex++] = length;\n\n  for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n    Cartesian3.pack(positions[i], array, startingIndex);\n  }\n\n  var colors = value._colors;\n  length = defined(colors) ? colors.length : 0.0;\n  array[startingIndex++] = length;\n\n  for (i = 0; i < length; ++i, startingIndex += Color.packedLength) {\n    Color.pack(colors[i], array, startingIndex);\n  }\n\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n\n  array[startingIndex++] = value._colorsPerVertex ? 1.0 : 0.0;\n  array[startingIndex++] = value._arcType;\n  array[startingIndex] = value._granularity;\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {SimplePolylineGeometry} [result] The object into which to store the result.\n * @returns {SimplePolylineGeometry} The modified result parameter or a new SimplePolylineGeometry instance if one was not provided.\n */\nSimplePolylineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  var i;\n\n  var length = array[startingIndex++];\n  var positions = new Array(length);\n\n  for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n    positions[i] = Cartesian3.unpack(array, startingIndex);\n  }\n\n  length = array[startingIndex++];\n  var colors = length > 0 ? new Array(length) : undefined;\n\n  for (i = 0; i < length; ++i, startingIndex += Color.packedLength) {\n    colors[i] = Color.unpack(array, startingIndex);\n  }\n\n  var ellipsoid = Ellipsoid.unpack(array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n\n  var colorsPerVertex = array[startingIndex++] === 1.0;\n  var arcType = array[startingIndex++];\n  var granularity = array[startingIndex];\n\n  if (!defined(result)) {\n    return new SimplePolylineGeometry({\n      positions: positions,\n      colors: colors,\n      ellipsoid: ellipsoid,\n      colorsPerVertex: colorsPerVertex,\n      arcType: arcType,\n      granularity: granularity,\n    });\n  }\n\n  result._positions = positions;\n  result._colors = colors;\n  result._ellipsoid = ellipsoid;\n  result._colorsPerVertex = colorsPerVertex;\n  result._arcType = arcType;\n  result._granularity = granularity;\n\n  return result;\n};\n\nvar scratchArray1 = new Array(2);\nvar scratchArray2 = new Array(2);\nvar generateArcOptionsScratch = {\n  positions: scratchArray1,\n  height: scratchArray2,\n  ellipsoid: undefined,\n  minDistance: undefined,\n  granularity: undefined,\n};\n\n/**\n * Computes the geometric representation of a simple polyline, including its vertices, indices, and a bounding sphere.\n *\n * @param {SimplePolylineGeometry} simplePolylineGeometry A description of the polyline.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nSimplePolylineGeometry.createGeometry = function (simplePolylineGeometry) {\n  var positions = simplePolylineGeometry._positions;\n  var colors = simplePolylineGeometry._colors;\n  var colorsPerVertex = simplePolylineGeometry._colorsPerVertex;\n  var arcType = simplePolylineGeometry._arcType;\n  var granularity = simplePolylineGeometry._granularity;\n  var ellipsoid = simplePolylineGeometry._ellipsoid;\n\n  var minDistance = CesiumMath.chordLength(\n    granularity,\n    ellipsoid.maximumRadius\n  );\n  var perSegmentColors = defined(colors) && !colorsPerVertex;\n\n  var i;\n  var length = positions.length;\n\n  var positionValues;\n  var numberOfPositions;\n  var colorValues;\n  var color;\n  var offset = 0;\n\n  if (arcType === ArcType.GEODESIC || arcType === ArcType.RHUMB) {\n    var subdivisionSize;\n    var numberOfPointsFunction;\n    var generateArcFunction;\n    if (arcType === ArcType.GEODESIC) {\n      subdivisionSize = CesiumMath.chordLength(\n        granularity,\n        ellipsoid.maximumRadius\n      );\n      numberOfPointsFunction = PolylinePipeline.numberOfPoints;\n      generateArcFunction = PolylinePipeline.generateArc;\n    } else {\n      subdivisionSize = granularity;\n      numberOfPointsFunction = PolylinePipeline.numberOfPointsRhumbLine;\n      generateArcFunction = PolylinePipeline.generateRhumbArc;\n    }\n\n    var heights = PolylinePipeline.extractHeights(positions, ellipsoid);\n\n    var generateArcOptions = generateArcOptionsScratch;\n    if (arcType === ArcType.GEODESIC) {\n      generateArcOptions.minDistance = minDistance;\n    } else {\n      generateArcOptions.granularity = granularity;\n    }\n    generateArcOptions.ellipsoid = ellipsoid;\n\n    if (perSegmentColors) {\n      var positionCount = 0;\n      for (i = 0; i < length - 1; i++) {\n        positionCount +=\n          numberOfPointsFunction(\n            positions[i],\n            positions[i + 1],\n            subdivisionSize\n          ) + 1;\n      }\n\n      positionValues = new Float64Array(positionCount * 3);\n      colorValues = new Uint8Array(positionCount * 4);\n\n      generateArcOptions.positions = scratchArray1;\n      generateArcOptions.height = scratchArray2;\n\n      var ci = 0;\n      for (i = 0; i < length - 1; ++i) {\n        scratchArray1[0] = positions[i];\n        scratchArray1[1] = positions[i + 1];\n\n        scratchArray2[0] = heights[i];\n        scratchArray2[1] = heights[i + 1];\n\n        var pos = generateArcFunction(generateArcOptions);\n\n        if (defined(colors)) {\n          var segLen = pos.length / 3;\n          color = colors[i];\n          for (var k = 0; k < segLen; ++k) {\n            colorValues[ci++] = Color.floatToByte(color.red);\n            colorValues[ci++] = Color.floatToByte(color.green);\n            colorValues[ci++] = Color.floatToByte(color.blue);\n            colorValues[ci++] = Color.floatToByte(color.alpha);\n          }\n        }\n\n        positionValues.set(pos, offset);\n        offset += pos.length;\n      }\n    } else {\n      generateArcOptions.positions = positions;\n      generateArcOptions.height = heights;\n      positionValues = new Float64Array(\n        generateArcFunction(generateArcOptions)\n      );\n\n      if (defined(colors)) {\n        colorValues = new Uint8Array((positionValues.length / 3) * 4);\n\n        for (i = 0; i < length - 1; ++i) {\n          var p0 = positions[i];\n          var p1 = positions[i + 1];\n          var c0 = colors[i];\n          var c1 = colors[i + 1];\n          offset = interpolateColors(\n            p0,\n            p1,\n            c0,\n            c1,\n            minDistance,\n            colorValues,\n            offset\n          );\n        }\n\n        var lastColor = colors[length - 1];\n        colorValues[offset++] = Color.floatToByte(lastColor.red);\n        colorValues[offset++] = Color.floatToByte(lastColor.green);\n        colorValues[offset++] = Color.floatToByte(lastColor.blue);\n        colorValues[offset++] = Color.floatToByte(lastColor.alpha);\n      }\n    }\n  } else {\n    numberOfPositions = perSegmentColors ? length * 2 - 2 : length;\n    positionValues = new Float64Array(numberOfPositions * 3);\n    colorValues = defined(colors)\n      ? new Uint8Array(numberOfPositions * 4)\n      : undefined;\n\n    var positionIndex = 0;\n    var colorIndex = 0;\n\n    for (i = 0; i < length; ++i) {\n      var p = positions[i];\n\n      if (perSegmentColors && i > 0) {\n        Cartesian3.pack(p, positionValues, positionIndex);\n        positionIndex += 3;\n\n        color = colors[i - 1];\n        colorValues[colorIndex++] = Color.floatToByte(color.red);\n        colorValues[colorIndex++] = Color.floatToByte(color.green);\n        colorValues[colorIndex++] = Color.floatToByte(color.blue);\n        colorValues[colorIndex++] = Color.floatToByte(color.alpha);\n      }\n\n      if (perSegmentColors && i === length - 1) {\n        break;\n      }\n\n      Cartesian3.pack(p, positionValues, positionIndex);\n      positionIndex += 3;\n\n      if (defined(colors)) {\n        color = colors[i];\n        colorValues[colorIndex++] = Color.floatToByte(color.red);\n        colorValues[colorIndex++] = Color.floatToByte(color.green);\n        colorValues[colorIndex++] = Color.floatToByte(color.blue);\n        colorValues[colorIndex++] = Color.floatToByte(color.alpha);\n      }\n    }\n  }\n\n  var attributes = new GeometryAttributes();\n  attributes.position = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.DOUBLE,\n    componentsPerAttribute: 3,\n    values: positionValues,\n  });\n\n  if (defined(colors)) {\n    attributes.color = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 4,\n      values: colorValues,\n      normalize: true,\n    });\n  }\n\n  numberOfPositions = positionValues.length / 3;\n  var numberOfIndices = (numberOfPositions - 1) * 2;\n  var indices = IndexDatatype.createTypedArray(\n    numberOfPositions,\n    numberOfIndices\n  );\n\n  var index = 0;\n  for (i = 0; i < numberOfPositions - 1; ++i) {\n    indices[index++] = i;\n    indices[index++] = i + 1;\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: PrimitiveType.LINES,\n    boundingSphere: BoundingSphere.fromPoints(positions),\n  });\n};\nexport default SimplePolylineGeometry;\n","import defined from \"../Core/defined.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport SimplePolylineGeometry from \"../Core/SimplePolylineGeometry.js\";\n\nfunction createSimplePolylineGeometry(simplePolylineGeometry, offset) {\n  if (defined(offset)) {\n    simplePolylineGeometry = SimplePolylineGeometry.unpack(\n      simplePolylineGeometry,\n      offset\n    );\n  }\n  simplePolylineGeometry._ellipsoid = Ellipsoid.clone(\n    simplePolylineGeometry._ellipsoid\n  );\n  return SimplePolylineGeometry.createGeometry(simplePolylineGeometry);\n}\nexport default createSimplePolylineGeometry;\n"],"names":["SimplePolylineGeometry","options","positions","defaultValue","EMPTY_OBJECT","colors","colorsPerVertex","defined","length","DeveloperError","this","_positions","_colors","_colorsPerVertex","_arcType","arcType","ArcType","GEODESIC","_granularity","granularity","CesiumMath","RADIANS_PER_DEGREE","_ellipsoid","ellipsoid","Ellipsoid","WGS84","_workerName","numComponents","Cartesian3","packedLength","Color","pack","value","array","startingIndex","i","unpack","result","Array","undefined","scratchArray1","scratchArray2","generateArcOptionsScratch","height","minDistance","createGeometry","simplePolylineGeometry","positionValues","numberOfPositions","colorValues","chordLength","maximumRadius","perSegmentColors","offset","RHUMB","subdivisionSize","numberOfPointsFunction","generateArcFunction","PolylinePipeline","numberOfPoints","generateArc","numberOfPointsRhumbLine","generateRhumbArc","heights","extractHeights","generateArcOptions","positionCount","Float64Array","Uint8Array","ci","pos","segLen","color","k","floatToByte","red","green","blue","alpha","set","p0","p1","color0","color1","numPoints","r0","g0","b0","a0","r1","g1","b1","a1","equals","redPerVertex","greenPerVertex","bluePerVertex","alphaPerVertex","index","interpolateColors","lastColor","positionIndex","colorIndex","p","attributes","GeometryAttributes","position","GeometryAttribute","componentDatatype","ComponentDatatype","DOUBLE","componentsPerAttribute","values","UNSIGNED_BYTE","normalize","numberOfIndices","indices","IndexDatatype","createTypedArray","Geometry","primitiveType","PrimitiveType","LINES","boundingSphere","BoundingSphere","fromPoints","clone"],"mappings":"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"}