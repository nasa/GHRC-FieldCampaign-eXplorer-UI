{"version":3,"file":"GeometryPipeline-abf0a505.js","sources":["../../../../Source/Core/barycentricCoordinates.js","../../../../Source/Core/Tipsify.js","../../../../Source/Core/GeometryPipeline.js"],"sourcesContent":["import Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defined from \"./defined.js\";\nimport CesiumMath from \"./Math.js\";\n\nvar scratchCartesian1 = new Cartesian3();\nvar scratchCartesian2 = new Cartesian3();\nvar scratchCartesian3 = new Cartesian3();\n\n/**\n * Computes the barycentric coordinates for a point with respect to a triangle.\n *\n * @function\n *\n * @param {Cartesian2|Cartesian3} point The point to test.\n * @param {Cartesian2|Cartesian3} p0 The first point of the triangle, corresponding to the barycentric x-axis.\n * @param {Cartesian2|Cartesian3} p1 The second point of the triangle, corresponding to the barycentric y-axis.\n * @param {Cartesian2|Cartesian3} p2 The third point of the triangle, corresponding to the barycentric z-axis.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n *\n * @example\n * // Returns Cartesian3.UNIT_X\n * var p = new Cesium.Cartesian3(-1.0, 0.0, 0.0);\n * var b = Cesium.barycentricCoordinates(p,\n *   new Cesium.Cartesian3(-1.0, 0.0, 0.0),\n *   new Cesium.Cartesian3( 1.0, 0.0, 0.0),\n *   new Cesium.Cartesian3( 0.0, 1.0, 1.0));\n */\nfunction barycentricCoordinates(point, p0, p1, p2, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"point\", point);\n  Check.defined(\"p0\", p0);\n  Check.defined(\"p1\", p1);\n  Check.defined(\"p2\", p2);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  // Implementation based on http://www.blackpawn.com/texts/pointinpoly/default.html.\n  var v0;\n  var v1;\n  var v2;\n  var dot00;\n  var dot01;\n  var dot02;\n  var dot11;\n  var dot12;\n\n  if (!defined(p0.z)) {\n    if (Cartesian2.equalsEpsilon(point, p0, CesiumMath.EPSILON14)) {\n      return Cartesian3.clone(Cartesian3.UNIT_X, result);\n    }\n    if (Cartesian2.equalsEpsilon(point, p1, CesiumMath.EPSILON14)) {\n      return Cartesian3.clone(Cartesian3.UNIT_Y, result);\n    }\n    if (Cartesian2.equalsEpsilon(point, p2, CesiumMath.EPSILON14)) {\n      return Cartesian3.clone(Cartesian3.UNIT_Z, result);\n    }\n\n    v0 = Cartesian2.subtract(p1, p0, scratchCartesian1);\n    v1 = Cartesian2.subtract(p2, p0, scratchCartesian2);\n    v2 = Cartesian2.subtract(point, p0, scratchCartesian3);\n\n    dot00 = Cartesian2.dot(v0, v0);\n    dot01 = Cartesian2.dot(v0, v1);\n    dot02 = Cartesian2.dot(v0, v2);\n    dot11 = Cartesian2.dot(v1, v1);\n    dot12 = Cartesian2.dot(v1, v2);\n  } else {\n    if (Cartesian3.equalsEpsilon(point, p0, CesiumMath.EPSILON14)) {\n      return Cartesian3.clone(Cartesian3.UNIT_X, result);\n    }\n    if (Cartesian3.equalsEpsilon(point, p1, CesiumMath.EPSILON14)) {\n      return Cartesian3.clone(Cartesian3.UNIT_Y, result);\n    }\n    if (Cartesian3.equalsEpsilon(point, p2, CesiumMath.EPSILON14)) {\n      return Cartesian3.clone(Cartesian3.UNIT_Z, result);\n    }\n\n    v0 = Cartesian3.subtract(p1, p0, scratchCartesian1);\n    v1 = Cartesian3.subtract(p2, p0, scratchCartesian2);\n    v2 = Cartesian3.subtract(point, p0, scratchCartesian3);\n\n    dot00 = Cartesian3.dot(v0, v0);\n    dot01 = Cartesian3.dot(v0, v1);\n    dot02 = Cartesian3.dot(v0, v2);\n    dot11 = Cartesian3.dot(v1, v1);\n    dot12 = Cartesian3.dot(v1, v2);\n  }\n\n  result.y = dot11 * dot02 - dot01 * dot12;\n  result.z = dot00 * dot12 - dot01 * dot02;\n  var q = dot00 * dot11 - dot01 * dot01;\n\n  // This is done to avoid dividing by infinity causing a NaN\n  if (result.y !== 0) {\n    result.y /= q;\n  }\n  if (result.z !== 0) {\n    result.z /= q;\n  }\n\n  result.x = 1.0 - result.y - result.z;\n  return result;\n}\nexport default barycentricCoordinates;\n","import defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\n\n/**\n * Encapsulates an algorithm to optimize triangles for the post\n * vertex-shader cache.  This is based on the 2007 SIGGRAPH paper\n * 'Fast Triangle Reordering for Vertex Locality and Reduced Overdraw.'\n * The runtime is linear but several passes are made.\n *\n * @namespace Tipsify\n *\n * @see <a href='http://gfx.cs.princeton.edu/pubs/Sander_2007_%3ETR/tipsy.pdf'>\n * Fast Triangle Reordering for Vertex Locality and Reduced Overdraw</a>\n * by Sander, Nehab, and Barczak\n *\n * @private\n */\nvar Tipsify = {};\n\n/**\n * Calculates the average cache miss ratio (ACMR) for a given set of indices.\n *\n * @param {Object} options Object with the following properties:\n * @param {Number[]} options.indices Lists triads of numbers corresponding to the indices of the vertices\n *                        in the vertex buffer that define the geometry's triangles.\n * @param {Number} [options.maximumIndex] The maximum value of the elements in <code>args.indices</code>.\n *                                     If not supplied, this value will be computed.\n * @param {Number} [options.cacheSize=24] The number of vertices that can be stored in the cache at any one time.\n * @returns {Number} The average cache miss ratio (ACMR).\n *\n * @exception {DeveloperError} indices length must be a multiple of three.\n * @exception {DeveloperError} cacheSize must be greater than two.\n *\n * @example\n * var indices = [0, 1, 2, 3, 4, 5];\n * var maxIndex = 5;\n * var cacheSize = 3;\n * var acmr = Cesium.Tipsify.calculateACMR({indices : indices, maxIndex : maxIndex, cacheSize : cacheSize});\n */\nTipsify.calculateACMR = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var indices = options.indices;\n  var maximumIndex = options.maximumIndex;\n  var cacheSize = defaultValue(options.cacheSize, 24);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(indices)) {\n    throw new DeveloperError(\"indices is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var numIndices = indices.length;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (numIndices < 3 || numIndices % 3 !== 0) {\n    throw new DeveloperError(\"indices length must be a multiple of three.\");\n  }\n  if (maximumIndex <= 0) {\n    throw new DeveloperError(\"maximumIndex must be greater than zero.\");\n  }\n  if (cacheSize < 3) {\n    throw new DeveloperError(\"cacheSize must be greater than two.\");\n  }\n  //>>includeEnd('debug');\n\n  // Compute the maximumIndex if not given\n  if (!defined(maximumIndex)) {\n    maximumIndex = 0;\n    var currentIndex = 0;\n    var intoIndices = indices[currentIndex];\n    while (currentIndex < numIndices) {\n      if (intoIndices > maximumIndex) {\n        maximumIndex = intoIndices;\n      }\n      ++currentIndex;\n      intoIndices = indices[currentIndex];\n    }\n  }\n\n  // Vertex time stamps\n  var vertexTimeStamps = [];\n  for (var i = 0; i < maximumIndex + 1; i++) {\n    vertexTimeStamps[i] = 0;\n  }\n\n  // Cache processing\n  var s = cacheSize + 1;\n  for (var j = 0; j < numIndices; ++j) {\n    if (s - vertexTimeStamps[indices[j]] > cacheSize) {\n      vertexTimeStamps[indices[j]] = s;\n      ++s;\n    }\n  }\n\n  return (s - cacheSize + 1) / (numIndices / 3);\n};\n\n/**\n * Optimizes triangles for the post-vertex shader cache.\n *\n * @param {Object} options Object with the following properties:\n * @param {Number[]} options.indices Lists triads of numbers corresponding to the indices of the vertices\n *                        in the vertex buffer that define the geometry's triangles.\n * @param {Number} [options.maximumIndex] The maximum value of the elements in <code>args.indices</code>.\n *                                     If not supplied, this value will be computed.\n * @param {Number} [options.cacheSize=24] The number of vertices that can be stored in the cache at any one time.\n * @returns {Number[]} A list of the input indices in an optimized order.\n *\n * @exception {DeveloperError} indices length must be a multiple of three.\n * @exception {DeveloperError} cacheSize must be greater than two.\n *\n * @example\n * var indices = [0, 1, 2, 3, 4, 5];\n * var maxIndex = 5;\n * var cacheSize = 3;\n * var reorderedIndices = Cesium.Tipsify.tipsify({indices : indices, maxIndex : maxIndex, cacheSize : cacheSize});\n */\nTipsify.tipsify = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var indices = options.indices;\n  var maximumIndex = options.maximumIndex;\n  var cacheSize = defaultValue(options.cacheSize, 24);\n\n  var cursor;\n\n  function skipDeadEnd(vertices, deadEnd, indices, maximumIndexPlusOne) {\n    while (deadEnd.length >= 1) {\n      // while the stack is not empty\n      var d = deadEnd[deadEnd.length - 1]; // top of the stack\n      deadEnd.splice(deadEnd.length - 1, 1); // pop the stack\n\n      if (vertices[d].numLiveTriangles > 0) {\n        return d;\n      }\n    }\n\n    while (cursor < maximumIndexPlusOne) {\n      if (vertices[cursor].numLiveTriangles > 0) {\n        ++cursor;\n        return cursor - 1;\n      }\n      ++cursor;\n    }\n    return -1;\n  }\n\n  function getNextVertex(\n    indices,\n    cacheSize,\n    oneRing,\n    vertices,\n    s,\n    deadEnd,\n    maximumIndexPlusOne\n  ) {\n    var n = -1;\n    var p;\n    var m = -1;\n    var itOneRing = 0;\n    while (itOneRing < oneRing.length) {\n      var index = oneRing[itOneRing];\n      if (vertices[index].numLiveTriangles) {\n        p = 0;\n        if (\n          s -\n            vertices[index].timeStamp +\n            2 * vertices[index].numLiveTriangles <=\n          cacheSize\n        ) {\n          p = s - vertices[index].timeStamp;\n        }\n        if (p > m || m === -1) {\n          m = p;\n          n = index;\n        }\n      }\n      ++itOneRing;\n    }\n    if (n === -1) {\n      return skipDeadEnd(vertices, deadEnd, indices, maximumIndexPlusOne);\n    }\n    return n;\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(indices)) {\n    throw new DeveloperError(\"indices is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var numIndices = indices.length;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (numIndices < 3 || numIndices % 3 !== 0) {\n    throw new DeveloperError(\"indices length must be a multiple of three.\");\n  }\n  if (maximumIndex <= 0) {\n    throw new DeveloperError(\"maximumIndex must be greater than zero.\");\n  }\n  if (cacheSize < 3) {\n    throw new DeveloperError(\"cacheSize must be greater than two.\");\n  }\n  //>>includeEnd('debug');\n\n  // Determine maximum index\n  var maximumIndexPlusOne = 0;\n  var currentIndex = 0;\n  var intoIndices = indices[currentIndex];\n  var endIndex = numIndices;\n  if (defined(maximumIndex)) {\n    maximumIndexPlusOne = maximumIndex + 1;\n  } else {\n    while (currentIndex < endIndex) {\n      if (intoIndices > maximumIndexPlusOne) {\n        maximumIndexPlusOne = intoIndices;\n      }\n      ++currentIndex;\n      intoIndices = indices[currentIndex];\n    }\n    if (maximumIndexPlusOne === -1) {\n      return 0;\n    }\n    ++maximumIndexPlusOne;\n  }\n\n  // Vertices\n  var vertices = [];\n  var i;\n  for (i = 0; i < maximumIndexPlusOne; i++) {\n    vertices[i] = {\n      numLiveTriangles: 0,\n      timeStamp: 0,\n      vertexTriangles: [],\n    };\n  }\n  currentIndex = 0;\n  var triangle = 0;\n  while (currentIndex < endIndex) {\n    vertices[indices[currentIndex]].vertexTriangles.push(triangle);\n    ++vertices[indices[currentIndex]].numLiveTriangles;\n    vertices[indices[currentIndex + 1]].vertexTriangles.push(triangle);\n    ++vertices[indices[currentIndex + 1]].numLiveTriangles;\n    vertices[indices[currentIndex + 2]].vertexTriangles.push(triangle);\n    ++vertices[indices[currentIndex + 2]].numLiveTriangles;\n    ++triangle;\n    currentIndex += 3;\n  }\n\n  // Starting index\n  var f = 0;\n\n  // Time Stamp\n  var s = cacheSize + 1;\n  cursor = 1;\n\n  // Process\n  var oneRing = [];\n  var deadEnd = []; //Stack\n  var vertex;\n  var intoVertices;\n  var currentOutputIndex = 0;\n  var outputIndices = [];\n  var numTriangles = numIndices / 3;\n  var triangleEmitted = [];\n  for (i = 0; i < numTriangles; i++) {\n    triangleEmitted[i] = false;\n  }\n  var index;\n  var limit;\n  while (f !== -1) {\n    oneRing = [];\n    intoVertices = vertices[f];\n    limit = intoVertices.vertexTriangles.length;\n    for (var k = 0; k < limit; ++k) {\n      triangle = intoVertices.vertexTriangles[k];\n      if (!triangleEmitted[triangle]) {\n        triangleEmitted[triangle] = true;\n        currentIndex = triangle + triangle + triangle;\n        for (var j = 0; j < 3; ++j) {\n          // Set this index as a possible next index\n          index = indices[currentIndex];\n          oneRing.push(index);\n          deadEnd.push(index);\n\n          // Output index\n          outputIndices[currentOutputIndex] = index;\n          ++currentOutputIndex;\n\n          // Cache processing\n          vertex = vertices[index];\n          --vertex.numLiveTriangles;\n          if (s - vertex.timeStamp > cacheSize) {\n            vertex.timeStamp = s;\n            ++s;\n          }\n          ++currentIndex;\n        }\n      }\n    }\n    f = getNextVertex(\n      indices,\n      cacheSize,\n      oneRing,\n      vertices,\n      s,\n      deadEnd,\n      maximumIndexPlusOne\n    );\n  }\n\n  return outputIndices;\n};\nexport default Tipsify;\n","import AttributeCompression from \"./AttributeCompression.js\";\nimport barycentricCoordinates from \"./barycentricCoordinates.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartesian4 from \"./Cartesian4.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport EncodedCartesian3 from \"./EncodedCartesian3.js\";\nimport GeographicProjection from \"./GeographicProjection.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryType from \"./GeometryType.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport Intersect from \"./Intersect.js\";\nimport IntersectionTests from \"./IntersectionTests.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport Plane from \"./Plane.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport Tipsify from \"./Tipsify.js\";\n\n/**\n * Content pipeline functions for geometries.\n *\n * @namespace GeometryPipeline\n *\n * @see Geometry\n */\nvar GeometryPipeline = {};\n\nfunction addTriangle(lines, index, i0, i1, i2) {\n  lines[index++] = i0;\n  lines[index++] = i1;\n\n  lines[index++] = i1;\n  lines[index++] = i2;\n\n  lines[index++] = i2;\n  lines[index] = i0;\n}\n\nfunction trianglesToLines(triangles) {\n  var count = triangles.length;\n  var size = (count / 3) * 6;\n  var lines = IndexDatatype.createTypedArray(count, size);\n\n  var index = 0;\n  for (var i = 0; i < count; i += 3, index += 6) {\n    addTriangle(lines, index, triangles[i], triangles[i + 1], triangles[i + 2]);\n  }\n\n  return lines;\n}\n\nfunction triangleStripToLines(triangles) {\n  var count = triangles.length;\n  if (count >= 3) {\n    var size = (count - 2) * 6;\n    var lines = IndexDatatype.createTypedArray(count, size);\n\n    addTriangle(lines, 0, triangles[0], triangles[1], triangles[2]);\n    var index = 6;\n\n    for (var i = 3; i < count; ++i, index += 6) {\n      addTriangle(\n        lines,\n        index,\n        triangles[i - 1],\n        triangles[i],\n        triangles[i - 2]\n      );\n    }\n\n    return lines;\n  }\n\n  return new Uint16Array();\n}\n\nfunction triangleFanToLines(triangles) {\n  if (triangles.length > 0) {\n    var count = triangles.length - 1;\n    var size = (count - 1) * 6;\n    var lines = IndexDatatype.createTypedArray(count, size);\n\n    var base = triangles[0];\n    var index = 0;\n    for (var i = 1; i < count; ++i, index += 6) {\n      addTriangle(lines, index, base, triangles[i], triangles[i + 1]);\n    }\n\n    return lines;\n  }\n\n  return new Uint16Array();\n}\n\n/**\n * Converts a geometry's triangle indices to line indices.  If the geometry has an <code>indices</code>\n * and its <code>primitiveType</code> is <code>TRIANGLES</code>, <code>TRIANGLE_STRIP</code>,\n * <code>TRIANGLE_FAN</code>, it is converted to <code>LINES</code>; otherwise, the geometry is not changed.\n * <p>\n * This is commonly used to create a wireframe geometry for visual debugging.\n * </p>\n *\n * @param {Geometry} geometry The geometry to modify.\n * @returns {Geometry} The modified <code>geometry</code> argument, with its triangle indices converted to lines.\n *\n * @exception {DeveloperError} geometry.primitiveType must be TRIANGLES, TRIANGLE_STRIP, or TRIANGLE_FAN.\n *\n * @example\n * geometry = Cesium.GeometryPipeline.toWireframe(geometry);\n */\nGeometryPipeline.toWireframe = function (geometry) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var indices = geometry.indices;\n  if (defined(indices)) {\n    switch (geometry.primitiveType) {\n      case PrimitiveType.TRIANGLES:\n        geometry.indices = trianglesToLines(indices);\n        break;\n      case PrimitiveType.TRIANGLE_STRIP:\n        geometry.indices = triangleStripToLines(indices);\n        break;\n      case PrimitiveType.TRIANGLE_FAN:\n        geometry.indices = triangleFanToLines(indices);\n        break;\n      //>>includeStart('debug', pragmas.debug);\n      default:\n        throw new DeveloperError(\n          \"geometry.primitiveType must be TRIANGLES, TRIANGLE_STRIP, or TRIANGLE_FAN.\"\n        );\n      //>>includeEnd('debug');\n    }\n\n    geometry.primitiveType = PrimitiveType.LINES;\n  }\n\n  return geometry;\n};\n\n/**\n * Creates a new {@link Geometry} with <code>LINES</code> representing the provided\n * attribute (<code>attributeName</code>) for the provided geometry.  This is used to\n * visualize vector attributes like normals, tangents, and bitangents.\n *\n * @param {Geometry} geometry The <code>Geometry</code> instance with the attribute.\n * @param {String} [attributeName='normal'] The name of the attribute.\n * @param {Number} [length=10000.0] The length of each line segment in meters.  This can be negative to point the vector in the opposite direction.\n * @returns {Geometry} A new <code>Geometry</code> instance with line segments for the vector.\n *\n * @exception {DeveloperError} geometry.attributes must have an attribute with the same name as the attributeName parameter.\n *\n * @example\n * var geometry = Cesium.GeometryPipeline.createLineSegmentsForVectors(instance.geometry, 'bitangent', 100000.0);\n */\nGeometryPipeline.createLineSegmentsForVectors = function (\n  geometry,\n  attributeName,\n  length\n) {\n  attributeName = defaultValue(attributeName, \"normal\");\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  }\n  if (!defined(geometry.attributes.position)) {\n    throw new DeveloperError(\"geometry.attributes.position is required.\");\n  }\n  if (!defined(geometry.attributes[attributeName])) {\n    throw new DeveloperError(\n      \"geometry.attributes must have an attribute with the same name as the attributeName parameter, \" +\n        attributeName +\n        \".\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  length = defaultValue(length, 10000.0);\n\n  var positions = geometry.attributes.position.values;\n  var vectors = geometry.attributes[attributeName].values;\n  var positionsLength = positions.length;\n\n  var newPositions = new Float64Array(2 * positionsLength);\n\n  var j = 0;\n  for (var i = 0; i < positionsLength; i += 3) {\n    newPositions[j++] = positions[i];\n    newPositions[j++] = positions[i + 1];\n    newPositions[j++] = positions[i + 2];\n\n    newPositions[j++] = positions[i] + vectors[i] * length;\n    newPositions[j++] = positions[i + 1] + vectors[i + 1] * length;\n    newPositions[j++] = positions[i + 2] + vectors[i + 2] * length;\n  }\n\n  var newBoundingSphere;\n  var bs = geometry.boundingSphere;\n  if (defined(bs)) {\n    newBoundingSphere = new BoundingSphere(bs.center, bs.radius + length);\n  }\n\n  return new Geometry({\n    attributes: {\n      position: new GeometryAttribute({\n        componentDatatype: ComponentDatatype.DOUBLE,\n        componentsPerAttribute: 3,\n        values: newPositions,\n      }),\n    },\n    primitiveType: PrimitiveType.LINES,\n    boundingSphere: newBoundingSphere,\n  });\n};\n\n/**\n * Creates an object that maps attribute names to unique locations (indices)\n * for matching vertex attributes and shader programs.\n *\n * @param {Geometry} geometry The geometry, which is not modified, to create the object for.\n * @returns {Object} An object with attribute name / index pairs.\n *\n * @example\n * var attributeLocations = Cesium.GeometryPipeline.createAttributeLocations(geometry);\n * // Example output\n * // {\n * //   'position' : 0,\n * //   'normal' : 1\n * // }\n */\nGeometryPipeline.createAttributeLocations = function (geometry) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  }\n  //>>includeEnd('debug')\n\n  // There can be a WebGL performance hit when attribute 0 is disabled, so\n  // assign attribute locations to well-known attributes.\n  var semantics = [\n    \"position\",\n    \"positionHigh\",\n    \"positionLow\",\n\n    // From VertexFormat.position - after 2D projection and high-precision encoding\n    \"position3DHigh\",\n    \"position3DLow\",\n    \"position2DHigh\",\n    \"position2DLow\",\n\n    // From Primitive\n    \"pickColor\",\n\n    // From VertexFormat\n    \"normal\",\n    \"st\",\n    \"tangent\",\n    \"bitangent\",\n\n    // For shadow volumes\n    \"extrudeDirection\",\n\n    // From compressing texture coordinates and normals\n    \"compressedAttributes\",\n  ];\n\n  var attributes = geometry.attributes;\n  var indices = {};\n  var j = 0;\n  var i;\n  var len = semantics.length;\n\n  // Attribute locations for well-known attributes\n  for (i = 0; i < len; ++i) {\n    var semantic = semantics[i];\n\n    if (defined(attributes[semantic])) {\n      indices[semantic] = j++;\n    }\n  }\n\n  // Locations for custom attributes\n  for (var name in attributes) {\n    if (attributes.hasOwnProperty(name) && !defined(indices[name])) {\n      indices[name] = j++;\n    }\n  }\n\n  return indices;\n};\n\n/**\n * Reorders a geometry's attributes and <code>indices</code> to achieve better performance from the GPU's pre-vertex-shader cache.\n *\n * @param {Geometry} geometry The geometry to modify.\n * @returns {Geometry} The modified <code>geometry</code> argument, with its attributes and indices reordered for the GPU's pre-vertex-shader cache.\n *\n * @exception {DeveloperError} Each attribute array in geometry.attributes must have the same number of attributes.\n *\n *\n * @example\n * geometry = Cesium.GeometryPipeline.reorderForPreVertexCache(geometry);\n *\n * @see GeometryPipeline.reorderForPostVertexCache\n */\nGeometryPipeline.reorderForPreVertexCache = function (geometry) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var numVertices = Geometry.computeNumberOfVertices(geometry);\n\n  var indices = geometry.indices;\n  if (defined(indices)) {\n    var indexCrossReferenceOldToNew = new Int32Array(numVertices);\n    for (var i = 0; i < numVertices; i++) {\n      indexCrossReferenceOldToNew[i] = -1;\n    }\n\n    // Construct cross reference and reorder indices\n    var indicesIn = indices;\n    var numIndices = indicesIn.length;\n    var indicesOut = IndexDatatype.createTypedArray(numVertices, numIndices);\n\n    var intoIndicesIn = 0;\n    var intoIndicesOut = 0;\n    var nextIndex = 0;\n    var tempIndex;\n    while (intoIndicesIn < numIndices) {\n      tempIndex = indexCrossReferenceOldToNew[indicesIn[intoIndicesIn]];\n      if (tempIndex !== -1) {\n        indicesOut[intoIndicesOut] = tempIndex;\n      } else {\n        tempIndex = indicesIn[intoIndicesIn];\n        indexCrossReferenceOldToNew[tempIndex] = nextIndex;\n\n        indicesOut[intoIndicesOut] = nextIndex;\n        ++nextIndex;\n      }\n      ++intoIndicesIn;\n      ++intoIndicesOut;\n    }\n    geometry.indices = indicesOut;\n\n    // Reorder attributes\n    var attributes = geometry.attributes;\n    for (var property in attributes) {\n      if (\n        attributes.hasOwnProperty(property) &&\n        defined(attributes[property]) &&\n        defined(attributes[property].values)\n      ) {\n        var attribute = attributes[property];\n        var elementsIn = attribute.values;\n        var intoElementsIn = 0;\n        var numComponents = attribute.componentsPerAttribute;\n        var elementsOut = ComponentDatatype.createTypedArray(\n          attribute.componentDatatype,\n          nextIndex * numComponents\n        );\n        while (intoElementsIn < numVertices) {\n          var temp = indexCrossReferenceOldToNew[intoElementsIn];\n          if (temp !== -1) {\n            for (var j = 0; j < numComponents; j++) {\n              elementsOut[numComponents * temp + j] =\n                elementsIn[numComponents * intoElementsIn + j];\n            }\n          }\n          ++intoElementsIn;\n        }\n        attribute.values = elementsOut;\n      }\n    }\n  }\n\n  return geometry;\n};\n\n/**\n * Reorders a geometry's <code>indices</code> to achieve better performance from the GPU's\n * post vertex-shader cache by using the Tipsify algorithm.  If the geometry <code>primitiveType</code>\n * is not <code>TRIANGLES</code> or the geometry does not have an <code>indices</code>, this function has no effect.\n *\n * @param {Geometry} geometry The geometry to modify.\n * @param {Number} [cacheCapacity=24] The number of vertices that can be held in the GPU's vertex cache.\n * @returns {Geometry} The modified <code>geometry</code> argument, with its indices reordered for the post-vertex-shader cache.\n *\n * @exception {DeveloperError} cacheCapacity must be greater than two.\n *\n *\n * @example\n * geometry = Cesium.GeometryPipeline.reorderForPostVertexCache(geometry);\n *\n * @see GeometryPipeline.reorderForPreVertexCache\n * @see {@link http://gfx.cs.princ0eton.edu/pubs/Sander_2007_%3ETR/tipsy.pdf|Fast Triangle Reordering for Vertex Locality and Reduced Overdraw}\n * by Sander, Nehab, and Barczak\n */\nGeometryPipeline.reorderForPostVertexCache = function (\n  geometry,\n  cacheCapacity\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var indices = geometry.indices;\n  if (geometry.primitiveType === PrimitiveType.TRIANGLES && defined(indices)) {\n    var numIndices = indices.length;\n    var maximumIndex = 0;\n    for (var j = 0; j < numIndices; j++) {\n      if (indices[j] > maximumIndex) {\n        maximumIndex = indices[j];\n      }\n    }\n    geometry.indices = Tipsify.tipsify({\n      indices: indices,\n      maximumIndex: maximumIndex,\n      cacheSize: cacheCapacity,\n    });\n  }\n\n  return geometry;\n};\n\nfunction copyAttributesDescriptions(attributes) {\n  var newAttributes = {};\n\n  for (var attribute in attributes) {\n    if (\n      attributes.hasOwnProperty(attribute) &&\n      defined(attributes[attribute]) &&\n      defined(attributes[attribute].values)\n    ) {\n      var attr = attributes[attribute];\n      newAttributes[attribute] = new GeometryAttribute({\n        componentDatatype: attr.componentDatatype,\n        componentsPerAttribute: attr.componentsPerAttribute,\n        normalize: attr.normalize,\n        values: [],\n      });\n    }\n  }\n\n  return newAttributes;\n}\n\nfunction copyVertex(destinationAttributes, sourceAttributes, index) {\n  for (var attribute in sourceAttributes) {\n    if (\n      sourceAttributes.hasOwnProperty(attribute) &&\n      defined(sourceAttributes[attribute]) &&\n      defined(sourceAttributes[attribute].values)\n    ) {\n      var attr = sourceAttributes[attribute];\n\n      for (var k = 0; k < attr.componentsPerAttribute; ++k) {\n        destinationAttributes[attribute].values.push(\n          attr.values[index * attr.componentsPerAttribute + k]\n        );\n      }\n    }\n  }\n}\n\n/**\n * Splits a geometry into multiple geometries, if necessary, to ensure that indices in the\n * <code>indices</code> fit into unsigned shorts.  This is used to meet the WebGL requirements\n * when unsigned int indices are not supported.\n * <p>\n * If the geometry does not have any <code>indices</code>, this function has no effect.\n * </p>\n *\n * @param {Geometry} geometry The geometry to be split into multiple geometries.\n * @returns {Geometry[]} An array of geometries, each with indices that fit into unsigned shorts.\n *\n * @exception {DeveloperError} geometry.primitiveType must equal to PrimitiveType.TRIANGLES, PrimitiveType.LINES, or PrimitiveType.POINTS\n * @exception {DeveloperError} All geometry attribute lists must have the same number of attributes.\n *\n * @example\n * var geometries = Cesium.GeometryPipeline.fitToUnsignedShortIndices(geometry);\n */\nGeometryPipeline.fitToUnsignedShortIndices = function (geometry) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  }\n  if (\n    defined(geometry.indices) &&\n    geometry.primitiveType !== PrimitiveType.TRIANGLES &&\n    geometry.primitiveType !== PrimitiveType.LINES &&\n    geometry.primitiveType !== PrimitiveType.POINTS\n  ) {\n    throw new DeveloperError(\n      \"geometry.primitiveType must equal to PrimitiveType.TRIANGLES, PrimitiveType.LINES, or PrimitiveType.POINTS.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var geometries = [];\n\n  // If there's an index list and more than 64K attributes, it is possible that\n  // some indices are outside the range of unsigned short [0, 64K - 1]\n  var numberOfVertices = Geometry.computeNumberOfVertices(geometry);\n  if (\n    defined(geometry.indices) &&\n    numberOfVertices >= CesiumMath.SIXTY_FOUR_KILOBYTES\n  ) {\n    var oldToNewIndex = [];\n    var newIndices = [];\n    var currentIndex = 0;\n    var newAttributes = copyAttributesDescriptions(geometry.attributes);\n\n    var originalIndices = geometry.indices;\n    var numberOfIndices = originalIndices.length;\n\n    var indicesPerPrimitive;\n\n    if (geometry.primitiveType === PrimitiveType.TRIANGLES) {\n      indicesPerPrimitive = 3;\n    } else if (geometry.primitiveType === PrimitiveType.LINES) {\n      indicesPerPrimitive = 2;\n    } else if (geometry.primitiveType === PrimitiveType.POINTS) {\n      indicesPerPrimitive = 1;\n    }\n\n    for (var j = 0; j < numberOfIndices; j += indicesPerPrimitive) {\n      for (var k = 0; k < indicesPerPrimitive; ++k) {\n        var x = originalIndices[j + k];\n        var i = oldToNewIndex[x];\n        if (!defined(i)) {\n          i = currentIndex++;\n          oldToNewIndex[x] = i;\n          copyVertex(newAttributes, geometry.attributes, x);\n        }\n        newIndices.push(i);\n      }\n\n      if (\n        currentIndex + indicesPerPrimitive >=\n        CesiumMath.SIXTY_FOUR_KILOBYTES\n      ) {\n        geometries.push(\n          new Geometry({\n            attributes: newAttributes,\n            indices: newIndices,\n            primitiveType: geometry.primitiveType,\n            boundingSphere: geometry.boundingSphere,\n            boundingSphereCV: geometry.boundingSphereCV,\n          })\n        );\n\n        // Reset for next vertex-array\n        oldToNewIndex = [];\n        newIndices = [];\n        currentIndex = 0;\n        newAttributes = copyAttributesDescriptions(geometry.attributes);\n      }\n    }\n\n    if (newIndices.length !== 0) {\n      geometries.push(\n        new Geometry({\n          attributes: newAttributes,\n          indices: newIndices,\n          primitiveType: geometry.primitiveType,\n          boundingSphere: geometry.boundingSphere,\n          boundingSphereCV: geometry.boundingSphereCV,\n        })\n      );\n    }\n  } else {\n    // No need to split into multiple geometries\n    geometries.push(geometry);\n  }\n\n  return geometries;\n};\n\nvar scratchProjectTo2DCartesian3 = new Cartesian3();\nvar scratchProjectTo2DCartographic = new Cartographic();\n\n/**\n * Projects a geometry's 3D <code>position</code> attribute to 2D, replacing the <code>position</code>\n * attribute with separate <code>position3D</code> and <code>position2D</code> attributes.\n * <p>\n * If the geometry does not have a <code>position</code>, this function has no effect.\n * </p>\n *\n * @param {Geometry} geometry The geometry to modify.\n * @param {String} attributeName The name of the attribute.\n * @param {String} attributeName3D The name of the attribute in 3D.\n * @param {String} attributeName2D The name of the attribute in 2D.\n * @param {Object} [projection=new GeographicProjection()] The projection to use.\n * @returns {Geometry} The modified <code>geometry</code> argument with <code>position3D</code> and <code>position2D</code> attributes.\n *\n * @exception {DeveloperError} geometry must have attribute matching the attributeName argument.\n * @exception {DeveloperError} The attribute componentDatatype must be ComponentDatatype.DOUBLE.\n * @exception {DeveloperError} Could not project a point to 2D.\n *\n * @example\n * geometry = Cesium.GeometryPipeline.projectTo2D(geometry, 'position', 'position3D', 'position2D');\n */\nGeometryPipeline.projectTo2D = function (\n  geometry,\n  attributeName,\n  attributeName3D,\n  attributeName2D,\n  projection\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  }\n  if (!defined(attributeName)) {\n    throw new DeveloperError(\"attributeName is required.\");\n  }\n  if (!defined(attributeName3D)) {\n    throw new DeveloperError(\"attributeName3D is required.\");\n  }\n  if (!defined(attributeName2D)) {\n    throw new DeveloperError(\"attributeName2D is required.\");\n  }\n  if (!defined(geometry.attributes[attributeName])) {\n    throw new DeveloperError(\n      \"geometry must have attribute matching the attributeName argument: \" +\n        attributeName +\n        \".\"\n    );\n  }\n  if (\n    geometry.attributes[attributeName].componentDatatype !==\n    ComponentDatatype.DOUBLE\n  ) {\n    throw new DeveloperError(\n      \"The attribute componentDatatype must be ComponentDatatype.DOUBLE.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var attribute = geometry.attributes[attributeName];\n  projection = defined(projection) ? projection : new GeographicProjection();\n  var ellipsoid = projection.ellipsoid;\n\n  // Project original values to 2D.\n  var values3D = attribute.values;\n  var projectedValues = new Float64Array(values3D.length);\n  var index = 0;\n\n  for (var i = 0; i < values3D.length; i += 3) {\n    var value = Cartesian3.fromArray(values3D, i, scratchProjectTo2DCartesian3);\n\n    var lonLat = ellipsoid.cartesianToCartographic(\n      value,\n      scratchProjectTo2DCartographic\n    );\n    //>>includeStart('debug', pragmas.debug);\n    if (!defined(lonLat)) {\n      throw new DeveloperError(\n        \"Could not project point (\" +\n          value.x +\n          \", \" +\n          value.y +\n          \", \" +\n          value.z +\n          \") to 2D.\"\n      );\n    }\n    //>>includeEnd('debug');\n\n    var projectedLonLat = projection.project(\n      lonLat,\n      scratchProjectTo2DCartesian3\n    );\n\n    projectedValues[index++] = projectedLonLat.x;\n    projectedValues[index++] = projectedLonLat.y;\n    projectedValues[index++] = projectedLonLat.z;\n  }\n\n  // Rename original cartesians to WGS84 cartesians.\n  geometry.attributes[attributeName3D] = attribute;\n\n  // Replace original cartesians with 2D projected cartesians\n  geometry.attributes[attributeName2D] = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.DOUBLE,\n    componentsPerAttribute: 3,\n    values: projectedValues,\n  });\n  delete geometry.attributes[attributeName];\n\n  return geometry;\n};\n\nvar encodedResult = {\n  high: 0.0,\n  low: 0.0,\n};\n\n/**\n * Encodes floating-point geometry attribute values as two separate attributes to improve\n * rendering precision.\n * <p>\n * This is commonly used to create high-precision position vertex attributes.\n * </p>\n *\n * @param {Geometry} geometry The geometry to modify.\n * @param {String} attributeName The name of the attribute.\n * @param {String} attributeHighName The name of the attribute for the encoded high bits.\n * @param {String} attributeLowName The name of the attribute for the encoded low bits.\n * @returns {Geometry} The modified <code>geometry</code> argument, with its encoded attribute.\n *\n * @exception {DeveloperError} geometry must have attribute matching the attributeName argument.\n * @exception {DeveloperError} The attribute componentDatatype must be ComponentDatatype.DOUBLE.\n *\n * @example\n * geometry = Cesium.GeometryPipeline.encodeAttribute(geometry, 'position3D', 'position3DHigh', 'position3DLow');\n */\nGeometryPipeline.encodeAttribute = function (\n  geometry,\n  attributeName,\n  attributeHighName,\n  attributeLowName\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  }\n  if (!defined(attributeName)) {\n    throw new DeveloperError(\"attributeName is required.\");\n  }\n  if (!defined(attributeHighName)) {\n    throw new DeveloperError(\"attributeHighName is required.\");\n  }\n  if (!defined(attributeLowName)) {\n    throw new DeveloperError(\"attributeLowName is required.\");\n  }\n  if (!defined(geometry.attributes[attributeName])) {\n    throw new DeveloperError(\n      \"geometry must have attribute matching the attributeName argument: \" +\n        attributeName +\n        \".\"\n    );\n  }\n  if (\n    geometry.attributes[attributeName].componentDatatype !==\n    ComponentDatatype.DOUBLE\n  ) {\n    throw new DeveloperError(\n      \"The attribute componentDatatype must be ComponentDatatype.DOUBLE.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var attribute = geometry.attributes[attributeName];\n  var values = attribute.values;\n  var length = values.length;\n  var highValues = new Float32Array(length);\n  var lowValues = new Float32Array(length);\n\n  for (var i = 0; i < length; ++i) {\n    EncodedCartesian3.encode(values[i], encodedResult);\n    highValues[i] = encodedResult.high;\n    lowValues[i] = encodedResult.low;\n  }\n\n  var componentsPerAttribute = attribute.componentsPerAttribute;\n\n  geometry.attributes[attributeHighName] = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: componentsPerAttribute,\n    values: highValues,\n  });\n  geometry.attributes[attributeLowName] = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: componentsPerAttribute,\n    values: lowValues,\n  });\n  delete geometry.attributes[attributeName];\n\n  return geometry;\n};\n\nvar scratchCartesian3 = new Cartesian3();\n\nfunction transformPoint(matrix, attribute) {\n  if (defined(attribute)) {\n    var values = attribute.values;\n    var length = values.length;\n    for (var i = 0; i < length; i += 3) {\n      Cartesian3.unpack(values, i, scratchCartesian3);\n      Matrix4.multiplyByPoint(matrix, scratchCartesian3, scratchCartesian3);\n      Cartesian3.pack(scratchCartesian3, values, i);\n    }\n  }\n}\n\nfunction transformVector(matrix, attribute) {\n  if (defined(attribute)) {\n    var values = attribute.values;\n    var length = values.length;\n    for (var i = 0; i < length; i += 3) {\n      Cartesian3.unpack(values, i, scratchCartesian3);\n      Matrix3.multiplyByVector(matrix, scratchCartesian3, scratchCartesian3);\n      scratchCartesian3 = Cartesian3.normalize(\n        scratchCartesian3,\n        scratchCartesian3\n      );\n      Cartesian3.pack(scratchCartesian3, values, i);\n    }\n  }\n}\n\nvar inverseTranspose = new Matrix4();\nvar normalMatrix = new Matrix3();\n\n/**\n * Transforms a geometry instance to world coordinates.  This changes\n * the instance's <code>modelMatrix</code> to {@link Matrix4.IDENTITY} and transforms the\n * following attributes if they are present: <code>position</code>, <code>normal</code>,\n * <code>tangent</code>, and <code>bitangent</code>.\n *\n * @param {GeometryInstance} instance The geometry instance to modify.\n * @returns {GeometryInstance} The modified <code>instance</code> argument, with its attributes transforms to world coordinates.\n *\n * @example\n * Cesium.GeometryPipeline.transformToWorldCoordinates(instance);\n */\nGeometryPipeline.transformToWorldCoordinates = function (instance) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(instance)) {\n    throw new DeveloperError(\"instance is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var modelMatrix = instance.modelMatrix;\n\n  if (Matrix4.equals(modelMatrix, Matrix4.IDENTITY)) {\n    // Already in world coordinates\n    return instance;\n  }\n\n  var attributes = instance.geometry.attributes;\n\n  // Transform attributes in known vertex formats\n  transformPoint(modelMatrix, attributes.position);\n  transformPoint(modelMatrix, attributes.prevPosition);\n  transformPoint(modelMatrix, attributes.nextPosition);\n\n  if (\n    defined(attributes.normal) ||\n    defined(attributes.tangent) ||\n    defined(attributes.bitangent)\n  ) {\n    Matrix4.inverse(modelMatrix, inverseTranspose);\n    Matrix4.transpose(inverseTranspose, inverseTranspose);\n    Matrix4.getMatrix3(inverseTranspose, normalMatrix);\n\n    transformVector(normalMatrix, attributes.normal);\n    transformVector(normalMatrix, attributes.tangent);\n    transformVector(normalMatrix, attributes.bitangent);\n  }\n\n  var boundingSphere = instance.geometry.boundingSphere;\n  if (defined(boundingSphere)) {\n    instance.geometry.boundingSphere = BoundingSphere.transform(\n      boundingSphere,\n      modelMatrix,\n      boundingSphere\n    );\n  }\n\n  instance.modelMatrix = Matrix4.clone(Matrix4.IDENTITY);\n\n  return instance;\n};\n\nfunction findAttributesInAllGeometries(instances, propertyName) {\n  var length = instances.length;\n\n  var attributesInAllGeometries = {};\n\n  var attributes0 = instances[0][propertyName].attributes;\n  var name;\n\n  for (name in attributes0) {\n    if (\n      attributes0.hasOwnProperty(name) &&\n      defined(attributes0[name]) &&\n      defined(attributes0[name].values)\n    ) {\n      var attribute = attributes0[name];\n      var numberOfComponents = attribute.values.length;\n      var inAllGeometries = true;\n\n      // Does this same attribute exist in all geometries?\n      for (var i = 1; i < length; ++i) {\n        var otherAttribute = instances[i][propertyName].attributes[name];\n\n        if (\n          !defined(otherAttribute) ||\n          attribute.componentDatatype !== otherAttribute.componentDatatype ||\n          attribute.componentsPerAttribute !==\n            otherAttribute.componentsPerAttribute ||\n          attribute.normalize !== otherAttribute.normalize\n        ) {\n          inAllGeometries = false;\n          break;\n        }\n\n        numberOfComponents += otherAttribute.values.length;\n      }\n\n      if (inAllGeometries) {\n        attributesInAllGeometries[name] = new GeometryAttribute({\n          componentDatatype: attribute.componentDatatype,\n          componentsPerAttribute: attribute.componentsPerAttribute,\n          normalize: attribute.normalize,\n          values: ComponentDatatype.createTypedArray(\n            attribute.componentDatatype,\n            numberOfComponents\n          ),\n        });\n      }\n    }\n  }\n\n  return attributesInAllGeometries;\n}\n\nvar tempScratch = new Cartesian3();\n\nfunction combineGeometries(instances, propertyName) {\n  var length = instances.length;\n\n  var name;\n  var i;\n  var j;\n  var k;\n\n  var m = instances[0].modelMatrix;\n  var haveIndices = defined(instances[0][propertyName].indices);\n  var primitiveType = instances[0][propertyName].primitiveType;\n\n  //>>includeStart('debug', pragmas.debug);\n  for (i = 1; i < length; ++i) {\n    if (!Matrix4.equals(instances[i].modelMatrix, m)) {\n      throw new DeveloperError(\"All instances must have the same modelMatrix.\");\n    }\n    if (defined(instances[i][propertyName].indices) !== haveIndices) {\n      throw new DeveloperError(\n        \"All instance geometries must have an indices or not have one.\"\n      );\n    }\n    if (instances[i][propertyName].primitiveType !== primitiveType) {\n      throw new DeveloperError(\n        \"All instance geometries must have the same primitiveType.\"\n      );\n    }\n  }\n  //>>includeEnd('debug');\n\n  // Find subset of attributes in all geometries\n  var attributes = findAttributesInAllGeometries(instances, propertyName);\n  var values;\n  var sourceValues;\n  var sourceValuesLength;\n\n  // Combine attributes from each geometry into a single typed array\n  for (name in attributes) {\n    if (attributes.hasOwnProperty(name)) {\n      values = attributes[name].values;\n\n      k = 0;\n      for (i = 0; i < length; ++i) {\n        sourceValues = instances[i][propertyName].attributes[name].values;\n        sourceValuesLength = sourceValues.length;\n\n        for (j = 0; j < sourceValuesLength; ++j) {\n          values[k++] = sourceValues[j];\n        }\n      }\n    }\n  }\n\n  // Combine index lists\n  var indices;\n\n  if (haveIndices) {\n    var numberOfIndices = 0;\n    for (i = 0; i < length; ++i) {\n      numberOfIndices += instances[i][propertyName].indices.length;\n    }\n\n    var numberOfVertices = Geometry.computeNumberOfVertices(\n      new Geometry({\n        attributes: attributes,\n        primitiveType: PrimitiveType.POINTS,\n      })\n    );\n    var destIndices = IndexDatatype.createTypedArray(\n      numberOfVertices,\n      numberOfIndices\n    );\n\n    var destOffset = 0;\n    var offset = 0;\n\n    for (i = 0; i < length; ++i) {\n      var sourceIndices = instances[i][propertyName].indices;\n      var sourceIndicesLen = sourceIndices.length;\n\n      for (k = 0; k < sourceIndicesLen; ++k) {\n        destIndices[destOffset++] = offset + sourceIndices[k];\n      }\n\n      offset += Geometry.computeNumberOfVertices(instances[i][propertyName]);\n    }\n\n    indices = destIndices;\n  }\n\n  // Create bounding sphere that includes all instances\n  var center = new Cartesian3();\n  var radius = 0.0;\n  var bs;\n\n  for (i = 0; i < length; ++i) {\n    bs = instances[i][propertyName].boundingSphere;\n    if (!defined(bs)) {\n      // If any geometries have an undefined bounding sphere, then so does the combined geometry\n      center = undefined;\n      break;\n    }\n\n    Cartesian3.add(bs.center, center, center);\n  }\n\n  if (defined(center)) {\n    Cartesian3.divideByScalar(center, length, center);\n\n    for (i = 0; i < length; ++i) {\n      bs = instances[i][propertyName].boundingSphere;\n      var tempRadius =\n        Cartesian3.magnitude(\n          Cartesian3.subtract(bs.center, center, tempScratch)\n        ) + bs.radius;\n\n      if (tempRadius > radius) {\n        radius = tempRadius;\n      }\n    }\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: primitiveType,\n    boundingSphere: defined(center)\n      ? new BoundingSphere(center, radius)\n      : undefined,\n  });\n}\n\n/**\n * Combines geometry from several {@link GeometryInstance} objects into one geometry.\n * This concatenates the attributes, concatenates and adjusts the indices, and creates\n * a bounding sphere encompassing all instances.\n * <p>\n * If the instances do not have the same attributes, a subset of attributes common\n * to all instances is used, and the others are ignored.\n * </p>\n * <p>\n * This is used by {@link Primitive} to efficiently render a large amount of static data.\n * </p>\n *\n * @private\n *\n * @param {GeometryInstance[]} [instances] The array of {@link GeometryInstance} objects whose geometry will be combined.\n * @returns {Geometry} A single geometry created from the provided geometry instances.\n *\n * @exception {DeveloperError} All instances must have the same modelMatrix.\n * @exception {DeveloperError} All instance geometries must have an indices or not have one.\n * @exception {DeveloperError} All instance geometries must have the same primitiveType.\n *\n *\n * @example\n * for (var i = 0; i < instances.length; ++i) {\n *   Cesium.GeometryPipeline.transformToWorldCoordinates(instances[i]);\n * }\n * var geometries = Cesium.GeometryPipeline.combineInstances(instances);\n *\n * @see GeometryPipeline.transformToWorldCoordinates\n */\nGeometryPipeline.combineInstances = function (instances) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(instances) || instances.length < 1) {\n    throw new DeveloperError(\n      \"instances is required and must have length greater than zero.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var instanceGeometry = [];\n  var instanceSplitGeometry = [];\n  var length = instances.length;\n  for (var i = 0; i < length; ++i) {\n    var instance = instances[i];\n\n    if (defined(instance.geometry)) {\n      instanceGeometry.push(instance);\n    } else if (\n      defined(instance.westHemisphereGeometry) &&\n      defined(instance.eastHemisphereGeometry)\n    ) {\n      instanceSplitGeometry.push(instance);\n    }\n  }\n\n  var geometries = [];\n  if (instanceGeometry.length > 0) {\n    geometries.push(combineGeometries(instanceGeometry, \"geometry\"));\n  }\n\n  if (instanceSplitGeometry.length > 0) {\n    geometries.push(\n      combineGeometries(instanceSplitGeometry, \"westHemisphereGeometry\")\n    );\n    geometries.push(\n      combineGeometries(instanceSplitGeometry, \"eastHemisphereGeometry\")\n    );\n  }\n\n  return geometries;\n};\n\nvar normal = new Cartesian3();\nvar v0 = new Cartesian3();\nvar v1 = new Cartesian3();\nvar v2 = new Cartesian3();\n\n/**\n * Computes per-vertex normals for a geometry containing <code>TRIANGLES</code> by averaging the normals of\n * all triangles incident to the vertex.  The result is a new <code>normal</code> attribute added to the geometry.\n * This assumes a counter-clockwise winding order.\n *\n * @param {Geometry} geometry The geometry to modify.\n * @returns {Geometry} The modified <code>geometry</code> argument with the computed <code>normal</code> attribute.\n *\n * @exception {DeveloperError} geometry.indices length must be greater than 0 and be a multiple of 3.\n * @exception {DeveloperError} geometry.primitiveType must be {@link PrimitiveType.TRIANGLES}.\n *\n * @example\n * Cesium.GeometryPipeline.computeNormal(geometry);\n */\nGeometryPipeline.computeNormal = function (geometry) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  }\n  if (\n    !defined(geometry.attributes.position) ||\n    !defined(geometry.attributes.position.values)\n  ) {\n    throw new DeveloperError(\n      \"geometry.attributes.position.values is required.\"\n    );\n  }\n  if (!defined(geometry.indices)) {\n    throw new DeveloperError(\"geometry.indices is required.\");\n  }\n  if (geometry.indices.length < 2 || geometry.indices.length % 3 !== 0) {\n    throw new DeveloperError(\n      \"geometry.indices length must be greater than 0 and be a multiple of 3.\"\n    );\n  }\n  if (geometry.primitiveType !== PrimitiveType.TRIANGLES) {\n    throw new DeveloperError(\n      \"geometry.primitiveType must be PrimitiveType.TRIANGLES.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var indices = geometry.indices;\n  var attributes = geometry.attributes;\n  var vertices = attributes.position.values;\n  var numVertices = attributes.position.values.length / 3;\n  var numIndices = indices.length;\n  var normalsPerVertex = new Array(numVertices);\n  var normalsPerTriangle = new Array(numIndices / 3);\n  var normalIndices = new Array(numIndices);\n  var i;\n  for (i = 0; i < numVertices; i++) {\n    normalsPerVertex[i] = {\n      indexOffset: 0,\n      count: 0,\n      currentCount: 0,\n    };\n  }\n\n  var j = 0;\n  for (i = 0; i < numIndices; i += 3) {\n    var i0 = indices[i];\n    var i1 = indices[i + 1];\n    var i2 = indices[i + 2];\n    var i03 = i0 * 3;\n    var i13 = i1 * 3;\n    var i23 = i2 * 3;\n\n    v0.x = vertices[i03];\n    v0.y = vertices[i03 + 1];\n    v0.z = vertices[i03 + 2];\n    v1.x = vertices[i13];\n    v1.y = vertices[i13 + 1];\n    v1.z = vertices[i13 + 2];\n    v2.x = vertices[i23];\n    v2.y = vertices[i23 + 1];\n    v2.z = vertices[i23 + 2];\n\n    normalsPerVertex[i0].count++;\n    normalsPerVertex[i1].count++;\n    normalsPerVertex[i2].count++;\n\n    Cartesian3.subtract(v1, v0, v1);\n    Cartesian3.subtract(v2, v0, v2);\n    normalsPerTriangle[j] = Cartesian3.cross(v1, v2, new Cartesian3());\n    j++;\n  }\n\n  var indexOffset = 0;\n  for (i = 0; i < numVertices; i++) {\n    normalsPerVertex[i].indexOffset += indexOffset;\n    indexOffset += normalsPerVertex[i].count;\n  }\n\n  j = 0;\n  var vertexNormalData;\n  for (i = 0; i < numIndices; i += 3) {\n    vertexNormalData = normalsPerVertex[indices[i]];\n    var index = vertexNormalData.indexOffset + vertexNormalData.currentCount;\n    normalIndices[index] = j;\n    vertexNormalData.currentCount++;\n\n    vertexNormalData = normalsPerVertex[indices[i + 1]];\n    index = vertexNormalData.indexOffset + vertexNormalData.currentCount;\n    normalIndices[index] = j;\n    vertexNormalData.currentCount++;\n\n    vertexNormalData = normalsPerVertex[indices[i + 2]];\n    index = vertexNormalData.indexOffset + vertexNormalData.currentCount;\n    normalIndices[index] = j;\n    vertexNormalData.currentCount++;\n\n    j++;\n  }\n\n  var normalValues = new Float32Array(numVertices * 3);\n  for (i = 0; i < numVertices; i++) {\n    var i3 = i * 3;\n    vertexNormalData = normalsPerVertex[i];\n    Cartesian3.clone(Cartesian3.ZERO, normal);\n    if (vertexNormalData.count > 0) {\n      for (j = 0; j < vertexNormalData.count; j++) {\n        Cartesian3.add(\n          normal,\n          normalsPerTriangle[normalIndices[vertexNormalData.indexOffset + j]],\n          normal\n        );\n      }\n\n      // We can run into an issue where a vertex is used with 2 primitives that have opposite winding order.\n      if (\n        Cartesian3.equalsEpsilon(Cartesian3.ZERO, normal, CesiumMath.EPSILON10)\n      ) {\n        Cartesian3.clone(\n          normalsPerTriangle[normalIndices[vertexNormalData.indexOffset]],\n          normal\n        );\n      }\n    }\n\n    // We end up with a zero vector probably because of a degenerate triangle\n    if (\n      Cartesian3.equalsEpsilon(Cartesian3.ZERO, normal, CesiumMath.EPSILON10)\n    ) {\n      // Default to (0,0,1)\n      normal.z = 1.0;\n    }\n\n    Cartesian3.normalize(normal, normal);\n    normalValues[i3] = normal.x;\n    normalValues[i3 + 1] = normal.y;\n    normalValues[i3 + 2] = normal.z;\n  }\n\n  geometry.attributes.normal = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 3,\n    values: normalValues,\n  });\n\n  return geometry;\n};\n\nvar normalScratch = new Cartesian3();\nvar normalScale = new Cartesian3();\nvar tScratch = new Cartesian3();\n\n/**\n * Computes per-vertex tangents and bitangents for a geometry containing <code>TRIANGLES</code>.\n * The result is new <code>tangent</code> and <code>bitangent</code> attributes added to the geometry.\n * This assumes a counter-clockwise winding order.\n * <p>\n * Based on <a href=\"http://www.terathon.com/code/tangent.html\">Computing Tangent Space Basis Vectors\n * for an Arbitrary Mesh</a> by Eric Lengyel.\n * </p>\n *\n * @param {Geometry} geometry The geometry to modify.\n * @returns {Geometry} The modified <code>geometry</code> argument with the computed <code>tangent</code> and <code>bitangent</code> attributes.\n *\n * @exception {DeveloperError} geometry.indices length must be greater than 0 and be a multiple of 3.\n * @exception {DeveloperError} geometry.primitiveType must be {@link PrimitiveType.TRIANGLES}.\n *\n * @example\n * Cesium.GeometryPipeline.computeTangentAndBiTangent(geometry);\n */\nGeometryPipeline.computeTangentAndBitangent = function (geometry) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var attributes = geometry.attributes;\n  var indices = geometry.indices;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(attributes.position) || !defined(attributes.position.values)) {\n    throw new DeveloperError(\n      \"geometry.attributes.position.values is required.\"\n    );\n  }\n  if (!defined(attributes.normal) || !defined(attributes.normal.values)) {\n    throw new DeveloperError(\"geometry.attributes.normal.values is required.\");\n  }\n  if (!defined(attributes.st) || !defined(attributes.st.values)) {\n    throw new DeveloperError(\"geometry.attributes.st.values is required.\");\n  }\n  if (!defined(indices)) {\n    throw new DeveloperError(\"geometry.indices is required.\");\n  }\n  if (indices.length < 2 || indices.length % 3 !== 0) {\n    throw new DeveloperError(\n      \"geometry.indices length must be greater than 0 and be a multiple of 3.\"\n    );\n  }\n  if (geometry.primitiveType !== PrimitiveType.TRIANGLES) {\n    throw new DeveloperError(\n      \"geometry.primitiveType must be PrimitiveType.TRIANGLES.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var vertices = geometry.attributes.position.values;\n  var normals = geometry.attributes.normal.values;\n  var st = geometry.attributes.st.values;\n\n  var numVertices = geometry.attributes.position.values.length / 3;\n  var numIndices = indices.length;\n  var tan1 = new Array(numVertices * 3);\n\n  var i;\n  for (i = 0; i < tan1.length; i++) {\n    tan1[i] = 0;\n  }\n\n  var i03;\n  var i13;\n  var i23;\n  for (i = 0; i < numIndices; i += 3) {\n    var i0 = indices[i];\n    var i1 = indices[i + 1];\n    var i2 = indices[i + 2];\n    i03 = i0 * 3;\n    i13 = i1 * 3;\n    i23 = i2 * 3;\n    var i02 = i0 * 2;\n    var i12 = i1 * 2;\n    var i22 = i2 * 2;\n\n    var ux = vertices[i03];\n    var uy = vertices[i03 + 1];\n    var uz = vertices[i03 + 2];\n\n    var wx = st[i02];\n    var wy = st[i02 + 1];\n    var t1 = st[i12 + 1] - wy;\n    var t2 = st[i22 + 1] - wy;\n\n    var r = 1.0 / ((st[i12] - wx) * t2 - (st[i22] - wx) * t1);\n    var sdirx = (t2 * (vertices[i13] - ux) - t1 * (vertices[i23] - ux)) * r;\n    var sdiry =\n      (t2 * (vertices[i13 + 1] - uy) - t1 * (vertices[i23 + 1] - uy)) * r;\n    var sdirz =\n      (t2 * (vertices[i13 + 2] - uz) - t1 * (vertices[i23 + 2] - uz)) * r;\n\n    tan1[i03] += sdirx;\n    tan1[i03 + 1] += sdiry;\n    tan1[i03 + 2] += sdirz;\n\n    tan1[i13] += sdirx;\n    tan1[i13 + 1] += sdiry;\n    tan1[i13 + 2] += sdirz;\n\n    tan1[i23] += sdirx;\n    tan1[i23 + 1] += sdiry;\n    tan1[i23 + 2] += sdirz;\n  }\n\n  var tangentValues = new Float32Array(numVertices * 3);\n  var bitangentValues = new Float32Array(numVertices * 3);\n\n  for (i = 0; i < numVertices; i++) {\n    i03 = i * 3;\n    i13 = i03 + 1;\n    i23 = i03 + 2;\n\n    var n = Cartesian3.fromArray(normals, i03, normalScratch);\n    var t = Cartesian3.fromArray(tan1, i03, tScratch);\n    var scalar = Cartesian3.dot(n, t);\n    Cartesian3.multiplyByScalar(n, scalar, normalScale);\n    Cartesian3.normalize(Cartesian3.subtract(t, normalScale, t), t);\n\n    tangentValues[i03] = t.x;\n    tangentValues[i13] = t.y;\n    tangentValues[i23] = t.z;\n\n    Cartesian3.normalize(Cartesian3.cross(n, t, t), t);\n\n    bitangentValues[i03] = t.x;\n    bitangentValues[i13] = t.y;\n    bitangentValues[i23] = t.z;\n  }\n\n  geometry.attributes.tangent = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 3,\n    values: tangentValues,\n  });\n\n  geometry.attributes.bitangent = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 3,\n    values: bitangentValues,\n  });\n\n  return geometry;\n};\n\nvar scratchCartesian2 = new Cartesian2();\nvar toEncode1 = new Cartesian3();\nvar toEncode2 = new Cartesian3();\nvar toEncode3 = new Cartesian3();\nvar encodeResult2 = new Cartesian2();\n/**\n * Compresses and packs geometry normal attribute values to save memory.\n *\n * @param {Geometry} geometry The geometry to modify.\n * @returns {Geometry} The modified <code>geometry</code> argument, with its normals compressed and packed.\n *\n * @example\n * geometry = Cesium.GeometryPipeline.compressVertices(geometry);\n */\nGeometryPipeline.compressVertices = function (geometry) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var extrudeAttribute = geometry.attributes.extrudeDirection;\n  var i;\n  var numVertices;\n  if (defined(extrudeAttribute)) {\n    //only shadow volumes use extrudeDirection, and shadow volumes use vertexFormat: POSITION_ONLY so we don't need to check other attributes\n    var extrudeDirections = extrudeAttribute.values;\n    numVertices = extrudeDirections.length / 3.0;\n    var compressedDirections = new Float32Array(numVertices * 2);\n\n    var i2 = 0;\n    for (i = 0; i < numVertices; ++i) {\n      Cartesian3.fromArray(extrudeDirections, i * 3.0, toEncode1);\n      if (Cartesian3.equals(toEncode1, Cartesian3.ZERO)) {\n        i2 += 2;\n        continue;\n      }\n      encodeResult2 = AttributeCompression.octEncodeInRange(\n        toEncode1,\n        65535,\n        encodeResult2\n      );\n      compressedDirections[i2++] = encodeResult2.x;\n      compressedDirections[i2++] = encodeResult2.y;\n    }\n\n    geometry.attributes.compressedAttributes = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: compressedDirections,\n    });\n    delete geometry.attributes.extrudeDirection;\n    return geometry;\n  }\n\n  var normalAttribute = geometry.attributes.normal;\n  var stAttribute = geometry.attributes.st;\n\n  var hasNormal = defined(normalAttribute);\n  var hasSt = defined(stAttribute);\n  if (!hasNormal && !hasSt) {\n    return geometry;\n  }\n\n  var tangentAttribute = geometry.attributes.tangent;\n  var bitangentAttribute = geometry.attributes.bitangent;\n\n  var hasTangent = defined(tangentAttribute);\n  var hasBitangent = defined(bitangentAttribute);\n\n  var normals;\n  var st;\n  var tangents;\n  var bitangents;\n\n  if (hasNormal) {\n    normals = normalAttribute.values;\n  }\n  if (hasSt) {\n    st = stAttribute.values;\n  }\n  if (hasTangent) {\n    tangents = tangentAttribute.values;\n  }\n  if (hasBitangent) {\n    bitangents = bitangentAttribute.values;\n  }\n\n  var length = hasNormal ? normals.length : st.length;\n  var numComponents = hasNormal ? 3.0 : 2.0;\n  numVertices = length / numComponents;\n\n  var compressedLength = numVertices;\n  var numCompressedComponents = hasSt && hasNormal ? 2.0 : 1.0;\n  numCompressedComponents += hasTangent || hasBitangent ? 1.0 : 0.0;\n  compressedLength *= numCompressedComponents;\n\n  var compressedAttributes = new Float32Array(compressedLength);\n\n  var normalIndex = 0;\n  for (i = 0; i < numVertices; ++i) {\n    if (hasSt) {\n      Cartesian2.fromArray(st, i * 2.0, scratchCartesian2);\n      compressedAttributes[\n        normalIndex++\n      ] = AttributeCompression.compressTextureCoordinates(scratchCartesian2);\n    }\n\n    var index = i * 3.0;\n    if (hasNormal && defined(tangents) && defined(bitangents)) {\n      Cartesian3.fromArray(normals, index, toEncode1);\n      Cartesian3.fromArray(tangents, index, toEncode2);\n      Cartesian3.fromArray(bitangents, index, toEncode3);\n\n      AttributeCompression.octPack(\n        toEncode1,\n        toEncode2,\n        toEncode3,\n        scratchCartesian2\n      );\n      compressedAttributes[normalIndex++] = scratchCartesian2.x;\n      compressedAttributes[normalIndex++] = scratchCartesian2.y;\n    } else {\n      if (hasNormal) {\n        Cartesian3.fromArray(normals, index, toEncode1);\n        compressedAttributes[\n          normalIndex++\n        ] = AttributeCompression.octEncodeFloat(toEncode1);\n      }\n\n      if (hasTangent) {\n        Cartesian3.fromArray(tangents, index, toEncode1);\n        compressedAttributes[\n          normalIndex++\n        ] = AttributeCompression.octEncodeFloat(toEncode1);\n      }\n\n      if (hasBitangent) {\n        Cartesian3.fromArray(bitangents, index, toEncode1);\n        compressedAttributes[\n          normalIndex++\n        ] = AttributeCompression.octEncodeFloat(toEncode1);\n      }\n    }\n  }\n\n  geometry.attributes.compressedAttributes = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: numCompressedComponents,\n    values: compressedAttributes,\n  });\n\n  if (hasNormal) {\n    delete geometry.attributes.normal;\n  }\n  if (hasSt) {\n    delete geometry.attributes.st;\n  }\n  if (hasBitangent) {\n    delete geometry.attributes.bitangent;\n  }\n  if (hasTangent) {\n    delete geometry.attributes.tangent;\n  }\n\n  return geometry;\n};\n\nfunction indexTriangles(geometry) {\n  if (defined(geometry.indices)) {\n    return geometry;\n  }\n  var numberOfVertices = Geometry.computeNumberOfVertices(geometry);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (numberOfVertices < 3) {\n    throw new DeveloperError(\"The number of vertices must be at least three.\");\n  }\n  if (numberOfVertices % 3 !== 0) {\n    throw new DeveloperError(\n      \"The number of vertices must be a multiple of three.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var indices = IndexDatatype.createTypedArray(\n    numberOfVertices,\n    numberOfVertices\n  );\n  for (var i = 0; i < numberOfVertices; ++i) {\n    indices[i] = i;\n  }\n\n  geometry.indices = indices;\n  return geometry;\n}\n\nfunction indexTriangleFan(geometry) {\n  var numberOfVertices = Geometry.computeNumberOfVertices(geometry);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (numberOfVertices < 3) {\n    throw new DeveloperError(\"The number of vertices must be at least three.\");\n  }\n  //>>includeEnd('debug');\n\n  var indices = IndexDatatype.createTypedArray(\n    numberOfVertices,\n    (numberOfVertices - 2) * 3\n  );\n  indices[0] = 1;\n  indices[1] = 0;\n  indices[2] = 2;\n\n  var indicesIndex = 3;\n  for (var i = 3; i < numberOfVertices; ++i) {\n    indices[indicesIndex++] = i - 1;\n    indices[indicesIndex++] = 0;\n    indices[indicesIndex++] = i;\n  }\n\n  geometry.indices = indices;\n  geometry.primitiveType = PrimitiveType.TRIANGLES;\n  return geometry;\n}\n\nfunction indexTriangleStrip(geometry) {\n  var numberOfVertices = Geometry.computeNumberOfVertices(geometry);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (numberOfVertices < 3) {\n    throw new DeveloperError(\"The number of vertices must be at least 3.\");\n  }\n  //>>includeEnd('debug');\n\n  var indices = IndexDatatype.createTypedArray(\n    numberOfVertices,\n    (numberOfVertices - 2) * 3\n  );\n  indices[0] = 0;\n  indices[1] = 1;\n  indices[2] = 2;\n\n  if (numberOfVertices > 3) {\n    indices[3] = 0;\n    indices[4] = 2;\n    indices[5] = 3;\n  }\n\n  var indicesIndex = 6;\n  for (var i = 3; i < numberOfVertices - 1; i += 2) {\n    indices[indicesIndex++] = i;\n    indices[indicesIndex++] = i - 1;\n    indices[indicesIndex++] = i + 1;\n\n    if (i + 2 < numberOfVertices) {\n      indices[indicesIndex++] = i;\n      indices[indicesIndex++] = i + 1;\n      indices[indicesIndex++] = i + 2;\n    }\n  }\n\n  geometry.indices = indices;\n  geometry.primitiveType = PrimitiveType.TRIANGLES;\n  return geometry;\n}\n\nfunction indexLines(geometry) {\n  if (defined(geometry.indices)) {\n    return geometry;\n  }\n  var numberOfVertices = Geometry.computeNumberOfVertices(geometry);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (numberOfVertices < 2) {\n    throw new DeveloperError(\"The number of vertices must be at least two.\");\n  }\n  if (numberOfVertices % 2 !== 0) {\n    throw new DeveloperError(\"The number of vertices must be a multiple of 2.\");\n  }\n  //>>includeEnd('debug');\n\n  var indices = IndexDatatype.createTypedArray(\n    numberOfVertices,\n    numberOfVertices\n  );\n  for (var i = 0; i < numberOfVertices; ++i) {\n    indices[i] = i;\n  }\n\n  geometry.indices = indices;\n  return geometry;\n}\n\nfunction indexLineStrip(geometry) {\n  var numberOfVertices = Geometry.computeNumberOfVertices(geometry);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (numberOfVertices < 2) {\n    throw new DeveloperError(\"The number of vertices must be at least two.\");\n  }\n  //>>includeEnd('debug');\n\n  var indices = IndexDatatype.createTypedArray(\n    numberOfVertices,\n    (numberOfVertices - 1) * 2\n  );\n  indices[0] = 0;\n  indices[1] = 1;\n  var indicesIndex = 2;\n  for (var i = 2; i < numberOfVertices; ++i) {\n    indices[indicesIndex++] = i - 1;\n    indices[indicesIndex++] = i;\n  }\n\n  geometry.indices = indices;\n  geometry.primitiveType = PrimitiveType.LINES;\n  return geometry;\n}\n\nfunction indexLineLoop(geometry) {\n  var numberOfVertices = Geometry.computeNumberOfVertices(geometry);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (numberOfVertices < 2) {\n    throw new DeveloperError(\"The number of vertices must be at least two.\");\n  }\n  //>>includeEnd('debug');\n\n  var indices = IndexDatatype.createTypedArray(\n    numberOfVertices,\n    numberOfVertices * 2\n  );\n\n  indices[0] = 0;\n  indices[1] = 1;\n\n  var indicesIndex = 2;\n  for (var i = 2; i < numberOfVertices; ++i) {\n    indices[indicesIndex++] = i - 1;\n    indices[indicesIndex++] = i;\n  }\n\n  indices[indicesIndex++] = numberOfVertices - 1;\n  indices[indicesIndex] = 0;\n\n  geometry.indices = indices;\n  geometry.primitiveType = PrimitiveType.LINES;\n  return geometry;\n}\n\nfunction indexPrimitive(geometry) {\n  switch (geometry.primitiveType) {\n    case PrimitiveType.TRIANGLE_FAN:\n      return indexTriangleFan(geometry);\n    case PrimitiveType.TRIANGLE_STRIP:\n      return indexTriangleStrip(geometry);\n    case PrimitiveType.TRIANGLES:\n      return indexTriangles(geometry);\n    case PrimitiveType.LINE_STRIP:\n      return indexLineStrip(geometry);\n    case PrimitiveType.LINE_LOOP:\n      return indexLineLoop(geometry);\n    case PrimitiveType.LINES:\n      return indexLines(geometry);\n  }\n\n  return geometry;\n}\n\nfunction offsetPointFromXZPlane(p, isBehind) {\n  if (Math.abs(p.y) < CesiumMath.EPSILON6) {\n    if (isBehind) {\n      p.y = -CesiumMath.EPSILON6;\n    } else {\n      p.y = CesiumMath.EPSILON6;\n    }\n  }\n}\n\nfunction offsetTriangleFromXZPlane(p0, p1, p2) {\n  if (p0.y !== 0.0 && p1.y !== 0.0 && p2.y !== 0.0) {\n    offsetPointFromXZPlane(p0, p0.y < 0.0);\n    offsetPointFromXZPlane(p1, p1.y < 0.0);\n    offsetPointFromXZPlane(p2, p2.y < 0.0);\n    return;\n  }\n\n  var p0y = Math.abs(p0.y);\n  var p1y = Math.abs(p1.y);\n  var p2y = Math.abs(p2.y);\n\n  var sign;\n  if (p0y > p1y) {\n    if (p0y > p2y) {\n      sign = CesiumMath.sign(p0.y);\n    } else {\n      sign = CesiumMath.sign(p2.y);\n    }\n  } else if (p1y > p2y) {\n    sign = CesiumMath.sign(p1.y);\n  } else {\n    sign = CesiumMath.sign(p2.y);\n  }\n\n  var isBehind = sign < 0.0;\n  offsetPointFromXZPlane(p0, isBehind);\n  offsetPointFromXZPlane(p1, isBehind);\n  offsetPointFromXZPlane(p2, isBehind);\n}\n\nvar c3 = new Cartesian3();\nfunction getXZIntersectionOffsetPoints(p, p1, u1, v1) {\n  Cartesian3.add(\n    p,\n    Cartesian3.multiplyByScalar(\n      Cartesian3.subtract(p1, p, c3),\n      p.y / (p.y - p1.y),\n      c3\n    ),\n    u1\n  );\n  Cartesian3.clone(u1, v1);\n  offsetPointFromXZPlane(u1, true);\n  offsetPointFromXZPlane(v1, false);\n}\n\nvar u1 = new Cartesian3();\nvar u2 = new Cartesian3();\nvar q1 = new Cartesian3();\nvar q2 = new Cartesian3();\n\nvar splitTriangleResult = {\n  positions: new Array(7),\n  indices: new Array(3 * 3),\n};\n\nfunction splitTriangle(p0, p1, p2) {\n  // In WGS84 coordinates, for a triangle approximately on the\n  // ellipsoid to cross the IDL, first it needs to be on the\n  // negative side of the plane x = 0.\n  if (p0.x >= 0.0 || p1.x >= 0.0 || p2.x >= 0.0) {\n    return undefined;\n  }\n\n  offsetTriangleFromXZPlane(p0, p1, p2);\n\n  var p0Behind = p0.y < 0.0;\n  var p1Behind = p1.y < 0.0;\n  var p2Behind = p2.y < 0.0;\n\n  var numBehind = 0;\n  numBehind += p0Behind ? 1 : 0;\n  numBehind += p1Behind ? 1 : 0;\n  numBehind += p2Behind ? 1 : 0;\n\n  var indices = splitTriangleResult.indices;\n\n  if (numBehind === 1) {\n    indices[1] = 3;\n    indices[2] = 4;\n    indices[5] = 6;\n    indices[7] = 6;\n    indices[8] = 5;\n\n    if (p0Behind) {\n      getXZIntersectionOffsetPoints(p0, p1, u1, q1);\n      getXZIntersectionOffsetPoints(p0, p2, u2, q2);\n\n      indices[0] = 0;\n      indices[3] = 1;\n      indices[4] = 2;\n      indices[6] = 1;\n    } else if (p1Behind) {\n      getXZIntersectionOffsetPoints(p1, p2, u1, q1);\n      getXZIntersectionOffsetPoints(p1, p0, u2, q2);\n\n      indices[0] = 1;\n      indices[3] = 2;\n      indices[4] = 0;\n      indices[6] = 2;\n    } else if (p2Behind) {\n      getXZIntersectionOffsetPoints(p2, p0, u1, q1);\n      getXZIntersectionOffsetPoints(p2, p1, u2, q2);\n\n      indices[0] = 2;\n      indices[3] = 0;\n      indices[4] = 1;\n      indices[6] = 0;\n    }\n  } else if (numBehind === 2) {\n    indices[2] = 4;\n    indices[4] = 4;\n    indices[5] = 3;\n    indices[7] = 5;\n    indices[8] = 6;\n\n    if (!p0Behind) {\n      getXZIntersectionOffsetPoints(p0, p1, u1, q1);\n      getXZIntersectionOffsetPoints(p0, p2, u2, q2);\n\n      indices[0] = 1;\n      indices[1] = 2;\n      indices[3] = 1;\n      indices[6] = 0;\n    } else if (!p1Behind) {\n      getXZIntersectionOffsetPoints(p1, p2, u1, q1);\n      getXZIntersectionOffsetPoints(p1, p0, u2, q2);\n\n      indices[0] = 2;\n      indices[1] = 0;\n      indices[3] = 2;\n      indices[6] = 1;\n    } else if (!p2Behind) {\n      getXZIntersectionOffsetPoints(p2, p0, u1, q1);\n      getXZIntersectionOffsetPoints(p2, p1, u2, q2);\n\n      indices[0] = 0;\n      indices[1] = 1;\n      indices[3] = 0;\n      indices[6] = 2;\n    }\n  }\n\n  var positions = splitTriangleResult.positions;\n  positions[0] = p0;\n  positions[1] = p1;\n  positions[2] = p2;\n  positions.length = 3;\n\n  if (numBehind === 1 || numBehind === 2) {\n    positions[3] = u1;\n    positions[4] = u2;\n    positions[5] = q1;\n    positions[6] = q2;\n    positions.length = 7;\n  }\n\n  return splitTriangleResult;\n}\n\nfunction updateGeometryAfterSplit(geometry, computeBoundingSphere) {\n  var attributes = geometry.attributes;\n\n  if (attributes.position.values.length === 0) {\n    return undefined;\n  }\n\n  for (var property in attributes) {\n    if (\n      attributes.hasOwnProperty(property) &&\n      defined(attributes[property]) &&\n      defined(attributes[property].values)\n    ) {\n      var attribute = attributes[property];\n      attribute.values = ComponentDatatype.createTypedArray(\n        attribute.componentDatatype,\n        attribute.values\n      );\n    }\n  }\n\n  var numberOfVertices = Geometry.computeNumberOfVertices(geometry);\n  geometry.indices = IndexDatatype.createTypedArray(\n    numberOfVertices,\n    geometry.indices\n  );\n\n  if (computeBoundingSphere) {\n    geometry.boundingSphere = BoundingSphere.fromVertices(\n      attributes.position.values\n    );\n  }\n\n  return geometry;\n}\n\nfunction copyGeometryForSplit(geometry) {\n  var attributes = geometry.attributes;\n  var copiedAttributes = {};\n\n  for (var property in attributes) {\n    if (\n      attributes.hasOwnProperty(property) &&\n      defined(attributes[property]) &&\n      defined(attributes[property].values)\n    ) {\n      var attribute = attributes[property];\n      copiedAttributes[property] = new GeometryAttribute({\n        componentDatatype: attribute.componentDatatype,\n        componentsPerAttribute: attribute.componentsPerAttribute,\n        normalize: attribute.normalize,\n        values: [],\n      });\n    }\n  }\n\n  return new Geometry({\n    attributes: copiedAttributes,\n    indices: [],\n    primitiveType: geometry.primitiveType,\n  });\n}\n\nfunction updateInstanceAfterSplit(instance, westGeometry, eastGeometry) {\n  var computeBoundingSphere = defined(instance.geometry.boundingSphere);\n\n  westGeometry = updateGeometryAfterSplit(westGeometry, computeBoundingSphere);\n  eastGeometry = updateGeometryAfterSplit(eastGeometry, computeBoundingSphere);\n\n  if (defined(eastGeometry) && !defined(westGeometry)) {\n    instance.geometry = eastGeometry;\n  } else if (!defined(eastGeometry) && defined(westGeometry)) {\n    instance.geometry = westGeometry;\n  } else {\n    instance.westHemisphereGeometry = westGeometry;\n    instance.eastHemisphereGeometry = eastGeometry;\n    instance.geometry = undefined;\n  }\n}\n\nfunction generateBarycentricInterpolateFunction(\n  CartesianType,\n  numberOfComponents\n) {\n  var v0Scratch = new CartesianType();\n  var v1Scratch = new CartesianType();\n  var v2Scratch = new CartesianType();\n\n  return function (\n    i0,\n    i1,\n    i2,\n    coords,\n    sourceValues,\n    currentValues,\n    insertedIndex,\n    normalize\n  ) {\n    var v0 = CartesianType.fromArray(\n      sourceValues,\n      i0 * numberOfComponents,\n      v0Scratch\n    );\n    var v1 = CartesianType.fromArray(\n      sourceValues,\n      i1 * numberOfComponents,\n      v1Scratch\n    );\n    var v2 = CartesianType.fromArray(\n      sourceValues,\n      i2 * numberOfComponents,\n      v2Scratch\n    );\n\n    CartesianType.multiplyByScalar(v0, coords.x, v0);\n    CartesianType.multiplyByScalar(v1, coords.y, v1);\n    CartesianType.multiplyByScalar(v2, coords.z, v2);\n\n    var value = CartesianType.add(v0, v1, v0);\n    CartesianType.add(value, v2, value);\n\n    if (normalize) {\n      CartesianType.normalize(value, value);\n    }\n\n    CartesianType.pack(\n      value,\n      currentValues,\n      insertedIndex * numberOfComponents\n    );\n  };\n}\n\nvar interpolateAndPackCartesian4 = generateBarycentricInterpolateFunction(\n  Cartesian4,\n  4\n);\nvar interpolateAndPackCartesian3 = generateBarycentricInterpolateFunction(\n  Cartesian3,\n  3\n);\nvar interpolateAndPackCartesian2 = generateBarycentricInterpolateFunction(\n  Cartesian2,\n  2\n);\nvar interpolateAndPackBoolean = function (\n  i0,\n  i1,\n  i2,\n  coords,\n  sourceValues,\n  currentValues,\n  insertedIndex\n) {\n  var v1 = sourceValues[i0] * coords.x;\n  var v2 = sourceValues[i1] * coords.y;\n  var v3 = sourceValues[i2] * coords.z;\n  currentValues[insertedIndex] = v1 + v2 + v3 > CesiumMath.EPSILON6 ? 1 : 0;\n};\n\nvar p0Scratch = new Cartesian3();\nvar p1Scratch = new Cartesian3();\nvar p2Scratch = new Cartesian3();\nvar barycentricScratch = new Cartesian3();\n\nfunction computeTriangleAttributes(\n  i0,\n  i1,\n  i2,\n  point,\n  positions,\n  normals,\n  tangents,\n  bitangents,\n  texCoords,\n  extrudeDirections,\n  applyOffset,\n  currentAttributes,\n  customAttributeNames,\n  customAttributesLength,\n  allAttributes,\n  insertedIndex\n) {\n  if (\n    !defined(normals) &&\n    !defined(tangents) &&\n    !defined(bitangents) &&\n    !defined(texCoords) &&\n    !defined(extrudeDirections) &&\n    customAttributesLength === 0\n  ) {\n    return;\n  }\n\n  var p0 = Cartesian3.fromArray(positions, i0 * 3, p0Scratch);\n  var p1 = Cartesian3.fromArray(positions, i1 * 3, p1Scratch);\n  var p2 = Cartesian3.fromArray(positions, i2 * 3, p2Scratch);\n  var coords = barycentricCoordinates(point, p0, p1, p2, barycentricScratch);\n\n  if (defined(normals)) {\n    interpolateAndPackCartesian3(\n      i0,\n      i1,\n      i2,\n      coords,\n      normals,\n      currentAttributes.normal.values,\n      insertedIndex,\n      true\n    );\n  }\n\n  if (defined(extrudeDirections)) {\n    var d0 = Cartesian3.fromArray(extrudeDirections, i0 * 3, p0Scratch);\n    var d1 = Cartesian3.fromArray(extrudeDirections, i1 * 3, p1Scratch);\n    var d2 = Cartesian3.fromArray(extrudeDirections, i2 * 3, p2Scratch);\n\n    Cartesian3.multiplyByScalar(d0, coords.x, d0);\n    Cartesian3.multiplyByScalar(d1, coords.y, d1);\n    Cartesian3.multiplyByScalar(d2, coords.z, d2);\n\n    var direction;\n    if (\n      !Cartesian3.equals(d0, Cartesian3.ZERO) ||\n      !Cartesian3.equals(d1, Cartesian3.ZERO) ||\n      !Cartesian3.equals(d2, Cartesian3.ZERO)\n    ) {\n      direction = Cartesian3.add(d0, d1, d0);\n      Cartesian3.add(direction, d2, direction);\n      Cartesian3.normalize(direction, direction);\n    } else {\n      direction = p0Scratch;\n      direction.x = 0;\n      direction.y = 0;\n      direction.z = 0;\n    }\n    Cartesian3.pack(\n      direction,\n      currentAttributes.extrudeDirection.values,\n      insertedIndex * 3\n    );\n  }\n\n  if (defined(applyOffset)) {\n    interpolateAndPackBoolean(\n      i0,\n      i1,\n      i2,\n      coords,\n      applyOffset,\n      currentAttributes.applyOffset.values,\n      insertedIndex\n    );\n  }\n\n  if (defined(tangents)) {\n    interpolateAndPackCartesian3(\n      i0,\n      i1,\n      i2,\n      coords,\n      tangents,\n      currentAttributes.tangent.values,\n      insertedIndex,\n      true\n    );\n  }\n\n  if (defined(bitangents)) {\n    interpolateAndPackCartesian3(\n      i0,\n      i1,\n      i2,\n      coords,\n      bitangents,\n      currentAttributes.bitangent.values,\n      insertedIndex,\n      true\n    );\n  }\n\n  if (defined(texCoords)) {\n    interpolateAndPackCartesian2(\n      i0,\n      i1,\n      i2,\n      coords,\n      texCoords,\n      currentAttributes.st.values,\n      insertedIndex\n    );\n  }\n\n  if (customAttributesLength > 0) {\n    for (var i = 0; i < customAttributesLength; i++) {\n      var attributeName = customAttributeNames[i];\n      genericInterpolate(\n        i0,\n        i1,\n        i2,\n        coords,\n        insertedIndex,\n        allAttributes[attributeName],\n        currentAttributes[attributeName]\n      );\n    }\n  }\n}\n\nfunction genericInterpolate(\n  i0,\n  i1,\n  i2,\n  coords,\n  insertedIndex,\n  sourceAttribute,\n  currentAttribute\n) {\n  var componentsPerAttribute = sourceAttribute.componentsPerAttribute;\n  var sourceValues = sourceAttribute.values;\n  var currentValues = currentAttribute.values;\n  switch (componentsPerAttribute) {\n    case 4:\n      interpolateAndPackCartesian4(\n        i0,\n        i1,\n        i2,\n        coords,\n        sourceValues,\n        currentValues,\n        insertedIndex,\n        false\n      );\n      break;\n    case 3:\n      interpolateAndPackCartesian3(\n        i0,\n        i1,\n        i2,\n        coords,\n        sourceValues,\n        currentValues,\n        insertedIndex,\n        false\n      );\n      break;\n    case 2:\n      interpolateAndPackCartesian2(\n        i0,\n        i1,\n        i2,\n        coords,\n        sourceValues,\n        currentValues,\n        insertedIndex,\n        false\n      );\n      break;\n    default:\n      currentValues[insertedIndex] =\n        sourceValues[i0] * coords.x +\n        sourceValues[i1] * coords.y +\n        sourceValues[i2] * coords.z;\n  }\n}\n\nfunction insertSplitPoint(\n  currentAttributes,\n  currentIndices,\n  currentIndexMap,\n  indices,\n  currentIndex,\n  point\n) {\n  var insertIndex = currentAttributes.position.values.length / 3;\n\n  if (currentIndex !== -1) {\n    var prevIndex = indices[currentIndex];\n    var newIndex = currentIndexMap[prevIndex];\n\n    if (newIndex === -1) {\n      currentIndexMap[prevIndex] = insertIndex;\n      currentAttributes.position.values.push(point.x, point.y, point.z);\n      currentIndices.push(insertIndex);\n      return insertIndex;\n    }\n\n    currentIndices.push(newIndex);\n    return newIndex;\n  }\n\n  currentAttributes.position.values.push(point.x, point.y, point.z);\n  currentIndices.push(insertIndex);\n  return insertIndex;\n}\n\nvar NAMED_ATTRIBUTES = {\n  position: true,\n  normal: true,\n  bitangent: true,\n  tangent: true,\n  st: true,\n  extrudeDirection: true,\n  applyOffset: true,\n};\nfunction splitLongitudeTriangles(instance) {\n  var geometry = instance.geometry;\n  var attributes = geometry.attributes;\n  var positions = attributes.position.values;\n  var normals = defined(attributes.normal)\n    ? attributes.normal.values\n    : undefined;\n  var bitangents = defined(attributes.bitangent)\n    ? attributes.bitangent.values\n    : undefined;\n  var tangents = defined(attributes.tangent)\n    ? attributes.tangent.values\n    : undefined;\n  var texCoords = defined(attributes.st) ? attributes.st.values : undefined;\n  var extrudeDirections = defined(attributes.extrudeDirection)\n    ? attributes.extrudeDirection.values\n    : undefined;\n  var applyOffset = defined(attributes.applyOffset)\n    ? attributes.applyOffset.values\n    : undefined;\n  var indices = geometry.indices;\n\n  var customAttributeNames = [];\n  for (var attributeName in attributes) {\n    if (\n      attributes.hasOwnProperty(attributeName) &&\n      !NAMED_ATTRIBUTES[attributeName] &&\n      defined(attributes[attributeName])\n    ) {\n      customAttributeNames.push(attributeName);\n    }\n  }\n  var customAttributesLength = customAttributeNames.length;\n\n  var eastGeometry = copyGeometryForSplit(geometry);\n  var westGeometry = copyGeometryForSplit(geometry);\n\n  var currentAttributes;\n  var currentIndices;\n  var currentIndexMap;\n  var insertedIndex;\n  var i;\n\n  var westGeometryIndexMap = [];\n  westGeometryIndexMap.length = positions.length / 3;\n\n  var eastGeometryIndexMap = [];\n  eastGeometryIndexMap.length = positions.length / 3;\n\n  for (i = 0; i < westGeometryIndexMap.length; ++i) {\n    westGeometryIndexMap[i] = -1;\n    eastGeometryIndexMap[i] = -1;\n  }\n\n  var len = indices.length;\n  for (i = 0; i < len; i += 3) {\n    var i0 = indices[i];\n    var i1 = indices[i + 1];\n    var i2 = indices[i + 2];\n\n    var p0 = Cartesian3.fromArray(positions, i0 * 3);\n    var p1 = Cartesian3.fromArray(positions, i1 * 3);\n    var p2 = Cartesian3.fromArray(positions, i2 * 3);\n\n    var result = splitTriangle(p0, p1, p2);\n    if (defined(result) && result.positions.length > 3) {\n      var resultPositions = result.positions;\n      var resultIndices = result.indices;\n      var resultLength = resultIndices.length;\n\n      for (var j = 0; j < resultLength; ++j) {\n        var resultIndex = resultIndices[j];\n        var point = resultPositions[resultIndex];\n\n        if (point.y < 0.0) {\n          currentAttributes = westGeometry.attributes;\n          currentIndices = westGeometry.indices;\n          currentIndexMap = westGeometryIndexMap;\n        } else {\n          currentAttributes = eastGeometry.attributes;\n          currentIndices = eastGeometry.indices;\n          currentIndexMap = eastGeometryIndexMap;\n        }\n\n        insertedIndex = insertSplitPoint(\n          currentAttributes,\n          currentIndices,\n          currentIndexMap,\n          indices,\n          resultIndex < 3 ? i + resultIndex : -1,\n          point\n        );\n        computeTriangleAttributes(\n          i0,\n          i1,\n          i2,\n          point,\n          positions,\n          normals,\n          tangents,\n          bitangents,\n          texCoords,\n          extrudeDirections,\n          applyOffset,\n          currentAttributes,\n          customAttributeNames,\n          customAttributesLength,\n          attributes,\n          insertedIndex\n        );\n      }\n    } else {\n      if (defined(result)) {\n        p0 = result.positions[0];\n        p1 = result.positions[1];\n        p2 = result.positions[2];\n      }\n\n      if (p0.y < 0.0) {\n        currentAttributes = westGeometry.attributes;\n        currentIndices = westGeometry.indices;\n        currentIndexMap = westGeometryIndexMap;\n      } else {\n        currentAttributes = eastGeometry.attributes;\n        currentIndices = eastGeometry.indices;\n        currentIndexMap = eastGeometryIndexMap;\n      }\n\n      insertedIndex = insertSplitPoint(\n        currentAttributes,\n        currentIndices,\n        currentIndexMap,\n        indices,\n        i,\n        p0\n      );\n      computeTriangleAttributes(\n        i0,\n        i1,\n        i2,\n        p0,\n        positions,\n        normals,\n        tangents,\n        bitangents,\n        texCoords,\n        extrudeDirections,\n        applyOffset,\n        currentAttributes,\n        customAttributeNames,\n        customAttributesLength,\n        attributes,\n        insertedIndex\n      );\n\n      insertedIndex = insertSplitPoint(\n        currentAttributes,\n        currentIndices,\n        currentIndexMap,\n        indices,\n        i + 1,\n        p1\n      );\n      computeTriangleAttributes(\n        i0,\n        i1,\n        i2,\n        p1,\n        positions,\n        normals,\n        tangents,\n        bitangents,\n        texCoords,\n        extrudeDirections,\n        applyOffset,\n        currentAttributes,\n        customAttributeNames,\n        customAttributesLength,\n        attributes,\n        insertedIndex\n      );\n\n      insertedIndex = insertSplitPoint(\n        currentAttributes,\n        currentIndices,\n        currentIndexMap,\n        indices,\n        i + 2,\n        p2\n      );\n      computeTriangleAttributes(\n        i0,\n        i1,\n        i2,\n        p2,\n        positions,\n        normals,\n        tangents,\n        bitangents,\n        texCoords,\n        extrudeDirections,\n        applyOffset,\n        currentAttributes,\n        customAttributeNames,\n        customAttributesLength,\n        attributes,\n        insertedIndex\n      );\n    }\n  }\n\n  updateInstanceAfterSplit(instance, westGeometry, eastGeometry);\n}\n\nvar xzPlane = Plane.fromPointNormal(Cartesian3.ZERO, Cartesian3.UNIT_Y);\n\nvar offsetScratch = new Cartesian3();\nvar offsetPointScratch = new Cartesian3();\n\nfunction computeLineAttributes(\n  i0,\n  i1,\n  point,\n  positions,\n  insertIndex,\n  currentAttributes,\n  applyOffset\n) {\n  if (!defined(applyOffset)) {\n    return;\n  }\n\n  var p0 = Cartesian3.fromArray(positions, i0 * 3, p0Scratch);\n  if (Cartesian3.equalsEpsilon(p0, point, CesiumMath.EPSILON10)) {\n    currentAttributes.applyOffset.values[insertIndex] = applyOffset[i0];\n  } else {\n    currentAttributes.applyOffset.values[insertIndex] = applyOffset[i1];\n  }\n}\n\nfunction splitLongitudeLines(instance) {\n  var geometry = instance.geometry;\n  var attributes = geometry.attributes;\n  var positions = attributes.position.values;\n  var applyOffset = defined(attributes.applyOffset)\n    ? attributes.applyOffset.values\n    : undefined;\n  var indices = geometry.indices;\n\n  var eastGeometry = copyGeometryForSplit(geometry);\n  var westGeometry = copyGeometryForSplit(geometry);\n\n  var i;\n  var length = indices.length;\n\n  var westGeometryIndexMap = [];\n  westGeometryIndexMap.length = positions.length / 3;\n\n  var eastGeometryIndexMap = [];\n  eastGeometryIndexMap.length = positions.length / 3;\n\n  for (i = 0; i < westGeometryIndexMap.length; ++i) {\n    westGeometryIndexMap[i] = -1;\n    eastGeometryIndexMap[i] = -1;\n  }\n\n  for (i = 0; i < length; i += 2) {\n    var i0 = indices[i];\n    var i1 = indices[i + 1];\n\n    var p0 = Cartesian3.fromArray(positions, i0 * 3, p0Scratch);\n    var p1 = Cartesian3.fromArray(positions, i1 * 3, p1Scratch);\n    var insertIndex;\n\n    if (Math.abs(p0.y) < CesiumMath.EPSILON6) {\n      if (p0.y < 0.0) {\n        p0.y = -CesiumMath.EPSILON6;\n      } else {\n        p0.y = CesiumMath.EPSILON6;\n      }\n    }\n\n    if (Math.abs(p1.y) < CesiumMath.EPSILON6) {\n      if (p1.y < 0.0) {\n        p1.y = -CesiumMath.EPSILON6;\n      } else {\n        p1.y = CesiumMath.EPSILON6;\n      }\n    }\n\n    var p0Attributes = eastGeometry.attributes;\n    var p0Indices = eastGeometry.indices;\n    var p0IndexMap = eastGeometryIndexMap;\n    var p1Attributes = westGeometry.attributes;\n    var p1Indices = westGeometry.indices;\n    var p1IndexMap = westGeometryIndexMap;\n\n    var intersection = IntersectionTests.lineSegmentPlane(\n      p0,\n      p1,\n      xzPlane,\n      p2Scratch\n    );\n    if (defined(intersection)) {\n      // move point on the xz-plane slightly away from the plane\n      var offset = Cartesian3.multiplyByScalar(\n        Cartesian3.UNIT_Y,\n        5.0 * CesiumMath.EPSILON9,\n        offsetScratch\n      );\n      if (p0.y < 0.0) {\n        Cartesian3.negate(offset, offset);\n\n        p0Attributes = westGeometry.attributes;\n        p0Indices = westGeometry.indices;\n        p0IndexMap = westGeometryIndexMap;\n        p1Attributes = eastGeometry.attributes;\n        p1Indices = eastGeometry.indices;\n        p1IndexMap = eastGeometryIndexMap;\n      }\n\n      var offsetPoint = Cartesian3.add(\n        intersection,\n        offset,\n        offsetPointScratch\n      );\n\n      insertIndex = insertSplitPoint(\n        p0Attributes,\n        p0Indices,\n        p0IndexMap,\n        indices,\n        i,\n        p0\n      );\n      computeLineAttributes(\n        i0,\n        i1,\n        p0,\n        positions,\n        insertIndex,\n        p0Attributes,\n        applyOffset\n      );\n\n      insertIndex = insertSplitPoint(\n        p0Attributes,\n        p0Indices,\n        p0IndexMap,\n        indices,\n        -1,\n        offsetPoint\n      );\n      computeLineAttributes(\n        i0,\n        i1,\n        offsetPoint,\n        positions,\n        insertIndex,\n        p0Attributes,\n        applyOffset\n      );\n\n      Cartesian3.negate(offset, offset);\n      Cartesian3.add(intersection, offset, offsetPoint);\n      insertIndex = insertSplitPoint(\n        p1Attributes,\n        p1Indices,\n        p1IndexMap,\n        indices,\n        -1,\n        offsetPoint\n      );\n      computeLineAttributes(\n        i0,\n        i1,\n        offsetPoint,\n        positions,\n        insertIndex,\n        p1Attributes,\n        applyOffset\n      );\n\n      insertIndex = insertSplitPoint(\n        p1Attributes,\n        p1Indices,\n        p1IndexMap,\n        indices,\n        i + 1,\n        p1\n      );\n      computeLineAttributes(\n        i0,\n        i1,\n        p1,\n        positions,\n        insertIndex,\n        p1Attributes,\n        applyOffset\n      );\n    } else {\n      var currentAttributes;\n      var currentIndices;\n      var currentIndexMap;\n\n      if (p0.y < 0.0) {\n        currentAttributes = westGeometry.attributes;\n        currentIndices = westGeometry.indices;\n        currentIndexMap = westGeometryIndexMap;\n      } else {\n        currentAttributes = eastGeometry.attributes;\n        currentIndices = eastGeometry.indices;\n        currentIndexMap = eastGeometryIndexMap;\n      }\n\n      insertIndex = insertSplitPoint(\n        currentAttributes,\n        currentIndices,\n        currentIndexMap,\n        indices,\n        i,\n        p0\n      );\n      computeLineAttributes(\n        i0,\n        i1,\n        p0,\n        positions,\n        insertIndex,\n        currentAttributes,\n        applyOffset\n      );\n\n      insertIndex = insertSplitPoint(\n        currentAttributes,\n        currentIndices,\n        currentIndexMap,\n        indices,\n        i + 1,\n        p1\n      );\n      computeLineAttributes(\n        i0,\n        i1,\n        p1,\n        positions,\n        insertIndex,\n        currentAttributes,\n        applyOffset\n      );\n    }\n  }\n\n  updateInstanceAfterSplit(instance, westGeometry, eastGeometry);\n}\n\nvar cartesian2Scratch0 = new Cartesian2();\nvar cartesian2Scratch1 = new Cartesian2();\n\nvar cartesian3Scratch0 = new Cartesian3();\nvar cartesian3Scratch2 = new Cartesian3();\nvar cartesian3Scratch3 = new Cartesian3();\nvar cartesian3Scratch4 = new Cartesian3();\nvar cartesian3Scratch5 = new Cartesian3();\nvar cartesian3Scratch6 = new Cartesian3();\n\nvar cartesian4Scratch0 = new Cartesian4();\n\nfunction updateAdjacencyAfterSplit(geometry) {\n  var attributes = geometry.attributes;\n  var positions = attributes.position.values;\n  var prevPositions = attributes.prevPosition.values;\n  var nextPositions = attributes.nextPosition.values;\n\n  var length = positions.length;\n  for (var j = 0; j < length; j += 3) {\n    var position = Cartesian3.unpack(positions, j, cartesian3Scratch0);\n    if (position.x > 0.0) {\n      continue;\n    }\n\n    var prevPosition = Cartesian3.unpack(prevPositions, j, cartesian3Scratch2);\n    if (\n      (position.y < 0.0 && prevPosition.y > 0.0) ||\n      (position.y > 0.0 && prevPosition.y < 0.0)\n    ) {\n      if (j - 3 > 0) {\n        prevPositions[j] = positions[j - 3];\n        prevPositions[j + 1] = positions[j - 2];\n        prevPositions[j + 2] = positions[j - 1];\n      } else {\n        Cartesian3.pack(position, prevPositions, j);\n      }\n    }\n\n    var nextPosition = Cartesian3.unpack(nextPositions, j, cartesian3Scratch3);\n    if (\n      (position.y < 0.0 && nextPosition.y > 0.0) ||\n      (position.y > 0.0 && nextPosition.y < 0.0)\n    ) {\n      if (j + 3 < length) {\n        nextPositions[j] = positions[j + 3];\n        nextPositions[j + 1] = positions[j + 4];\n        nextPositions[j + 2] = positions[j + 5];\n      } else {\n        Cartesian3.pack(position, nextPositions, j);\n      }\n    }\n  }\n}\n\nvar offsetScalar = 5.0 * CesiumMath.EPSILON9;\nvar coplanarOffset = CesiumMath.EPSILON6;\n\nfunction splitLongitudePolyline(instance) {\n  var geometry = instance.geometry;\n  var attributes = geometry.attributes;\n  var positions = attributes.position.values;\n  var prevPositions = attributes.prevPosition.values;\n  var nextPositions = attributes.nextPosition.values;\n  var expandAndWidths = attributes.expandAndWidth.values;\n\n  var texCoords = defined(attributes.st) ? attributes.st.values : undefined;\n  var colors = defined(attributes.color) ? attributes.color.values : undefined;\n\n  var eastGeometry = copyGeometryForSplit(geometry);\n  var westGeometry = copyGeometryForSplit(geometry);\n\n  var i;\n  var j;\n  var index;\n\n  var intersectionFound = false;\n\n  var length = positions.length / 3;\n  for (i = 0; i < length; i += 4) {\n    var i0 = i;\n    var i2 = i + 2;\n\n    var p0 = Cartesian3.fromArray(positions, i0 * 3, cartesian3Scratch0);\n    var p2 = Cartesian3.fromArray(positions, i2 * 3, cartesian3Scratch2);\n\n    // Offset points that are close to the 180 longitude and change the previous/next point\n    // to be the same offset point so it can be projected to 2D. There is special handling in the\n    // shader for when position == prevPosition || position == nextPosition.\n    if (Math.abs(p0.y) < coplanarOffset) {\n      p0.y = coplanarOffset * (p2.y < 0.0 ? -1.0 : 1.0);\n      positions[i * 3 + 1] = p0.y;\n      positions[(i + 1) * 3 + 1] = p0.y;\n\n      for (j = i0 * 3; j < i0 * 3 + 4 * 3; j += 3) {\n        prevPositions[j] = positions[i * 3];\n        prevPositions[j + 1] = positions[i * 3 + 1];\n        prevPositions[j + 2] = positions[i * 3 + 2];\n      }\n    }\n\n    // Do the same but for when the line crosses 180 longitude in the opposite direction.\n    if (Math.abs(p2.y) < coplanarOffset) {\n      p2.y = coplanarOffset * (p0.y < 0.0 ? -1.0 : 1.0);\n      positions[(i + 2) * 3 + 1] = p2.y;\n      positions[(i + 3) * 3 + 1] = p2.y;\n\n      for (j = i0 * 3; j < i0 * 3 + 4 * 3; j += 3) {\n        nextPositions[j] = positions[(i + 2) * 3];\n        nextPositions[j + 1] = positions[(i + 2) * 3 + 1];\n        nextPositions[j + 2] = positions[(i + 2) * 3 + 2];\n      }\n    }\n\n    var p0Attributes = eastGeometry.attributes;\n    var p0Indices = eastGeometry.indices;\n    var p2Attributes = westGeometry.attributes;\n    var p2Indices = westGeometry.indices;\n\n    var intersection = IntersectionTests.lineSegmentPlane(\n      p0,\n      p2,\n      xzPlane,\n      cartesian3Scratch4\n    );\n    if (defined(intersection)) {\n      intersectionFound = true;\n\n      // move point on the xz-plane slightly away from the plane\n      var offset = Cartesian3.multiplyByScalar(\n        Cartesian3.UNIT_Y,\n        offsetScalar,\n        cartesian3Scratch5\n      );\n      if (p0.y < 0.0) {\n        Cartesian3.negate(offset, offset);\n        p0Attributes = westGeometry.attributes;\n        p0Indices = westGeometry.indices;\n        p2Attributes = eastGeometry.attributes;\n        p2Indices = eastGeometry.indices;\n      }\n\n      var offsetPoint = Cartesian3.add(\n        intersection,\n        offset,\n        cartesian3Scratch6\n      );\n      p0Attributes.position.values.push(p0.x, p0.y, p0.z, p0.x, p0.y, p0.z);\n      p0Attributes.position.values.push(\n        offsetPoint.x,\n        offsetPoint.y,\n        offsetPoint.z\n      );\n      p0Attributes.position.values.push(\n        offsetPoint.x,\n        offsetPoint.y,\n        offsetPoint.z\n      );\n\n      p0Attributes.prevPosition.values.push(\n        prevPositions[i0 * 3],\n        prevPositions[i0 * 3 + 1],\n        prevPositions[i0 * 3 + 2]\n      );\n      p0Attributes.prevPosition.values.push(\n        prevPositions[i0 * 3 + 3],\n        prevPositions[i0 * 3 + 4],\n        prevPositions[i0 * 3 + 5]\n      );\n      p0Attributes.prevPosition.values.push(p0.x, p0.y, p0.z, p0.x, p0.y, p0.z);\n\n      p0Attributes.nextPosition.values.push(\n        offsetPoint.x,\n        offsetPoint.y,\n        offsetPoint.z\n      );\n      p0Attributes.nextPosition.values.push(\n        offsetPoint.x,\n        offsetPoint.y,\n        offsetPoint.z\n      );\n      p0Attributes.nextPosition.values.push(\n        offsetPoint.x,\n        offsetPoint.y,\n        offsetPoint.z\n      );\n      p0Attributes.nextPosition.values.push(\n        offsetPoint.x,\n        offsetPoint.y,\n        offsetPoint.z\n      );\n\n      Cartesian3.negate(offset, offset);\n      Cartesian3.add(intersection, offset, offsetPoint);\n      p2Attributes.position.values.push(\n        offsetPoint.x,\n        offsetPoint.y,\n        offsetPoint.z\n      );\n      p2Attributes.position.values.push(\n        offsetPoint.x,\n        offsetPoint.y,\n        offsetPoint.z\n      );\n      p2Attributes.position.values.push(p2.x, p2.y, p2.z, p2.x, p2.y, p2.z);\n\n      p2Attributes.prevPosition.values.push(\n        offsetPoint.x,\n        offsetPoint.y,\n        offsetPoint.z\n      );\n      p2Attributes.prevPosition.values.push(\n        offsetPoint.x,\n        offsetPoint.y,\n        offsetPoint.z\n      );\n      p2Attributes.prevPosition.values.push(\n        offsetPoint.x,\n        offsetPoint.y,\n        offsetPoint.z\n      );\n      p2Attributes.prevPosition.values.push(\n        offsetPoint.x,\n        offsetPoint.y,\n        offsetPoint.z\n      );\n\n      p2Attributes.nextPosition.values.push(p2.x, p2.y, p2.z, p2.x, p2.y, p2.z);\n      p2Attributes.nextPosition.values.push(\n        nextPositions[i2 * 3],\n        nextPositions[i2 * 3 + 1],\n        nextPositions[i2 * 3 + 2]\n      );\n      p2Attributes.nextPosition.values.push(\n        nextPositions[i2 * 3 + 3],\n        nextPositions[i2 * 3 + 4],\n        nextPositions[i2 * 3 + 5]\n      );\n\n      var ew0 = Cartesian2.fromArray(\n        expandAndWidths,\n        i0 * 2,\n        cartesian2Scratch0\n      );\n      var width = Math.abs(ew0.y);\n\n      p0Attributes.expandAndWidth.values.push(-1, width, 1, width);\n      p0Attributes.expandAndWidth.values.push(-1, -width, 1, -width);\n      p2Attributes.expandAndWidth.values.push(-1, width, 1, width);\n      p2Attributes.expandAndWidth.values.push(-1, -width, 1, -width);\n\n      var t = Cartesian3.magnitudeSquared(\n        Cartesian3.subtract(intersection, p0, cartesian3Scratch3)\n      );\n      t /= Cartesian3.magnitudeSquared(\n        Cartesian3.subtract(p2, p0, cartesian3Scratch3)\n      );\n\n      if (defined(colors)) {\n        var c0 = Cartesian4.fromArray(colors, i0 * 4, cartesian4Scratch0);\n        var c2 = Cartesian4.fromArray(colors, i2 * 4, cartesian4Scratch0);\n\n        var r = CesiumMath.lerp(c0.x, c2.x, t);\n        var g = CesiumMath.lerp(c0.y, c2.y, t);\n        var b = CesiumMath.lerp(c0.z, c2.z, t);\n        var a = CesiumMath.lerp(c0.w, c2.w, t);\n\n        for (j = i0 * 4; j < i0 * 4 + 2 * 4; ++j) {\n          p0Attributes.color.values.push(colors[j]);\n        }\n        p0Attributes.color.values.push(r, g, b, a);\n        p0Attributes.color.values.push(r, g, b, a);\n        p2Attributes.color.values.push(r, g, b, a);\n        p2Attributes.color.values.push(r, g, b, a);\n        for (j = i2 * 4; j < i2 * 4 + 2 * 4; ++j) {\n          p2Attributes.color.values.push(colors[j]);\n        }\n      }\n\n      if (defined(texCoords)) {\n        var s0 = Cartesian2.fromArray(texCoords, i0 * 2, cartesian2Scratch0);\n        var s3 = Cartesian2.fromArray(\n          texCoords,\n          (i + 3) * 2,\n          cartesian2Scratch1\n        );\n\n        var sx = CesiumMath.lerp(s0.x, s3.x, t);\n\n        for (j = i0 * 2; j < i0 * 2 + 2 * 2; ++j) {\n          p0Attributes.st.values.push(texCoords[j]);\n        }\n        p0Attributes.st.values.push(sx, s0.y);\n        p0Attributes.st.values.push(sx, s3.y);\n        p2Attributes.st.values.push(sx, s0.y);\n        p2Attributes.st.values.push(sx, s3.y);\n        for (j = i2 * 2; j < i2 * 2 + 2 * 2; ++j) {\n          p2Attributes.st.values.push(texCoords[j]);\n        }\n      }\n\n      index = p0Attributes.position.values.length / 3 - 4;\n      p0Indices.push(index, index + 2, index + 1);\n      p0Indices.push(index + 1, index + 2, index + 3);\n\n      index = p2Attributes.position.values.length / 3 - 4;\n      p2Indices.push(index, index + 2, index + 1);\n      p2Indices.push(index + 1, index + 2, index + 3);\n    } else {\n      var currentAttributes;\n      var currentIndices;\n\n      if (p0.y < 0.0) {\n        currentAttributes = westGeometry.attributes;\n        currentIndices = westGeometry.indices;\n      } else {\n        currentAttributes = eastGeometry.attributes;\n        currentIndices = eastGeometry.indices;\n      }\n\n      currentAttributes.position.values.push(p0.x, p0.y, p0.z);\n      currentAttributes.position.values.push(p0.x, p0.y, p0.z);\n      currentAttributes.position.values.push(p2.x, p2.y, p2.z);\n      currentAttributes.position.values.push(p2.x, p2.y, p2.z);\n\n      for (j = i * 3; j < i * 3 + 4 * 3; ++j) {\n        currentAttributes.prevPosition.values.push(prevPositions[j]);\n        currentAttributes.nextPosition.values.push(nextPositions[j]);\n      }\n\n      for (j = i * 2; j < i * 2 + 4 * 2; ++j) {\n        currentAttributes.expandAndWidth.values.push(expandAndWidths[j]);\n        if (defined(texCoords)) {\n          currentAttributes.st.values.push(texCoords[j]);\n        }\n      }\n\n      if (defined(colors)) {\n        for (j = i * 4; j < i * 4 + 4 * 4; ++j) {\n          currentAttributes.color.values.push(colors[j]);\n        }\n      }\n\n      index = currentAttributes.position.values.length / 3 - 4;\n      currentIndices.push(index, index + 2, index + 1);\n      currentIndices.push(index + 1, index + 2, index + 3);\n    }\n  }\n\n  if (intersectionFound) {\n    updateAdjacencyAfterSplit(westGeometry);\n    updateAdjacencyAfterSplit(eastGeometry);\n  }\n\n  updateInstanceAfterSplit(instance, westGeometry, eastGeometry);\n}\n\n/**\n * Splits the instances's geometry, by introducing new vertices and indices,that\n * intersect the International Date Line and Prime Meridian so that no primitives cross longitude\n * -180/180 degrees.  This is not required for 3D drawing, but is required for\n * correcting drawing in 2D and Columbus view.\n *\n * @private\n *\n * @param {GeometryInstance} instance The instance to modify.\n * @returns {GeometryInstance} The modified <code>instance</code> argument, with it's geometry split at the International Date Line.\n *\n * @example\n * instance = Cesium.GeometryPipeline.splitLongitude(instance);\n */\nGeometryPipeline.splitLongitude = function (instance) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(instance)) {\n    throw new DeveloperError(\"instance is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var geometry = instance.geometry;\n  var boundingSphere = geometry.boundingSphere;\n  if (defined(boundingSphere)) {\n    var minX = boundingSphere.center.x - boundingSphere.radius;\n    if (\n      minX > 0 ||\n      BoundingSphere.intersectPlane(boundingSphere, Plane.ORIGIN_ZX_PLANE) !==\n        Intersect.INTERSECTING\n    ) {\n      return instance;\n    }\n  }\n\n  if (geometry.geometryType !== GeometryType.NONE) {\n    switch (geometry.geometryType) {\n      case GeometryType.POLYLINES:\n        splitLongitudePolyline(instance);\n        break;\n      case GeometryType.TRIANGLES:\n        splitLongitudeTriangles(instance);\n        break;\n      case GeometryType.LINES:\n        splitLongitudeLines(instance);\n        break;\n    }\n  } else {\n    indexPrimitive(geometry);\n    if (geometry.primitiveType === PrimitiveType.TRIANGLES) {\n      splitLongitudeTriangles(instance);\n    } else if (geometry.primitiveType === PrimitiveType.LINES) {\n      splitLongitudeLines(instance);\n    }\n  }\n\n  return instance;\n};\nexport default GeometryPipeline;\n"],"names":["scratchCartesian1","Cartesian3","scratchCartesian2","scratchCartesian3","Tipsify","calculateACMR","options","indices","defaultValue","EMPTY_OBJECT","maximumIndex","cacheSize","defined","DeveloperError","numIndices","length","currentIndex","intoIndices","vertexTimeStamps","i","s","j","tipsify","getNextVertex","oneRing","vertices","deadEnd","maximumIndexPlusOne","p","n","m","itOneRing","index","numLiveTriangles","timeStamp","d","splice","cursor","skipDeadEnd","endIndex","vertexTriangles","triangle","push","vertex","intoVertices","limit","f","currentOutputIndex","outputIndices","numTriangles","triangleEmitted","k","GeometryPipeline","addTriangle","lines","i0","i1","i2","copyAttributesDescriptions","attributes","attr","newAttributes","attribute","hasOwnProperty","values","GeometryAttribute","componentDatatype","componentsPerAttribute","normalize","toWireframe","geometry","primitiveType","PrimitiveType","TRIANGLES","triangles","count","size","IndexDatatype","createTypedArray","trianglesToLines","TRIANGLE_STRIP","Uint16Array","triangleStripToLines","TRIANGLE_FAN","base","triangleFanToLines","LINES","createLineSegmentsForVectors","attributeName","position","newBoundingSphere","positions","vectors","positionsLength","newPositions","Float64Array","bs","boundingSphere","BoundingSphere","center","radius","Geometry","ComponentDatatype","DOUBLE","createAttributeLocations","semantics","len","semantic","name","reorderForPreVertexCache","numVertices","computeNumberOfVertices","indexCrossReferenceOldToNew","Int32Array","tempIndex","indicesIn","indicesOut","intoIndicesIn","intoIndicesOut","nextIndex","property","elementsIn","intoElementsIn","numComponents","elementsOut","temp","reorderForPostVertexCache","cacheCapacity","fitToUnsignedShortIndices","POINTS","geometries","numberOfVertices","CesiumMath","SIXTY_FOUR_KILOBYTES","indicesPerPrimitive","oldToNewIndex","newIndices","originalIndices","numberOfIndices","x","destinationAttributes","sourceAttributes","copyVertex","boundingSphereCV","scratchProjectTo2DCartesian3","scratchProjectTo2DCartographic","Cartographic","projectTo2D","attributeName3D","attributeName2D","projection","ellipsoid","GeographicProjection","values3D","projectedValues","value","fromArray","lonLat","cartesianToCartographic","y","z","projectedLonLat","project","encodedResult","high","low","encodeAttribute","attributeHighName","attributeLowName","highValues","Float32Array","lowValues","EncodedCartesian3","encode","FLOAT","transformPoint","matrix","unpack","Matrix4","multiplyByPoint","pack","transformVector","Matrix3","multiplyByVector","inverseTranspose","normalMatrix","transformToWorldCoordinates","instance","modelMatrix","equals","IDENTITY","prevPosition","nextPosition","normal","tangent","bitangent","inverse","transpose","getMatrix3","transform","clone","tempScratch","combineGeometries","instances","propertyName","haveIndices","sourceValues","sourceValuesLength","attributesInAllGeometries","attributes0","numberOfComponents","inAllGeometries","otherAttribute","findAttributesInAllGeometries","destIndices","destOffset","offset","sourceIndices","sourceIndicesLen","undefined","add","divideByScalar","tempRadius","magnitude","subtract","combineInstances","instanceGeometry","instanceSplitGeometry","westHemisphereGeometry","eastHemisphereGeometry","v0","v1","v2","computeNormal","normalsPerVertex","Array","normalsPerTriangle","normalIndices","indexOffset","currentCount","i03","i13","i23","cross","vertexNormalData","normalValues","i3","ZERO","equalsEpsilon","EPSILON10","normalScratch","normalScale","tScratch","computeTangentAndBitangent","st","normals","tan1","i02","i12","i22","ux","uy","uz","wx","wy","t1","t2","r","sdirx","sdiry","sdirz","tangentValues","bitangentValues","t","scalar","dot","multiplyByScalar","Cartesian2","toEncode1","toEncode2","toEncode3","encodeResult2","indexPrimitive","indicesIndex","indexTriangleFan","indexTriangleStrip","indexTriangles","LINE_STRIP","indexLineStrip","LINE_LOOP","indexLineLoop","indexLines","offsetPointFromXZPlane","isBehind","Math","abs","EPSILON6","compressVertices","extrudeAttribute","extrudeDirection","extrudeDirections","compressedDirections","AttributeCompression","octEncodeInRange","compressedAttributes","normalAttribute","stAttribute","hasNormal","hasSt","tangents","bitangents","tangentAttribute","bitangentAttribute","hasTangent","hasBitangent","compressedLength","numCompressedComponents","normalIndex","compressTextureCoordinates","octPack","octEncodeFloat","c3","getXZIntersectionOffsetPoints","p1","u1","u2","q1","q2","splitTriangleResult","splitTriangle","p0","p2","p0y","p1y","p2y","sign","offsetTriangleFromXZPlane","p0Behind","p1Behind","p2Behind","numBehind","updateGeometryAfterSplit","computeBoundingSphere","fromVertices","copyGeometryForSplit","copiedAttributes","updateInstanceAfterSplit","westGeometry","eastGeometry","generateBarycentricInterpolateFunction","CartesianType","v0Scratch","v1Scratch","v2Scratch","coords","currentValues","insertedIndex","interpolateAndPackCartesian4","Cartesian4","interpolateAndPackCartesian3","interpolateAndPackCartesian2","interpolateAndPackBoolean","v3","p0Scratch","p1Scratch","p2Scratch","barycentricScratch","computeTriangleAttributes","point","texCoords","applyOffset","currentAttributes","customAttributeNames","customAttributesLength","allAttributes","d0","d1","d2","direction","result","dot00","dot01","dot02","dot11","dot12","Check","EPSILON14","UNIT_X","UNIT_Y","UNIT_Z","q","barycentricCoordinates","sourceAttribute","currentAttribute","genericInterpolate","insertSplitPoint","currentIndices","currentIndexMap","insertIndex","prevIndex","newIndex","NAMED_ATTRIBUTES","splitLongitudeTriangles","westGeometryIndexMap","eastGeometryIndexMap","resultPositions","resultIndices","resultLength","resultIndex","xzPlane","Plane","fromPointNormal","offsetScratch","offsetPointScratch","computeLineAttributes","splitLongitudeLines","offsetPoint","p0Attributes","p0Indices","p0IndexMap","p1Attributes","p1Indices","p1IndexMap","intersection","IntersectionTests","lineSegmentPlane","EPSILON9","negate","cartesian2Scratch0","cartesian2Scratch1","cartesian3Scratch0","cartesian3Scratch2","cartesian3Scratch3","cartesian3Scratch4","cartesian3Scratch5","cartesian3Scratch6","cartesian4Scratch0","updateAdjacencyAfterSplit","prevPositions","nextPositions","offsetScalar","coplanarOffset","splitLongitude","intersectPlane","ORIGIN_ZX_PLANE","Intersect","INTERSECTING","geometryType","GeometryType","NONE","POLYLINES","expandAndWidths","expandAndWidth","colors","color","intersectionFound","p2Attributes","p2Indices","ew0","width","magnitudeSquared","c0","c2","lerp","g","b","a","w","s0","s3","sx","splitLongitudePolyline"],"mappings":"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"}