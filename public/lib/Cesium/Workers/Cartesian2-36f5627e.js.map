{"version":3,"file":"Cartesian2-36f5627e.js","sources":["../../../../Source/Core/Cartesian3.js","../../../../Source/Core/scaleToGeodeticSurface.js","../../../../Source/Core/Cartographic.js","../../../../Source/Core/Ellipsoid.js","../../../../Source/Core/Rectangle.js","../../../../Source/Core/Cartesian2.js"],"sourcesContent":["import Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\n\n/**\n * A 3D Cartesian point.\n * @alias Cartesian3\n * @constructor\n *\n * @param {Number} [x=0.0] The X component.\n * @param {Number} [y=0.0] The Y component.\n * @param {Number} [z=0.0] The Z component.\n *\n * @see Cartesian2\n * @see Cartesian4\n * @see Packable\n */\nfunction Cartesian3(x, y, z) {\n  /**\n   * The X component.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.x = defaultValue(x, 0.0);\n\n  /**\n   * The Y component.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.y = defaultValue(y, 0.0);\n\n  /**\n   * The Z component.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.z = defaultValue(z, 0.0);\n}\n\n/**\n * Converts the provided Spherical into Cartesian3 coordinates.\n *\n * @param {Spherical} spherical The Spherical to be converted to Cartesian3.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n */\nCartesian3.fromSpherical = function (spherical, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"spherical\", spherical);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  var clock = spherical.clock;\n  var cone = spherical.cone;\n  var magnitude = defaultValue(spherical.magnitude, 1.0);\n  var radial = magnitude * Math.sin(cone);\n  result.x = radial * Math.cos(clock);\n  result.y = radial * Math.sin(clock);\n  result.z = magnitude * Math.cos(cone);\n  return result;\n};\n\n/**\n * Creates a Cartesian3 instance from x, y and z coordinates.\n *\n * @param {Number} x The x coordinate.\n * @param {Number} y The y coordinate.\n * @param {Number} z The z coordinate.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n */\nCartesian3.fromElements = function (x, y, z, result) {\n  if (!defined(result)) {\n    return new Cartesian3(x, y, z);\n  }\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  return result;\n};\n\n/**\n * Duplicates a Cartesian3 instance.\n *\n * @param {Cartesian3} cartesian The Cartesian to duplicate.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided. (Returns undefined if cartesian is undefined)\n */\nCartesian3.clone = function (cartesian, result) {\n  if (!defined(cartesian)) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    return new Cartesian3(cartesian.x, cartesian.y, cartesian.z);\n  }\n\n  result.x = cartesian.x;\n  result.y = cartesian.y;\n  result.z = cartesian.z;\n  return result;\n};\n\n/**\n * Creates a Cartesian3 instance from an existing Cartesian4.  This simply takes the\n * x, y, and z properties of the Cartesian4 and drops w.\n * @function\n *\n * @param {Cartesian4} cartesian The Cartesian4 instance to create a Cartesian3 instance from.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n */\nCartesian3.fromCartesian4 = Cartesian3.clone;\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nCartesian3.packedLength = 3;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Cartesian3} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nCartesian3.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  array[startingIndex++] = value.x;\n  array[startingIndex++] = value.y;\n  array[startingIndex] = value.z;\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Cartesian3} [result] The object into which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n */\nCartesian3.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  result.x = array[startingIndex++];\n  result.y = array[startingIndex++];\n  result.z = array[startingIndex];\n  return result;\n};\n\n/**\n * Flattens an array of Cartesian3s into an array of components.\n *\n * @param {Cartesian3[]} array The array of cartesians to pack.\n * @param {Number[]} [result] The array onto which to store the result. If this is a typed array, it must have array.length * 3 components, else a {@link DeveloperError} will be thrown. If it is a regular array, it will be resized to have (array.length * 3) elements.\n * @returns {Number[]} The packed array.\n */\nCartesian3.packArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  var length = array.length;\n  var resultLength = length * 3;\n  if (!defined(result)) {\n    result = new Array(resultLength);\n  } else if (!Array.isArray(result) && result.length !== resultLength) {\n    throw new DeveloperError(\n      \"If result is a typed array, it must have exactly array.length * 3 elements\"\n    );\n  } else if (result.length !== resultLength) {\n    result.length = resultLength;\n  }\n\n  for (var i = 0; i < length; ++i) {\n    Cartesian3.pack(array[i], result, i * 3);\n  }\n  return result;\n};\n\n/**\n * Unpacks an array of cartesian components into an array of Cartesian3s.\n *\n * @param {Number[]} array The array of components to unpack.\n * @param {Cartesian3[]} [result] The array onto which to store the result.\n * @returns {Cartesian3[]} The unpacked array.\n */\nCartesian3.unpackArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  Check.typeOf.number.greaterThanOrEquals(\"array.length\", array.length, 3);\n  if (array.length % 3 !== 0) {\n    throw new DeveloperError(\"array length must be a multiple of 3.\");\n  }\n  //>>includeEnd('debug');\n\n  var length = array.length;\n  if (!defined(result)) {\n    result = new Array(length / 3);\n  } else {\n    result.length = length / 3;\n  }\n\n  for (var i = 0; i < length; i += 3) {\n    var index = i / 3;\n    result[index] = Cartesian3.unpack(array, i, result[index]);\n  }\n  return result;\n};\n\n/**\n * Creates a Cartesian3 from three consecutive elements in an array.\n * @function\n *\n * @param {Number[]} array The array whose three consecutive elements correspond to the x, y, and z components, respectively.\n * @param {Number} [startingIndex=0] The offset into the array of the first element, which corresponds to the x component.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n *\n * @example\n * // Create a Cartesian3 with (1.0, 2.0, 3.0)\n * var v = [1.0, 2.0, 3.0];\n * var p = Cesium.Cartesian3.fromArray(v);\n *\n * // Create a Cartesian3 with (1.0, 2.0, 3.0) using an offset into an array\n * var v2 = [0.0, 0.0, 1.0, 2.0, 3.0];\n * var p2 = Cesium.Cartesian3.fromArray(v2, 2);\n */\nCartesian3.fromArray = Cartesian3.unpack;\n\n/**\n * Computes the value of the maximum component for the supplied Cartesian.\n *\n * @param {Cartesian3} cartesian The cartesian to use.\n * @returns {Number} The value of the maximum component.\n */\nCartesian3.maximumComponent = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  return Math.max(cartesian.x, cartesian.y, cartesian.z);\n};\n\n/**\n * Computes the value of the minimum component for the supplied Cartesian.\n *\n * @param {Cartesian3} cartesian The cartesian to use.\n * @returns {Number} The value of the minimum component.\n */\nCartesian3.minimumComponent = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  return Math.min(cartesian.x, cartesian.y, cartesian.z);\n};\n\n/**\n * Compares two Cartesians and computes a Cartesian which contains the minimum components of the supplied Cartesians.\n *\n * @param {Cartesian3} first A cartesian to compare.\n * @param {Cartesian3} second A cartesian to compare.\n * @param {Cartesian3} result The object into which to store the result.\n * @returns {Cartesian3} A cartesian with the minimum components.\n */\nCartesian3.minimumByComponent = function (first, second, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"first\", first);\n  Check.typeOf.object(\"second\", second);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Math.min(first.x, second.x);\n  result.y = Math.min(first.y, second.y);\n  result.z = Math.min(first.z, second.z);\n\n  return result;\n};\n\n/**\n * Compares two Cartesians and computes a Cartesian which contains the maximum components of the supplied Cartesians.\n *\n * @param {Cartesian3} first A cartesian to compare.\n * @param {Cartesian3} second A cartesian to compare.\n * @param {Cartesian3} result The object into which to store the result.\n * @returns {Cartesian3} A cartesian with the maximum components.\n */\nCartesian3.maximumByComponent = function (first, second, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"first\", first);\n  Check.typeOf.object(\"second\", second);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Math.max(first.x, second.x);\n  result.y = Math.max(first.y, second.y);\n  result.z = Math.max(first.z, second.z);\n  return result;\n};\n\n/**\n * Computes the provided Cartesian's squared magnitude.\n *\n * @param {Cartesian3} cartesian The Cartesian instance whose squared magnitude is to be computed.\n * @returns {Number} The squared magnitude.\n */\nCartesian3.magnitudeSquared = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  return (\n    cartesian.x * cartesian.x +\n    cartesian.y * cartesian.y +\n    cartesian.z * cartesian.z\n  );\n};\n\n/**\n * Computes the Cartesian's magnitude (length).\n *\n * @param {Cartesian3} cartesian The Cartesian instance whose magnitude is to be computed.\n * @returns {Number} The magnitude.\n */\nCartesian3.magnitude = function (cartesian) {\n  return Math.sqrt(Cartesian3.magnitudeSquared(cartesian));\n};\n\nvar distanceScratch = new Cartesian3();\n\n/**\n * Computes the distance between two points.\n *\n * @param {Cartesian3} left The first point to compute the distance from.\n * @param {Cartesian3} right The second point to compute the distance to.\n * @returns {Number} The distance between two points.\n *\n * @example\n * // Returns 1.0\n * var d = Cesium.Cartesian3.distance(new Cesium.Cartesian3(1.0, 0.0, 0.0), new Cesium.Cartesian3(2.0, 0.0, 0.0));\n */\nCartesian3.distance = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  Cartesian3.subtract(left, right, distanceScratch);\n  return Cartesian3.magnitude(distanceScratch);\n};\n\n/**\n * Computes the squared distance between two points.  Comparing squared distances\n * using this function is more efficient than comparing distances using {@link Cartesian3#distance}.\n *\n * @param {Cartesian3} left The first point to compute the distance from.\n * @param {Cartesian3} right The second point to compute the distance to.\n * @returns {Number} The distance between two points.\n *\n * @example\n * // Returns 4.0, not 2.0\n * var d = Cesium.Cartesian3.distanceSquared(new Cesium.Cartesian3(1.0, 0.0, 0.0), new Cesium.Cartesian3(3.0, 0.0, 0.0));\n */\nCartesian3.distanceSquared = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  Cartesian3.subtract(left, right, distanceScratch);\n  return Cartesian3.magnitudeSquared(distanceScratch);\n};\n\n/**\n * Computes the normalized form of the supplied Cartesian.\n *\n * @param {Cartesian3} cartesian The Cartesian to be normalized.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.normalize = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var magnitude = Cartesian3.magnitude(cartesian);\n\n  result.x = cartesian.x / magnitude;\n  result.y = cartesian.y / magnitude;\n  result.z = cartesian.z / magnitude;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (isNaN(result.x) || isNaN(result.y) || isNaN(result.z)) {\n    throw new DeveloperError(\"normalized result is not a number\");\n  }\n  //>>includeEnd('debug');\n\n  return result;\n};\n\n/**\n * Computes the dot (scalar) product of two Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @returns {Number} The dot product.\n */\nCartesian3.dot = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  return left.x * right.x + left.y * right.y + left.z * right.z;\n};\n\n/**\n * Computes the componentwise product of two Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.multiplyComponents = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x * right.x;\n  result.y = left.y * right.y;\n  result.z = left.z * right.z;\n  return result;\n};\n\n/**\n * Computes the componentwise quotient of two Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.divideComponents = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x / right.x;\n  result.y = left.y / right.y;\n  result.z = left.z / right.z;\n  return result;\n};\n\n/**\n * Computes the componentwise sum of two Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.add = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x + right.x;\n  result.y = left.y + right.y;\n  result.z = left.z + right.z;\n  return result;\n};\n\n/**\n * Computes the componentwise difference of two Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.subtract = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x - right.x;\n  result.y = left.y - right.y;\n  result.z = left.z - right.z;\n  return result;\n};\n\n/**\n * Multiplies the provided Cartesian componentwise by the provided scalar.\n *\n * @param {Cartesian3} cartesian The Cartesian to be scaled.\n * @param {Number} scalar The scalar to multiply with.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.multiplyByScalar = function (cartesian, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = cartesian.x * scalar;\n  result.y = cartesian.y * scalar;\n  result.z = cartesian.z * scalar;\n  return result;\n};\n\n/**\n * Divides the provided Cartesian componentwise by the provided scalar.\n *\n * @param {Cartesian3} cartesian The Cartesian to be divided.\n * @param {Number} scalar The scalar to divide by.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.divideByScalar = function (cartesian, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = cartesian.x / scalar;\n  result.y = cartesian.y / scalar;\n  result.z = cartesian.z / scalar;\n  return result;\n};\n\n/**\n * Negates the provided Cartesian.\n *\n * @param {Cartesian3} cartesian The Cartesian to be negated.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.negate = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = -cartesian.x;\n  result.y = -cartesian.y;\n  result.z = -cartesian.z;\n  return result;\n};\n\n/**\n * Computes the absolute value of the provided Cartesian.\n *\n * @param {Cartesian3} cartesian The Cartesian whose absolute value is to be computed.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.abs = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Math.abs(cartesian.x);\n  result.y = Math.abs(cartesian.y);\n  result.z = Math.abs(cartesian.z);\n  return result;\n};\n\nvar lerpScratch = new Cartesian3();\n/**\n * Computes the linear interpolation or extrapolation at t using the provided cartesians.\n *\n * @param {Cartesian3} start The value corresponding to t at 0.0.\n * @param {Cartesian3} end The value corresponding to t at 1.0.\n * @param {Number} t The point along t at which to interpolate.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.lerp = function (start, end, t, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"start\", start);\n  Check.typeOf.object(\"end\", end);\n  Check.typeOf.number(\"t\", t);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  Cartesian3.multiplyByScalar(end, t, lerpScratch);\n  result = Cartesian3.multiplyByScalar(start, 1.0 - t, result);\n  return Cartesian3.add(lerpScratch, result, result);\n};\n\nvar angleBetweenScratch = new Cartesian3();\nvar angleBetweenScratch2 = new Cartesian3();\n/**\n * Returns the angle, in radians, between the provided Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @returns {Number} The angle between the Cartesians.\n */\nCartesian3.angleBetween = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  Cartesian3.normalize(left, angleBetweenScratch);\n  Cartesian3.normalize(right, angleBetweenScratch2);\n  var cosine = Cartesian3.dot(angleBetweenScratch, angleBetweenScratch2);\n  var sine = Cartesian3.magnitude(\n    Cartesian3.cross(\n      angleBetweenScratch,\n      angleBetweenScratch2,\n      angleBetweenScratch\n    )\n  );\n  return Math.atan2(sine, cosine);\n};\n\nvar mostOrthogonalAxisScratch = new Cartesian3();\n/**\n * Returns the axis that is most orthogonal to the provided Cartesian.\n *\n * @param {Cartesian3} cartesian The Cartesian on which to find the most orthogonal axis.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The most orthogonal axis.\n */\nCartesian3.mostOrthogonalAxis = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var f = Cartesian3.normalize(cartesian, mostOrthogonalAxisScratch);\n  Cartesian3.abs(f, f);\n\n  if (f.x <= f.y) {\n    if (f.x <= f.z) {\n      result = Cartesian3.clone(Cartesian3.UNIT_X, result);\n    } else {\n      result = Cartesian3.clone(Cartesian3.UNIT_Z, result);\n    }\n  } else if (f.y <= f.z) {\n    result = Cartesian3.clone(Cartesian3.UNIT_Y, result);\n  } else {\n    result = Cartesian3.clone(Cartesian3.UNIT_Z, result);\n  }\n\n  return result;\n};\n\n/**\n * Projects vector a onto vector b\n * @param {Cartesian3} a The vector that needs projecting\n * @param {Cartesian3} b The vector to project onto\n * @param {Cartesian3} result The result cartesian\n * @returns {Cartesian3} The modified result parameter\n */\nCartesian3.projectVector = function (a, b, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"a\", a);\n  Check.defined(\"b\", b);\n  Check.defined(\"result\", result);\n  //>>includeEnd('debug');\n\n  var scalar = Cartesian3.dot(a, b) / Cartesian3.dot(b, b);\n  return Cartesian3.multiplyByScalar(b, scalar, result);\n};\n\n/**\n * Compares the provided Cartesians componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartesian3} [left] The first Cartesian.\n * @param {Cartesian3} [right] The second Cartesian.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nCartesian3.equals = function (left, right) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      left.x === right.x &&\n      left.y === right.y &&\n      left.z === right.z)\n  );\n};\n\n/**\n * @private\n */\nCartesian3.equalsArray = function (cartesian, array, offset) {\n  return (\n    cartesian.x === array[offset] &&\n    cartesian.y === array[offset + 1] &&\n    cartesian.z === array[offset + 2]\n  );\n};\n\n/**\n * Compares the provided Cartesians componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {Cartesian3} [left] The first Cartesian.\n * @param {Cartesian3} [right] The second Cartesian.\n * @param {Number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\nCartesian3.equalsEpsilon = function (\n  left,\n  right,\n  relativeEpsilon,\n  absoluteEpsilon\n) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      CesiumMath.equalsEpsilon(\n        left.x,\n        right.x,\n        relativeEpsilon,\n        absoluteEpsilon\n      ) &&\n      CesiumMath.equalsEpsilon(\n        left.y,\n        right.y,\n        relativeEpsilon,\n        absoluteEpsilon\n      ) &&\n      CesiumMath.equalsEpsilon(\n        left.z,\n        right.z,\n        relativeEpsilon,\n        absoluteEpsilon\n      ))\n  );\n};\n\n/**\n * Computes the cross (outer) product of two Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The cross product.\n */\nCartesian3.cross = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var leftX = left.x;\n  var leftY = left.y;\n  var leftZ = left.z;\n  var rightX = right.x;\n  var rightY = right.y;\n  var rightZ = right.z;\n\n  var x = leftY * rightZ - leftZ * rightY;\n  var y = leftZ * rightX - leftX * rightZ;\n  var z = leftX * rightY - leftY * rightX;\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  return result;\n};\n\n/**\n * Computes the midpoint between the right and left Cartesian.\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The midpoint.\n */\nCartesian3.midpoint = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = (left.x + right.x) * 0.5;\n  result.y = (left.y + right.y) * 0.5;\n  result.z = (left.z + right.z) * 0.5;\n\n  return result;\n};\n\n/**\n * Returns a Cartesian3 position from longitude and latitude values given in degrees.\n *\n * @param {Number} longitude The longitude, in degrees\n * @param {Number} latitude The latitude, in degrees\n * @param {Number} [height=0.0] The height, in meters, above the ellipsoid.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the position lies.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The position\n *\n * @example\n * var position = Cesium.Cartesian3.fromDegrees(-115.0, 37.0);\n */\nCartesian3.fromDegrees = function (\n  longitude,\n  latitude,\n  height,\n  ellipsoid,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"longitude\", longitude);\n  Check.typeOf.number(\"latitude\", latitude);\n  //>>includeEnd('debug');\n\n  longitude = CesiumMath.toRadians(longitude);\n  latitude = CesiumMath.toRadians(latitude);\n  return Cartesian3.fromRadians(longitude, latitude, height, ellipsoid, result);\n};\n\nvar scratchN = new Cartesian3();\nvar scratchK = new Cartesian3();\nvar wgs84RadiiSquared = new Cartesian3(\n  6378137.0 * 6378137.0,\n  6378137.0 * 6378137.0,\n  6356752.3142451793 * 6356752.3142451793\n);\n\n/**\n * Returns a Cartesian3 position from longitude and latitude values given in radians.\n *\n * @param {Number} longitude The longitude, in radians\n * @param {Number} latitude The latitude, in radians\n * @param {Number} [height=0.0] The height, in meters, above the ellipsoid.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the position lies.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The position\n *\n * @example\n * var position = Cesium.Cartesian3.fromRadians(-2.007, 0.645);\n */\nCartesian3.fromRadians = function (\n  longitude,\n  latitude,\n  height,\n  ellipsoid,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"longitude\", longitude);\n  Check.typeOf.number(\"latitude\", latitude);\n  //>>includeEnd('debug');\n\n  height = defaultValue(height, 0.0);\n  var radiiSquared = defined(ellipsoid)\n    ? ellipsoid.radiiSquared\n    : wgs84RadiiSquared;\n\n  var cosLatitude = Math.cos(latitude);\n  scratchN.x = cosLatitude * Math.cos(longitude);\n  scratchN.y = cosLatitude * Math.sin(longitude);\n  scratchN.z = Math.sin(latitude);\n  scratchN = Cartesian3.normalize(scratchN, scratchN);\n\n  Cartesian3.multiplyComponents(radiiSquared, scratchN, scratchK);\n  var gamma = Math.sqrt(Cartesian3.dot(scratchN, scratchK));\n  scratchK = Cartesian3.divideByScalar(scratchK, gamma, scratchK);\n  scratchN = Cartesian3.multiplyByScalar(scratchN, height, scratchN);\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  return Cartesian3.add(scratchK, scratchN, result);\n};\n\n/**\n * Returns an array of Cartesian3 positions given an array of longitude and latitude values given in degrees.\n *\n * @param {Number[]} coordinates A list of longitude and latitude values. Values alternate [longitude, latitude, longitude, latitude...].\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the coordinates lie.\n * @param {Cartesian3[]} [result] An array of Cartesian3 objects to store the result.\n * @returns {Cartesian3[]} The array of positions.\n *\n * @example\n * var positions = Cesium.Cartesian3.fromDegreesArray([-115.0, 37.0, -107.0, 33.0]);\n */\nCartesian3.fromDegreesArray = function (coordinates, ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"coordinates\", coordinates);\n  if (coordinates.length < 2 || coordinates.length % 2 !== 0) {\n    throw new DeveloperError(\n      \"the number of coordinates must be a multiple of 2 and at least 2\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var length = coordinates.length;\n  if (!defined(result)) {\n    result = new Array(length / 2);\n  } else {\n    result.length = length / 2;\n  }\n\n  for (var i = 0; i < length; i += 2) {\n    var longitude = coordinates[i];\n    var latitude = coordinates[i + 1];\n    var index = i / 2;\n    result[index] = Cartesian3.fromDegrees(\n      longitude,\n      latitude,\n      0,\n      ellipsoid,\n      result[index]\n    );\n  }\n\n  return result;\n};\n\n/**\n * Returns an array of Cartesian3 positions given an array of longitude and latitude values given in radians.\n *\n * @param {Number[]} coordinates A list of longitude and latitude values. Values alternate [longitude, latitude, longitude, latitude...].\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the coordinates lie.\n * @param {Cartesian3[]} [result] An array of Cartesian3 objects to store the result.\n * @returns {Cartesian3[]} The array of positions.\n *\n * @example\n * var positions = Cesium.Cartesian3.fromRadiansArray([-2.007, 0.645, -1.867, .575]);\n */\nCartesian3.fromRadiansArray = function (coordinates, ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"coordinates\", coordinates);\n  if (coordinates.length < 2 || coordinates.length % 2 !== 0) {\n    throw new DeveloperError(\n      \"the number of coordinates must be a multiple of 2 and at least 2\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var length = coordinates.length;\n  if (!defined(result)) {\n    result = new Array(length / 2);\n  } else {\n    result.length = length / 2;\n  }\n\n  for (var i = 0; i < length; i += 2) {\n    var longitude = coordinates[i];\n    var latitude = coordinates[i + 1];\n    var index = i / 2;\n    result[index] = Cartesian3.fromRadians(\n      longitude,\n      latitude,\n      0,\n      ellipsoid,\n      result[index]\n    );\n  }\n\n  return result;\n};\n\n/**\n * Returns an array of Cartesian3 positions given an array of longitude, latitude and height values where longitude and latitude are given in degrees.\n *\n * @param {Number[]} coordinates A list of longitude, latitude and height values. Values alternate [longitude, latitude, height, longitude, latitude, height...].\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the position lies.\n * @param {Cartesian3[]} [result] An array of Cartesian3 objects to store the result.\n * @returns {Cartesian3[]} The array of positions.\n *\n * @example\n * var positions = Cesium.Cartesian3.fromDegreesArrayHeights([-115.0, 37.0, 100000.0, -107.0, 33.0, 150000.0]);\n */\nCartesian3.fromDegreesArrayHeights = function (coordinates, ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"coordinates\", coordinates);\n  if (coordinates.length < 3 || coordinates.length % 3 !== 0) {\n    throw new DeveloperError(\n      \"the number of coordinates must be a multiple of 3 and at least 3\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var length = coordinates.length;\n  if (!defined(result)) {\n    result = new Array(length / 3);\n  } else {\n    result.length = length / 3;\n  }\n\n  for (var i = 0; i < length; i += 3) {\n    var longitude = coordinates[i];\n    var latitude = coordinates[i + 1];\n    var height = coordinates[i + 2];\n    var index = i / 3;\n    result[index] = Cartesian3.fromDegrees(\n      longitude,\n      latitude,\n      height,\n      ellipsoid,\n      result[index]\n    );\n  }\n\n  return result;\n};\n\n/**\n * Returns an array of Cartesian3 positions given an array of longitude, latitude and height values where longitude and latitude are given in radians.\n *\n * @param {Number[]} coordinates A list of longitude, latitude and height values. Values alternate [longitude, latitude, height, longitude, latitude, height...].\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the position lies.\n * @param {Cartesian3[]} [result] An array of Cartesian3 objects to store the result.\n * @returns {Cartesian3[]} The array of positions.\n *\n * @example\n * var positions = Cesium.Cartesian3.fromRadiansArrayHeights([-2.007, 0.645, 100000.0, -1.867, .575, 150000.0]);\n */\nCartesian3.fromRadiansArrayHeights = function (coordinates, ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"coordinates\", coordinates);\n  if (coordinates.length < 3 || coordinates.length % 3 !== 0) {\n    throw new DeveloperError(\n      \"the number of coordinates must be a multiple of 3 and at least 3\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var length = coordinates.length;\n  if (!defined(result)) {\n    result = new Array(length / 3);\n  } else {\n    result.length = length / 3;\n  }\n\n  for (var i = 0; i < length; i += 3) {\n    var longitude = coordinates[i];\n    var latitude = coordinates[i + 1];\n    var height = coordinates[i + 2];\n    var index = i / 3;\n    result[index] = Cartesian3.fromRadians(\n      longitude,\n      latitude,\n      height,\n      ellipsoid,\n      result[index]\n    );\n  }\n\n  return result;\n};\n\n/**\n * An immutable Cartesian3 instance initialized to (0.0, 0.0, 0.0).\n *\n * @type {Cartesian3}\n * @constant\n */\nCartesian3.ZERO = Object.freeze(new Cartesian3(0.0, 0.0, 0.0));\n\n/**\n * An immutable Cartesian3 instance initialized to (1.0, 0.0, 0.0).\n *\n * @type {Cartesian3}\n * @constant\n */\nCartesian3.UNIT_X = Object.freeze(new Cartesian3(1.0, 0.0, 0.0));\n\n/**\n * An immutable Cartesian3 instance initialized to (0.0, 1.0, 0.0).\n *\n * @type {Cartesian3}\n * @constant\n */\nCartesian3.UNIT_Y = Object.freeze(new Cartesian3(0.0, 1.0, 0.0));\n\n/**\n * An immutable Cartesian3 instance initialized to (0.0, 0.0, 1.0).\n *\n * @type {Cartesian3}\n * @constant\n */\nCartesian3.UNIT_Z = Object.freeze(new Cartesian3(0.0, 0.0, 1.0));\n\n/**\n * Duplicates this Cartesian3 instance.\n *\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n */\nCartesian3.prototype.clone = function (result) {\n  return Cartesian3.clone(this, result);\n};\n\n/**\n * Compares this Cartesian against the provided Cartesian componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartesian3} [right] The right hand side Cartesian.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nCartesian3.prototype.equals = function (right) {\n  return Cartesian3.equals(this, right);\n};\n\n/**\n * Compares this Cartesian against the provided Cartesian componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {Cartesian3} [right] The right hand side Cartesian.\n * @param {Number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.\n */\nCartesian3.prototype.equalsEpsilon = function (\n  right,\n  relativeEpsilon,\n  absoluteEpsilon\n) {\n  return Cartesian3.equalsEpsilon(\n    this,\n    right,\n    relativeEpsilon,\n    absoluteEpsilon\n  );\n};\n\n/**\n * Creates a string representing this Cartesian in the format '(x, y, z)'.\n *\n * @returns {String} A string representing this Cartesian in the format '(x, y, z)'.\n */\nCartesian3.prototype.toString = function () {\n  return \"(\" + this.x + \", \" + this.y + \", \" + this.z + \")\";\n};\nexport default Cartesian3;\n","import Cartesian3 from \"./Cartesian3.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\n\nvar scaleToGeodeticSurfaceIntersection = new Cartesian3();\nvar scaleToGeodeticSurfaceGradient = new Cartesian3();\n\n/**\n * Scales the provided Cartesian position along the geodetic surface normal\n * so that it is on the surface of this ellipsoid.  If the position is\n * at the center of the ellipsoid, this function returns undefined.\n *\n * @param {Cartesian3} cartesian The Cartesian position to scale.\n * @param {Cartesian3} oneOverRadii One over radii of the ellipsoid.\n * @param {Cartesian3} oneOverRadiiSquared One over radii squared of the ellipsoid.\n * @param {Number} centerToleranceSquared Tolerance for closeness to the center.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter, a new Cartesian3 instance if none was provided, or undefined if the position is at the center.\n *\n * @function scaleToGeodeticSurface\n *\n * @private\n */\nfunction scaleToGeodeticSurface(\n  cartesian,\n  oneOverRadii,\n  oneOverRadiiSquared,\n  centerToleranceSquared,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(cartesian)) {\n    throw new DeveloperError(\"cartesian is required.\");\n  }\n  if (!defined(oneOverRadii)) {\n    throw new DeveloperError(\"oneOverRadii is required.\");\n  }\n  if (!defined(oneOverRadiiSquared)) {\n    throw new DeveloperError(\"oneOverRadiiSquared is required.\");\n  }\n  if (!defined(centerToleranceSquared)) {\n    throw new DeveloperError(\"centerToleranceSquared is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var positionX = cartesian.x;\n  var positionY = cartesian.y;\n  var positionZ = cartesian.z;\n\n  var oneOverRadiiX = oneOverRadii.x;\n  var oneOverRadiiY = oneOverRadii.y;\n  var oneOverRadiiZ = oneOverRadii.z;\n\n  var x2 = positionX * positionX * oneOverRadiiX * oneOverRadiiX;\n  var y2 = positionY * positionY * oneOverRadiiY * oneOverRadiiY;\n  var z2 = positionZ * positionZ * oneOverRadiiZ * oneOverRadiiZ;\n\n  // Compute the squared ellipsoid norm.\n  var squaredNorm = x2 + y2 + z2;\n  var ratio = Math.sqrt(1.0 / squaredNorm);\n\n  // As an initial approximation, assume that the radial intersection is the projection point.\n  var intersection = Cartesian3.multiplyByScalar(\n    cartesian,\n    ratio,\n    scaleToGeodeticSurfaceIntersection\n  );\n\n  // If the position is near the center, the iteration will not converge.\n  if (squaredNorm < centerToleranceSquared) {\n    return !isFinite(ratio)\n      ? undefined\n      : Cartesian3.clone(intersection, result);\n  }\n\n  var oneOverRadiiSquaredX = oneOverRadiiSquared.x;\n  var oneOverRadiiSquaredY = oneOverRadiiSquared.y;\n  var oneOverRadiiSquaredZ = oneOverRadiiSquared.z;\n\n  // Use the gradient at the intersection point in place of the true unit normal.\n  // The difference in magnitude will be absorbed in the multiplier.\n  var gradient = scaleToGeodeticSurfaceGradient;\n  gradient.x = intersection.x * oneOverRadiiSquaredX * 2.0;\n  gradient.y = intersection.y * oneOverRadiiSquaredY * 2.0;\n  gradient.z = intersection.z * oneOverRadiiSquaredZ * 2.0;\n\n  // Compute the initial guess at the normal vector multiplier, lambda.\n  var lambda =\n    ((1.0 - ratio) * Cartesian3.magnitude(cartesian)) /\n    (0.5 * Cartesian3.magnitude(gradient));\n  var correction = 0.0;\n\n  var func;\n  var denominator;\n  var xMultiplier;\n  var yMultiplier;\n  var zMultiplier;\n  var xMultiplier2;\n  var yMultiplier2;\n  var zMultiplier2;\n  var xMultiplier3;\n  var yMultiplier3;\n  var zMultiplier3;\n\n  do {\n    lambda -= correction;\n\n    xMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredX);\n    yMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredY);\n    zMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredZ);\n\n    xMultiplier2 = xMultiplier * xMultiplier;\n    yMultiplier2 = yMultiplier * yMultiplier;\n    zMultiplier2 = zMultiplier * zMultiplier;\n\n    xMultiplier3 = xMultiplier2 * xMultiplier;\n    yMultiplier3 = yMultiplier2 * yMultiplier;\n    zMultiplier3 = zMultiplier2 * zMultiplier;\n\n    func = x2 * xMultiplier2 + y2 * yMultiplier2 + z2 * zMultiplier2 - 1.0;\n\n    // \"denominator\" here refers to the use of this expression in the velocity and acceleration\n    // computations in the sections to follow.\n    denominator =\n      x2 * xMultiplier3 * oneOverRadiiSquaredX +\n      y2 * yMultiplier3 * oneOverRadiiSquaredY +\n      z2 * zMultiplier3 * oneOverRadiiSquaredZ;\n\n    var derivative = -2.0 * denominator;\n\n    correction = func / derivative;\n  } while (Math.abs(func) > CesiumMath.EPSILON12);\n\n  if (!defined(result)) {\n    return new Cartesian3(\n      positionX * xMultiplier,\n      positionY * yMultiplier,\n      positionZ * zMultiplier\n    );\n  }\n  result.x = positionX * xMultiplier;\n  result.y = positionY * yMultiplier;\n  result.z = positionZ * zMultiplier;\n  return result;\n}\nexport default scaleToGeodeticSurface;\n","import Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport CesiumMath from \"./Math.js\";\nimport scaleToGeodeticSurface from \"./scaleToGeodeticSurface.js\";\n\n/**\n * A position defined by longitude, latitude, and height.\n * @alias Cartographic\n * @constructor\n *\n * @param {Number} [longitude=0.0] The longitude, in radians.\n * @param {Number} [latitude=0.0] The latitude, in radians.\n * @param {Number} [height=0.0] The height, in meters, above the ellipsoid.\n *\n * @see Ellipsoid\n */\nfunction Cartographic(longitude, latitude, height) {\n  /**\n   * The longitude, in radians.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.longitude = defaultValue(longitude, 0.0);\n\n  /**\n   * The latitude, in radians.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.latitude = defaultValue(latitude, 0.0);\n\n  /**\n   * The height, in meters, above the ellipsoid.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.height = defaultValue(height, 0.0);\n}\n\n/**\n * Creates a new Cartographic instance from longitude and latitude\n * specified in radians.\n *\n * @param {Number} longitude The longitude, in radians.\n * @param {Number} latitude The latitude, in radians.\n * @param {Number} [height=0.0] The height, in meters, above the ellipsoid.\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if one was not provided.\n */\nCartographic.fromRadians = function (longitude, latitude, height, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"longitude\", longitude);\n  Check.typeOf.number(\"latitude\", latitude);\n  //>>includeEnd('debug');\n\n  height = defaultValue(height, 0.0);\n\n  if (!defined(result)) {\n    return new Cartographic(longitude, latitude, height);\n  }\n\n  result.longitude = longitude;\n  result.latitude = latitude;\n  result.height = height;\n  return result;\n};\n\n/**\n * Creates a new Cartographic instance from longitude and latitude\n * specified in degrees.  The values in the resulting object will\n * be in radians.\n *\n * @param {Number} longitude The longitude, in degrees.\n * @param {Number} latitude The latitude, in degrees.\n * @param {Number} [height=0.0] The height, in meters, above the ellipsoid.\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if one was not provided.\n */\nCartographic.fromDegrees = function (longitude, latitude, height, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"longitude\", longitude);\n  Check.typeOf.number(\"latitude\", latitude);\n  //>>includeEnd('debug');\n  longitude = CesiumMath.toRadians(longitude);\n  latitude = CesiumMath.toRadians(latitude);\n\n  return Cartographic.fromRadians(longitude, latitude, height, result);\n};\n\nvar cartesianToCartographicN = new Cartesian3();\nvar cartesianToCartographicP = new Cartesian3();\nvar cartesianToCartographicH = new Cartesian3();\nvar wgs84OneOverRadii = new Cartesian3(\n  1.0 / 6378137.0,\n  1.0 / 6378137.0,\n  1.0 / 6356752.3142451793\n);\nvar wgs84OneOverRadiiSquared = new Cartesian3(\n  1.0 / (6378137.0 * 6378137.0),\n  1.0 / (6378137.0 * 6378137.0),\n  1.0 / (6356752.3142451793 * 6356752.3142451793)\n);\nvar wgs84CenterToleranceSquared = CesiumMath.EPSILON1;\n\n/**\n * Creates a new Cartographic instance from a Cartesian position. The values in the\n * resulting object will be in radians.\n *\n * @param {Cartesian3} cartesian The Cartesian position to convert to cartographic representation.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the position lies.\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter, new Cartographic instance if none was provided, or undefined if the cartesian is at the center of the ellipsoid.\n */\nCartographic.fromCartesian = function (cartesian, ellipsoid, result) {\n  var oneOverRadii = defined(ellipsoid)\n    ? ellipsoid.oneOverRadii\n    : wgs84OneOverRadii;\n  var oneOverRadiiSquared = defined(ellipsoid)\n    ? ellipsoid.oneOverRadiiSquared\n    : wgs84OneOverRadiiSquared;\n  var centerToleranceSquared = defined(ellipsoid)\n    ? ellipsoid._centerToleranceSquared\n    : wgs84CenterToleranceSquared;\n\n  //`cartesian is required.` is thrown from scaleToGeodeticSurface\n  var p = scaleToGeodeticSurface(\n    cartesian,\n    oneOverRadii,\n    oneOverRadiiSquared,\n    centerToleranceSquared,\n    cartesianToCartographicP\n  );\n\n  if (!defined(p)) {\n    return undefined;\n  }\n\n  var n = Cartesian3.multiplyComponents(\n    p,\n    oneOverRadiiSquared,\n    cartesianToCartographicN\n  );\n  n = Cartesian3.normalize(n, n);\n\n  var h = Cartesian3.subtract(cartesian, p, cartesianToCartographicH);\n\n  var longitude = Math.atan2(n.y, n.x);\n  var latitude = Math.asin(n.z);\n  var height =\n    CesiumMath.sign(Cartesian3.dot(h, cartesian)) * Cartesian3.magnitude(h);\n\n  if (!defined(result)) {\n    return new Cartographic(longitude, latitude, height);\n  }\n  result.longitude = longitude;\n  result.latitude = latitude;\n  result.height = height;\n  return result;\n};\n\n/**\n * Creates a new Cartesian3 instance from a Cartographic input. The values in the inputted\n * object should be in radians.\n *\n * @param {Cartographic} cartographic Input to be converted into a Cartesian3 output.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the position lies.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The position\n */\nCartographic.toCartesian = function (cartographic, ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartographic\", cartographic);\n  //>>includeEnd('debug');\n\n  return Cartesian3.fromRadians(\n    cartographic.longitude,\n    cartographic.latitude,\n    cartographic.height,\n    ellipsoid,\n    result\n  );\n};\n\n/**\n * Duplicates a Cartographic instance.\n *\n * @param {Cartographic} cartographic The cartographic to duplicate.\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if one was not provided. (Returns undefined if cartographic is undefined)\n */\nCartographic.clone = function (cartographic, result) {\n  if (!defined(cartographic)) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    return new Cartographic(\n      cartographic.longitude,\n      cartographic.latitude,\n      cartographic.height\n    );\n  }\n  result.longitude = cartographic.longitude;\n  result.latitude = cartographic.latitude;\n  result.height = cartographic.height;\n  return result;\n};\n\n/**\n * Compares the provided cartographics componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartographic} [left] The first cartographic.\n * @param {Cartographic} [right] The second cartographic.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nCartographic.equals = function (left, right) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      left.longitude === right.longitude &&\n      left.latitude === right.latitude &&\n      left.height === right.height)\n  );\n};\n\n/**\n * Compares the provided cartographics componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {Cartographic} [left] The first cartographic.\n * @param {Cartographic} [right] The second cartographic.\n * @param {Number} [epsilon=0] The epsilon to use for equality testing.\n * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\nCartographic.equalsEpsilon = function (left, right, epsilon) {\n  epsilon = defaultValue(epsilon, 0);\n\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      Math.abs(left.longitude - right.longitude) <= epsilon &&\n      Math.abs(left.latitude - right.latitude) <= epsilon &&\n      Math.abs(left.height - right.height) <= epsilon)\n  );\n};\n\n/**\n * An immutable Cartographic instance initialized to (0.0, 0.0, 0.0).\n *\n * @type {Cartographic}\n * @constant\n */\nCartographic.ZERO = Object.freeze(new Cartographic(0.0, 0.0, 0.0));\n\n/**\n * Duplicates this instance.\n *\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if one was not provided.\n */\nCartographic.prototype.clone = function (result) {\n  return Cartographic.clone(this, result);\n};\n\n/**\n * Compares the provided against this cartographic componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartographic} [right] The second cartographic.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nCartographic.prototype.equals = function (right) {\n  return Cartographic.equals(this, right);\n};\n\n/**\n * Compares the provided against this cartographic componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {Cartographic} [right] The second cartographic.\n * @param {Number} [epsilon=0] The epsilon to use for equality testing.\n * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\nCartographic.prototype.equalsEpsilon = function (right, epsilon) {\n  return Cartographic.equalsEpsilon(this, right, epsilon);\n};\n\n/**\n * Creates a string representing this cartographic in the format '(longitude, latitude, height)'.\n *\n * @returns {String} A string representing the provided cartographic in the format '(longitude, latitude, height)'.\n */\nCartographic.prototype.toString = function () {\n  return \"(\" + this.longitude + \", \" + this.latitude + \", \" + this.height + \")\";\n};\nexport default Cartographic;\n","import Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\nimport scaleToGeodeticSurface from \"./scaleToGeodeticSurface.js\";\n\nfunction initialize(ellipsoid, x, y, z) {\n  x = defaultValue(x, 0.0);\n  y = defaultValue(y, 0.0);\n  z = defaultValue(z, 0.0);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.greaterThanOrEquals(\"x\", x, 0.0);\n  Check.typeOf.number.greaterThanOrEquals(\"y\", y, 0.0);\n  Check.typeOf.number.greaterThanOrEquals(\"z\", z, 0.0);\n  //>>includeEnd('debug');\n\n  ellipsoid._radii = new Cartesian3(x, y, z);\n\n  ellipsoid._radiiSquared = new Cartesian3(x * x, y * y, z * z);\n\n  ellipsoid._radiiToTheFourth = new Cartesian3(\n    x * x * x * x,\n    y * y * y * y,\n    z * z * z * z\n  );\n\n  ellipsoid._oneOverRadii = new Cartesian3(\n    x === 0.0 ? 0.0 : 1.0 / x,\n    y === 0.0 ? 0.0 : 1.0 / y,\n    z === 0.0 ? 0.0 : 1.0 / z\n  );\n\n  ellipsoid._oneOverRadiiSquared = new Cartesian3(\n    x === 0.0 ? 0.0 : 1.0 / (x * x),\n    y === 0.0 ? 0.0 : 1.0 / (y * y),\n    z === 0.0 ? 0.0 : 1.0 / (z * z)\n  );\n\n  ellipsoid._minimumRadius = Math.min(x, y, z);\n\n  ellipsoid._maximumRadius = Math.max(x, y, z);\n\n  ellipsoid._centerToleranceSquared = CesiumMath.EPSILON1;\n\n  if (ellipsoid._radiiSquared.z !== 0) {\n    ellipsoid._squaredXOverSquaredZ =\n      ellipsoid._radiiSquared.x / ellipsoid._radiiSquared.z;\n  }\n}\n\n/**\n * A quadratic surface defined in Cartesian coordinates by the equation\n * <code>(x / a)^2 + (y / b)^2 + (z / c)^2 = 1</code>.  Primarily used\n * by Cesium to represent the shape of planetary bodies.\n *\n * Rather than constructing this object directly, one of the provided\n * constants is normally used.\n * @alias Ellipsoid\n * @constructor\n *\n * @param {Number} [x=0] The radius in the x direction.\n * @param {Number} [y=0] The radius in the y direction.\n * @param {Number} [z=0] The radius in the z direction.\n *\n * @exception {DeveloperError} All radii components must be greater than or equal to zero.\n *\n * @see Ellipsoid.fromCartesian3\n * @see Ellipsoid.WGS84\n * @see Ellipsoid.UNIT_SPHERE\n */\nfunction Ellipsoid(x, y, z) {\n  this._radii = undefined;\n  this._radiiSquared = undefined;\n  this._radiiToTheFourth = undefined;\n  this._oneOverRadii = undefined;\n  this._oneOverRadiiSquared = undefined;\n  this._minimumRadius = undefined;\n  this._maximumRadius = undefined;\n  this._centerToleranceSquared = undefined;\n  this._squaredXOverSquaredZ = undefined;\n\n  initialize(this, x, y, z);\n}\n\nObject.defineProperties(Ellipsoid.prototype, {\n  /**\n   * Gets the radii of the ellipsoid.\n   * @memberof Ellipsoid.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  radii: {\n    get: function () {\n      return this._radii;\n    },\n  },\n  /**\n   * Gets the squared radii of the ellipsoid.\n   * @memberof Ellipsoid.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  radiiSquared: {\n    get: function () {\n      return this._radiiSquared;\n    },\n  },\n  /**\n   * Gets the radii of the ellipsoid raise to the fourth power.\n   * @memberof Ellipsoid.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  radiiToTheFourth: {\n    get: function () {\n      return this._radiiToTheFourth;\n    },\n  },\n  /**\n   * Gets one over the radii of the ellipsoid.\n   * @memberof Ellipsoid.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  oneOverRadii: {\n    get: function () {\n      return this._oneOverRadii;\n    },\n  },\n  /**\n   * Gets one over the squared radii of the ellipsoid.\n   * @memberof Ellipsoid.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  oneOverRadiiSquared: {\n    get: function () {\n      return this._oneOverRadiiSquared;\n    },\n  },\n  /**\n   * Gets the minimum radius of the ellipsoid.\n   * @memberof Ellipsoid.prototype\n   * @type {Number}\n   * @readonly\n   */\n  minimumRadius: {\n    get: function () {\n      return this._minimumRadius;\n    },\n  },\n  /**\n   * Gets the maximum radius of the ellipsoid.\n   * @memberof Ellipsoid.prototype\n   * @type {Number}\n   * @readonly\n   */\n  maximumRadius: {\n    get: function () {\n      return this._maximumRadius;\n    },\n  },\n});\n\n/**\n * Duplicates an Ellipsoid instance.\n *\n * @param {Ellipsoid} ellipsoid The ellipsoid to duplicate.\n * @param {Ellipsoid} [result] The object onto which to store the result, or undefined if a new\n *                    instance should be created.\n * @returns {Ellipsoid} The cloned Ellipsoid. (Returns undefined if ellipsoid is undefined)\n */\nEllipsoid.clone = function (ellipsoid, result) {\n  if (!defined(ellipsoid)) {\n    return undefined;\n  }\n  var radii = ellipsoid._radii;\n\n  if (!defined(result)) {\n    return new Ellipsoid(radii.x, radii.y, radii.z);\n  }\n\n  Cartesian3.clone(radii, result._radii);\n  Cartesian3.clone(ellipsoid._radiiSquared, result._radiiSquared);\n  Cartesian3.clone(ellipsoid._radiiToTheFourth, result._radiiToTheFourth);\n  Cartesian3.clone(ellipsoid._oneOverRadii, result._oneOverRadii);\n  Cartesian3.clone(ellipsoid._oneOverRadiiSquared, result._oneOverRadiiSquared);\n  result._minimumRadius = ellipsoid._minimumRadius;\n  result._maximumRadius = ellipsoid._maximumRadius;\n  result._centerToleranceSquared = ellipsoid._centerToleranceSquared;\n\n  return result;\n};\n\n/**\n * Computes an Ellipsoid from a Cartesian specifying the radii in x, y, and z directions.\n *\n * @param {Cartesian3} [cartesian=Cartesian3.ZERO] The ellipsoid's radius in the x, y, and z directions.\n * @param {Ellipsoid} [result] The object onto which to store the result, or undefined if a new\n *                    instance should be created.\n * @returns {Ellipsoid} A new Ellipsoid instance.\n *\n * @exception {DeveloperError} All radii components must be greater than or equal to zero.\n *\n * @see Ellipsoid.WGS84\n * @see Ellipsoid.UNIT_SPHERE\n */\nEllipsoid.fromCartesian3 = function (cartesian, result) {\n  if (!defined(result)) {\n    result = new Ellipsoid();\n  }\n\n  if (!defined(cartesian)) {\n    return result;\n  }\n\n  initialize(result, cartesian.x, cartesian.y, cartesian.z);\n  return result;\n};\n\n/**\n * An Ellipsoid instance initialized to the WGS84 standard.\n *\n * @type {Ellipsoid}\n * @constant\n */\nEllipsoid.WGS84 = Object.freeze(\n  new Ellipsoid(6378137.0, 6378137.0, 6356752.3142451793)\n);\n\n/**\n * An Ellipsoid instance initialized to radii of (1.0, 1.0, 1.0).\n *\n * @type {Ellipsoid}\n * @constant\n */\nEllipsoid.UNIT_SPHERE = Object.freeze(new Ellipsoid(1.0, 1.0, 1.0));\n\n/**\n * An Ellipsoid instance initialized to a sphere with the lunar radius.\n *\n * @type {Ellipsoid}\n * @constant\n */\nEllipsoid.MOON = Object.freeze(\n  new Ellipsoid(\n    CesiumMath.LUNAR_RADIUS,\n    CesiumMath.LUNAR_RADIUS,\n    CesiumMath.LUNAR_RADIUS\n  )\n);\n\n/**\n * Duplicates an Ellipsoid instance.\n *\n * @param {Ellipsoid} [result] The object onto which to store the result, or undefined if a new\n *                    instance should be created.\n * @returns {Ellipsoid} The cloned Ellipsoid.\n */\nEllipsoid.prototype.clone = function (result) {\n  return Ellipsoid.clone(this, result);\n};\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nEllipsoid.packedLength = Cartesian3.packedLength;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Ellipsoid} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nEllipsoid.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  Cartesian3.pack(value._radii, array, startingIndex);\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Ellipsoid} [result] The object into which to store the result.\n * @returns {Ellipsoid} The modified result parameter or a new Ellipsoid instance if one was not provided.\n */\nEllipsoid.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  var radii = Cartesian3.unpack(array, startingIndex);\n  return Ellipsoid.fromCartesian3(radii, result);\n};\n\n/**\n * Computes the unit vector directed from the center of this ellipsoid toward the provided Cartesian position.\n * @function\n *\n * @param {Cartesian3} cartesian The Cartesian for which to to determine the geocentric normal.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\n */\nEllipsoid.prototype.geocentricSurfaceNormal = Cartesian3.normalize;\n\n/**\n * Computes the normal of the plane tangent to the surface of the ellipsoid at the provided position.\n *\n * @param {Cartographic} cartographic The cartographic position for which to to determine the geodetic normal.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\n */\nEllipsoid.prototype.geodeticSurfaceNormalCartographic = function (\n  cartographic,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartographic\", cartographic);\n  //>>includeEnd('debug');\n\n  var longitude = cartographic.longitude;\n  var latitude = cartographic.latitude;\n  var cosLatitude = Math.cos(latitude);\n\n  var x = cosLatitude * Math.cos(longitude);\n  var y = cosLatitude * Math.sin(longitude);\n  var z = Math.sin(latitude);\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  return Cartesian3.normalize(result, result);\n};\n\n/**\n * Computes the normal of the plane tangent to the surface of the ellipsoid at the provided position.\n *\n * @param {Cartesian3} cartesian The Cartesian position for which to to determine the surface normal.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\n */\nEllipsoid.prototype.geodeticSurfaceNormal = function (cartesian, result) {\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  result = Cartesian3.multiplyComponents(\n    cartesian,\n    this._oneOverRadiiSquared,\n    result\n  );\n  return Cartesian3.normalize(result, result);\n};\n\nvar cartographicToCartesianNormal = new Cartesian3();\nvar cartographicToCartesianK = new Cartesian3();\n\n/**\n * Converts the provided cartographic to Cartesian representation.\n *\n * @param {Cartographic} cartographic The cartographic position.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\n *\n * @example\n * //Create a Cartographic and determine it's Cartesian representation on a WGS84 ellipsoid.\n * var position = new Cesium.Cartographic(Cesium.Math.toRadians(21), Cesium.Math.toRadians(78), 5000);\n * var cartesianPosition = Cesium.Ellipsoid.WGS84.cartographicToCartesian(position);\n */\nEllipsoid.prototype.cartographicToCartesian = function (cartographic, result) {\n  //`cartographic is required` is thrown from geodeticSurfaceNormalCartographic.\n  var n = cartographicToCartesianNormal;\n  var k = cartographicToCartesianK;\n  this.geodeticSurfaceNormalCartographic(cartographic, n);\n  Cartesian3.multiplyComponents(this._radiiSquared, n, k);\n  var gamma = Math.sqrt(Cartesian3.dot(n, k));\n  Cartesian3.divideByScalar(k, gamma, k);\n  Cartesian3.multiplyByScalar(n, cartographic.height, n);\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  return Cartesian3.add(k, n, result);\n};\n\n/**\n * Converts the provided array of cartographics to an array of Cartesians.\n *\n * @param {Cartographic[]} cartographics An array of cartographic positions.\n * @param {Cartesian3[]} [result] The object onto which to store the result.\n * @returns {Cartesian3[]} The modified result parameter or a new Array instance if none was provided.\n *\n * @example\n * //Convert an array of Cartographics and determine their Cartesian representation on a WGS84 ellipsoid.\n * var positions = [new Cesium.Cartographic(Cesium.Math.toRadians(21), Cesium.Math.toRadians(78), 0),\n *                  new Cesium.Cartographic(Cesium.Math.toRadians(21.321), Cesium.Math.toRadians(78.123), 100),\n *                  new Cesium.Cartographic(Cesium.Math.toRadians(21.645), Cesium.Math.toRadians(78.456), 250)];\n * var cartesianPositions = Cesium.Ellipsoid.WGS84.cartographicArrayToCartesianArray(positions);\n */\nEllipsoid.prototype.cartographicArrayToCartesianArray = function (\n  cartographics,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartographics\", cartographics);\n  //>>includeEnd('debug')\n\n  var length = cartographics.length;\n  if (!defined(result)) {\n    result = new Array(length);\n  } else {\n    result.length = length;\n  }\n  for (var i = 0; i < length; i++) {\n    result[i] = this.cartographicToCartesian(cartographics[i], result[i]);\n  }\n  return result;\n};\n\nvar cartesianToCartographicN = new Cartesian3();\nvar cartesianToCartographicP = new Cartesian3();\nvar cartesianToCartographicH = new Cartesian3();\n\n/**\n * Converts the provided cartesian to cartographic representation.\n * The cartesian is undefined at the center of the ellipsoid.\n *\n * @param {Cartesian3} cartesian The Cartesian position to convert to cartographic representation.\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter, new Cartographic instance if none was provided, or undefined if the cartesian is at the center of the ellipsoid.\n *\n * @example\n * //Create a Cartesian and determine it's Cartographic representation on a WGS84 ellipsoid.\n * var position = new Cesium.Cartesian3(17832.12, 83234.52, 952313.73);\n * var cartographicPosition = Cesium.Ellipsoid.WGS84.cartesianToCartographic(position);\n */\nEllipsoid.prototype.cartesianToCartographic = function (cartesian, result) {\n  //`cartesian is required.` is thrown from scaleToGeodeticSurface\n  var p = this.scaleToGeodeticSurface(cartesian, cartesianToCartographicP);\n\n  if (!defined(p)) {\n    return undefined;\n  }\n\n  var n = this.geodeticSurfaceNormal(p, cartesianToCartographicN);\n  var h = Cartesian3.subtract(cartesian, p, cartesianToCartographicH);\n\n  var longitude = Math.atan2(n.y, n.x);\n  var latitude = Math.asin(n.z);\n  var height =\n    CesiumMath.sign(Cartesian3.dot(h, cartesian)) * Cartesian3.magnitude(h);\n\n  if (!defined(result)) {\n    return new Cartographic(longitude, latitude, height);\n  }\n  result.longitude = longitude;\n  result.latitude = latitude;\n  result.height = height;\n  return result;\n};\n\n/**\n * Converts the provided array of cartesians to an array of cartographics.\n *\n * @param {Cartesian3[]} cartesians An array of Cartesian positions.\n * @param {Cartographic[]} [result] The object onto which to store the result.\n * @returns {Cartographic[]} The modified result parameter or a new Array instance if none was provided.\n *\n * @example\n * //Create an array of Cartesians and determine their Cartographic representation on a WGS84 ellipsoid.\n * var positions = [new Cesium.Cartesian3(17832.12, 83234.52, 952313.73),\n *                  new Cesium.Cartesian3(17832.13, 83234.53, 952313.73),\n *                  new Cesium.Cartesian3(17832.14, 83234.54, 952313.73)]\n * var cartographicPositions = Cesium.Ellipsoid.WGS84.cartesianArrayToCartographicArray(positions);\n */\nEllipsoid.prototype.cartesianArrayToCartographicArray = function (\n  cartesians,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesians\", cartesians);\n  //>>includeEnd('debug');\n\n  var length = cartesians.length;\n  if (!defined(result)) {\n    result = new Array(length);\n  } else {\n    result.length = length;\n  }\n  for (var i = 0; i < length; ++i) {\n    result[i] = this.cartesianToCartographic(cartesians[i], result[i]);\n  }\n  return result;\n};\n\n/**\n * Scales the provided Cartesian position along the geodetic surface normal\n * so that it is on the surface of this ellipsoid.  If the position is\n * at the center of the ellipsoid, this function returns undefined.\n *\n * @param {Cartesian3} cartesian The Cartesian position to scale.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter, a new Cartesian3 instance if none was provided, or undefined if the position is at the center.\n */\nEllipsoid.prototype.scaleToGeodeticSurface = function (cartesian, result) {\n  return scaleToGeodeticSurface(\n    cartesian,\n    this._oneOverRadii,\n    this._oneOverRadiiSquared,\n    this._centerToleranceSquared,\n    result\n  );\n};\n\n/**\n * Scales the provided Cartesian position along the geocentric surface normal\n * so that it is on the surface of this ellipsoid.\n *\n * @param {Cartesian3} cartesian The Cartesian position to scale.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\n */\nEllipsoid.prototype.scaleToGeocentricSurface = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  var positionX = cartesian.x;\n  var positionY = cartesian.y;\n  var positionZ = cartesian.z;\n  var oneOverRadiiSquared = this._oneOverRadiiSquared;\n\n  var beta =\n    1.0 /\n    Math.sqrt(\n      positionX * positionX * oneOverRadiiSquared.x +\n        positionY * positionY * oneOverRadiiSquared.y +\n        positionZ * positionZ * oneOverRadiiSquared.z\n    );\n\n  return Cartesian3.multiplyByScalar(cartesian, beta, result);\n};\n\n/**\n * Transforms a Cartesian X, Y, Z position to the ellipsoid-scaled space by multiplying\n * its components by the result of {@link Ellipsoid#oneOverRadii}.\n *\n * @param {Cartesian3} position The position to transform.\n * @param {Cartesian3} [result] The position to which to copy the result, or undefined to create and\n *        return a new instance.\n * @returns {Cartesian3} The position expressed in the scaled space.  The returned instance is the\n *          one passed as the result parameter if it is not undefined, or a new instance of it is.\n */\nEllipsoid.prototype.transformPositionToScaledSpace = function (\n  position,\n  result\n) {\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  return Cartesian3.multiplyComponents(position, this._oneOverRadii, result);\n};\n\n/**\n * Transforms a Cartesian X, Y, Z position from the ellipsoid-scaled space by multiplying\n * its components by the result of {@link Ellipsoid#radii}.\n *\n * @param {Cartesian3} position The position to transform.\n * @param {Cartesian3} [result] The position to which to copy the result, or undefined to create and\n *        return a new instance.\n * @returns {Cartesian3} The position expressed in the unscaled space.  The returned instance is the\n *          one passed as the result parameter if it is not undefined, or a new instance of it is.\n */\nEllipsoid.prototype.transformPositionFromScaledSpace = function (\n  position,\n  result\n) {\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  return Cartesian3.multiplyComponents(position, this._radii, result);\n};\n\n/**\n * Compares this Ellipsoid against the provided Ellipsoid componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Ellipsoid} [right] The other Ellipsoid.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nEllipsoid.prototype.equals = function (right) {\n  return (\n    this === right ||\n    (defined(right) && Cartesian3.equals(this._radii, right._radii))\n  );\n};\n\n/**\n * Creates a string representing this Ellipsoid in the format '(radii.x, radii.y, radii.z)'.\n *\n * @returns {String} A string representing this ellipsoid in the format '(radii.x, radii.y, radii.z)'.\n */\nEllipsoid.prototype.toString = function () {\n  return this._radii.toString();\n};\n\n/**\n * Computes a point which is the intersection of the surface normal with the z-axis.\n *\n * @param {Cartesian3} position the position. must be on the surface of the ellipsoid.\n * @param {Number} [buffer = 0.0] A buffer to subtract from the ellipsoid size when checking if the point is inside the ellipsoid.\n *                                In earth case, with common earth datums, there is no need for this buffer since the intersection point is always (relatively) very close to the center.\n *                                In WGS84 datum, intersection point is at max z = +-42841.31151331382 (0.673% of z-axis).\n *                                Intersection point could be outside the ellipsoid if the ratio of MajorAxis / AxisOfRotation is bigger than the square root of 2\n * @param {Cartesian3} [result] The cartesian to which to copy the result, or undefined to create and\n *        return a new instance.\n * @returns {Cartesian3 | undefined} the intersection point if it's inside the ellipsoid, undefined otherwise\n *\n * @exception {DeveloperError} position is required.\n * @exception {DeveloperError} Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y).\n * @exception {DeveloperError} Ellipsoid.radii.z must be greater than 0.\n */\nEllipsoid.prototype.getSurfaceNormalIntersectionWithZAxis = function (\n  position,\n  buffer,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"position\", position);\n\n  if (\n    !CesiumMath.equalsEpsilon(\n      this._radii.x,\n      this._radii.y,\n      CesiumMath.EPSILON15\n    )\n  ) {\n    throw new DeveloperError(\n      \"Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y)\"\n    );\n  }\n\n  Check.typeOf.number.greaterThan(\"Ellipsoid.radii.z\", this._radii.z, 0);\n  //>>includeEnd('debug');\n\n  buffer = defaultValue(buffer, 0.0);\n\n  var squaredXOverSquaredZ = this._squaredXOverSquaredZ;\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  result.x = 0.0;\n  result.y = 0.0;\n  result.z = position.z * (1 - squaredXOverSquaredZ);\n\n  if (Math.abs(result.z) >= this._radii.z - buffer) {\n    return undefined;\n  }\n\n  return result;\n};\nexport default Ellipsoid;\n","import Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport CesiumMath from \"./Math.js\";\n\n/**\n * A two dimensional region specified as longitude and latitude coordinates.\n *\n * @alias Rectangle\n * @constructor\n *\n * @param {Number} [west=0.0] The westernmost longitude, in radians, in the range [-Pi, Pi].\n * @param {Number} [south=0.0] The southernmost latitude, in radians, in the range [-Pi/2, Pi/2].\n * @param {Number} [east=0.0] The easternmost longitude, in radians, in the range [-Pi, Pi].\n * @param {Number} [north=0.0] The northernmost latitude, in radians, in the range [-Pi/2, Pi/2].\n *\n * @see Packable\n */\nfunction Rectangle(west, south, east, north) {\n  /**\n   * The westernmost longitude in radians in the range [-Pi, Pi].\n   *\n   * @type {Number}\n   * @default 0.0\n   */\n  this.west = defaultValue(west, 0.0);\n\n  /**\n   * The southernmost latitude in radians in the range [-Pi/2, Pi/2].\n   *\n   * @type {Number}\n   * @default 0.0\n   */\n  this.south = defaultValue(south, 0.0);\n\n  /**\n   * The easternmost longitude in radians in the range [-Pi, Pi].\n   *\n   * @type {Number}\n   * @default 0.0\n   */\n  this.east = defaultValue(east, 0.0);\n\n  /**\n   * The northernmost latitude in radians in the range [-Pi/2, Pi/2].\n   *\n   * @type {Number}\n   * @default 0.0\n   */\n  this.north = defaultValue(north, 0.0);\n}\n\nObject.defineProperties(Rectangle.prototype, {\n  /**\n   * Gets the width of the rectangle in radians.\n   * @memberof Rectangle.prototype\n   * @type {Number}\n   * @readonly\n   */\n  width: {\n    get: function () {\n      return Rectangle.computeWidth(this);\n    },\n  },\n\n  /**\n   * Gets the height of the rectangle in radians.\n   * @memberof Rectangle.prototype\n   * @type {Number}\n   * @readonly\n   */\n  height: {\n    get: function () {\n      return Rectangle.computeHeight(this);\n    },\n  },\n});\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nRectangle.packedLength = 4;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Rectangle} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nRectangle.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  array[startingIndex++] = value.west;\n  array[startingIndex++] = value.south;\n  array[startingIndex++] = value.east;\n  array[startingIndex] = value.north;\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Rectangle} [result] The object into which to store the result.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if one was not provided.\n */\nRectangle.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  if (!defined(result)) {\n    result = new Rectangle();\n  }\n\n  result.west = array[startingIndex++];\n  result.south = array[startingIndex++];\n  result.east = array[startingIndex++];\n  result.north = array[startingIndex];\n  return result;\n};\n\n/**\n * Computes the width of a rectangle in radians.\n * @param {Rectangle} rectangle The rectangle to compute the width of.\n * @returns {Number} The width.\n */\nRectangle.computeWidth = function (rectangle) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n  var east = rectangle.east;\n  var west = rectangle.west;\n  if (east < west) {\n    east += CesiumMath.TWO_PI;\n  }\n  return east - west;\n};\n\n/**\n * Computes the height of a rectangle in radians.\n * @param {Rectangle} rectangle The rectangle to compute the height of.\n * @returns {Number} The height.\n */\nRectangle.computeHeight = function (rectangle) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n  return rectangle.north - rectangle.south;\n};\n\n/**\n * Creates a rectangle given the boundary longitude and latitude in degrees.\n *\n * @param {Number} [west=0.0] The westernmost longitude in degrees in the range [-180.0, 180.0].\n * @param {Number} [south=0.0] The southernmost latitude in degrees in the range [-90.0, 90.0].\n * @param {Number} [east=0.0] The easternmost longitude in degrees in the range [-180.0, 180.0].\n * @param {Number} [north=0.0] The northernmost latitude in degrees in the range [-90.0, 90.0].\n * @param {Rectangle} [result] The object onto which to store the result, or undefined if a new instance should be created.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\n *\n * @example\n * var rectangle = Cesium.Rectangle.fromDegrees(0.0, 20.0, 10.0, 30.0);\n */\nRectangle.fromDegrees = function (west, south, east, north, result) {\n  west = CesiumMath.toRadians(defaultValue(west, 0.0));\n  south = CesiumMath.toRadians(defaultValue(south, 0.0));\n  east = CesiumMath.toRadians(defaultValue(east, 0.0));\n  north = CesiumMath.toRadians(defaultValue(north, 0.0));\n\n  if (!defined(result)) {\n    return new Rectangle(west, south, east, north);\n  }\n\n  result.west = west;\n  result.south = south;\n  result.east = east;\n  result.north = north;\n\n  return result;\n};\n\n/**\n * Creates a rectangle given the boundary longitude and latitude in radians.\n *\n * @param {Number} [west=0.0] The westernmost longitude in radians in the range [-Math.PI, Math.PI].\n * @param {Number} [south=0.0] The southernmost latitude in radians in the range [-Math.PI/2, Math.PI/2].\n * @param {Number} [east=0.0] The easternmost longitude in radians in the range [-Math.PI, Math.PI].\n * @param {Number} [north=0.0] The northernmost latitude in radians in the range [-Math.PI/2, Math.PI/2].\n * @param {Rectangle} [result] The object onto which to store the result, or undefined if a new instance should be created.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\n *\n * @example\n * var rectangle = Cesium.Rectangle.fromRadians(0.0, Math.PI/4, Math.PI/8, 3*Math.PI/4);\n */\nRectangle.fromRadians = function (west, south, east, north, result) {\n  if (!defined(result)) {\n    return new Rectangle(west, south, east, north);\n  }\n\n  result.west = defaultValue(west, 0.0);\n  result.south = defaultValue(south, 0.0);\n  result.east = defaultValue(east, 0.0);\n  result.north = defaultValue(north, 0.0);\n\n  return result;\n};\n\n/**\n * Creates the smallest possible Rectangle that encloses all positions in the provided array.\n *\n * @param {Cartographic[]} cartographics The list of Cartographic instances.\n * @param {Rectangle} [result] The object onto which to store the result, or undefined if a new instance should be created.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\n */\nRectangle.fromCartographicArray = function (cartographics, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartographics\", cartographics);\n  //>>includeEnd('debug');\n\n  var west = Number.MAX_VALUE;\n  var east = -Number.MAX_VALUE;\n  var westOverIDL = Number.MAX_VALUE;\n  var eastOverIDL = -Number.MAX_VALUE;\n  var south = Number.MAX_VALUE;\n  var north = -Number.MAX_VALUE;\n\n  for (var i = 0, len = cartographics.length; i < len; i++) {\n    var position = cartographics[i];\n    west = Math.min(west, position.longitude);\n    east = Math.max(east, position.longitude);\n    south = Math.min(south, position.latitude);\n    north = Math.max(north, position.latitude);\n\n    var lonAdjusted =\n      position.longitude >= 0\n        ? position.longitude\n        : position.longitude + CesiumMath.TWO_PI;\n    westOverIDL = Math.min(westOverIDL, lonAdjusted);\n    eastOverIDL = Math.max(eastOverIDL, lonAdjusted);\n  }\n\n  if (east - west > eastOverIDL - westOverIDL) {\n    west = westOverIDL;\n    east = eastOverIDL;\n\n    if (east > CesiumMath.PI) {\n      east = east - CesiumMath.TWO_PI;\n    }\n    if (west > CesiumMath.PI) {\n      west = west - CesiumMath.TWO_PI;\n    }\n  }\n\n  if (!defined(result)) {\n    return new Rectangle(west, south, east, north);\n  }\n\n  result.west = west;\n  result.south = south;\n  result.east = east;\n  result.north = north;\n  return result;\n};\n\n/**\n * Creates the smallest possible Rectangle that encloses all positions in the provided array.\n *\n * @param {Cartesian3[]} cartesians The list of Cartesian instances.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid the cartesians are on.\n * @param {Rectangle} [result] The object onto which to store the result, or undefined if a new instance should be created.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\n */\nRectangle.fromCartesianArray = function (cartesians, ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesians\", cartesians);\n  //>>includeEnd('debug');\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n\n  var west = Number.MAX_VALUE;\n  var east = -Number.MAX_VALUE;\n  var westOverIDL = Number.MAX_VALUE;\n  var eastOverIDL = -Number.MAX_VALUE;\n  var south = Number.MAX_VALUE;\n  var north = -Number.MAX_VALUE;\n\n  for (var i = 0, len = cartesians.length; i < len; i++) {\n    var position = ellipsoid.cartesianToCartographic(cartesians[i]);\n    west = Math.min(west, position.longitude);\n    east = Math.max(east, position.longitude);\n    south = Math.min(south, position.latitude);\n    north = Math.max(north, position.latitude);\n\n    var lonAdjusted =\n      position.longitude >= 0\n        ? position.longitude\n        : position.longitude + CesiumMath.TWO_PI;\n    westOverIDL = Math.min(westOverIDL, lonAdjusted);\n    eastOverIDL = Math.max(eastOverIDL, lonAdjusted);\n  }\n\n  if (east - west > eastOverIDL - westOverIDL) {\n    west = westOverIDL;\n    east = eastOverIDL;\n\n    if (east > CesiumMath.PI) {\n      east = east - CesiumMath.TWO_PI;\n    }\n    if (west > CesiumMath.PI) {\n      west = west - CesiumMath.TWO_PI;\n    }\n  }\n\n  if (!defined(result)) {\n    return new Rectangle(west, south, east, north);\n  }\n\n  result.west = west;\n  result.south = south;\n  result.east = east;\n  result.north = north;\n  return result;\n};\n\n/**\n * Duplicates a Rectangle.\n *\n * @param {Rectangle} rectangle The rectangle to clone.\n * @param {Rectangle} [result] The object onto which to store the result, or undefined if a new instance should be created.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided. (Returns undefined if rectangle is undefined)\n */\nRectangle.clone = function (rectangle, result) {\n  if (!defined(rectangle)) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    return new Rectangle(\n      rectangle.west,\n      rectangle.south,\n      rectangle.east,\n      rectangle.north\n    );\n  }\n\n  result.west = rectangle.west;\n  result.south = rectangle.south;\n  result.east = rectangle.east;\n  result.north = rectangle.north;\n  return result;\n};\n\n/**\n * Compares the provided Rectangles componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {Rectangle} [left] The first Rectangle.\n * @param {Rectangle} [right] The second Rectangle.\n * @param {Number} [absoluteEpsilon=0] The absolute epsilon tolerance to use for equality testing.\n * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\nRectangle.equalsEpsilon = function (left, right, absoluteEpsilon) {\n  absoluteEpsilon = defaultValue(absoluteEpsilon, 0);\n\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      Math.abs(left.west - right.west) <= absoluteEpsilon &&\n      Math.abs(left.south - right.south) <= absoluteEpsilon &&\n      Math.abs(left.east - right.east) <= absoluteEpsilon &&\n      Math.abs(left.north - right.north) <= absoluteEpsilon)\n  );\n};\n\n/**\n * Duplicates this Rectangle.\n *\n * @param {Rectangle} [result] The object onto which to store the result.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\n */\nRectangle.prototype.clone = function (result) {\n  return Rectangle.clone(this, result);\n};\n\n/**\n * Compares the provided Rectangle with this Rectangle componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Rectangle} [other] The Rectangle to compare.\n * @returns {Boolean} <code>true</code> if the Rectangles are equal, <code>false</code> otherwise.\n */\nRectangle.prototype.equals = function (other) {\n  return Rectangle.equals(this, other);\n};\n\n/**\n * Compares the provided rectangles and returns <code>true</code> if they are equal,\n * <code>false</code> otherwise.\n *\n * @param {Rectangle} [left] The first Rectangle.\n * @param {Rectangle} [right] The second Rectangle.\n * @returns {Boolean} <code>true</code> if left and right are equal; otherwise <code>false</code>.\n */\nRectangle.equals = function (left, right) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      left.west === right.west &&\n      left.south === right.south &&\n      left.east === right.east &&\n      left.north === right.north)\n  );\n};\n\n/**\n * Compares the provided Rectangle with this Rectangle componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {Rectangle} [other] The Rectangle to compare.\n * @param {Number} [epsilon=0] The epsilon to use for equality testing.\n * @returns {Boolean} <code>true</code> if the Rectangles are within the provided epsilon, <code>false</code> otherwise.\n */\nRectangle.prototype.equalsEpsilon = function (other, epsilon) {\n  return Rectangle.equalsEpsilon(this, other, epsilon);\n};\n\n/**\n * Checks a Rectangle's properties and throws if they are not in valid ranges.\n *\n * @param {Rectangle} rectangle The rectangle to validate\n *\n * @exception {DeveloperError} <code>north</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].\n * @exception {DeveloperError} <code>south</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].\n * @exception {DeveloperError} <code>east</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].\n * @exception {DeveloperError} <code>west</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].\n */\nRectangle.validate = function (rectangle) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n\n  var north = rectangle.north;\n  Check.typeOf.number.greaterThanOrEquals(\n    \"north\",\n    north,\n    -CesiumMath.PI_OVER_TWO\n  );\n  Check.typeOf.number.lessThanOrEquals(\"north\", north, CesiumMath.PI_OVER_TWO);\n\n  var south = rectangle.south;\n  Check.typeOf.number.greaterThanOrEquals(\n    \"south\",\n    south,\n    -CesiumMath.PI_OVER_TWO\n  );\n  Check.typeOf.number.lessThanOrEquals(\"south\", south, CesiumMath.PI_OVER_TWO);\n\n  var west = rectangle.west;\n  Check.typeOf.number.greaterThanOrEquals(\"west\", west, -Math.PI);\n  Check.typeOf.number.lessThanOrEquals(\"west\", west, Math.PI);\n\n  var east = rectangle.east;\n  Check.typeOf.number.greaterThanOrEquals(\"east\", east, -Math.PI);\n  Check.typeOf.number.lessThanOrEquals(\"east\", east, Math.PI);\n  //>>includeEnd('debug');\n};\n\n/**\n * Computes the southwest corner of a rectangle.\n *\n * @param {Rectangle} rectangle The rectangle for which to find the corner\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.\n */\nRectangle.southwest = function (rectangle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Cartographic(rectangle.west, rectangle.south);\n  }\n  result.longitude = rectangle.west;\n  result.latitude = rectangle.south;\n  result.height = 0.0;\n  return result;\n};\n\n/**\n * Computes the northwest corner of a rectangle.\n *\n * @param {Rectangle} rectangle The rectangle for which to find the corner\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.\n */\nRectangle.northwest = function (rectangle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Cartographic(rectangle.west, rectangle.north);\n  }\n  result.longitude = rectangle.west;\n  result.latitude = rectangle.north;\n  result.height = 0.0;\n  return result;\n};\n\n/**\n * Computes the northeast corner of a rectangle.\n *\n * @param {Rectangle} rectangle The rectangle for which to find the corner\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.\n */\nRectangle.northeast = function (rectangle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Cartographic(rectangle.east, rectangle.north);\n  }\n  result.longitude = rectangle.east;\n  result.latitude = rectangle.north;\n  result.height = 0.0;\n  return result;\n};\n\n/**\n * Computes the southeast corner of a rectangle.\n *\n * @param {Rectangle} rectangle The rectangle for which to find the corner\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.\n */\nRectangle.southeast = function (rectangle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Cartographic(rectangle.east, rectangle.south);\n  }\n  result.longitude = rectangle.east;\n  result.latitude = rectangle.south;\n  result.height = 0.0;\n  return result;\n};\n\n/**\n * Computes the center of a rectangle.\n *\n * @param {Rectangle} rectangle The rectangle for which to find the center\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.\n */\nRectangle.center = function (rectangle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n\n  var east = rectangle.east;\n  var west = rectangle.west;\n\n  if (east < west) {\n    east += CesiumMath.TWO_PI;\n  }\n\n  var longitude = CesiumMath.negativePiToPi((west + east) * 0.5);\n  var latitude = (rectangle.south + rectangle.north) * 0.5;\n\n  if (!defined(result)) {\n    return new Cartographic(longitude, latitude);\n  }\n\n  result.longitude = longitude;\n  result.latitude = latitude;\n  result.height = 0.0;\n  return result;\n};\n\n/**\n * Computes the intersection of two rectangles.  This function assumes that the rectangle's coordinates are\n * latitude and longitude in radians and produces a correct intersection, taking into account the fact that\n * the same angle can be represented with multiple values as well as the wrapping of longitude at the\n * anti-meridian.  For a simple intersection that ignores these factors and can be used with projected\n * coordinates, see {@link Rectangle.simpleIntersection}.\n *\n * @param {Rectangle} rectangle On rectangle to find an intersection\n * @param {Rectangle} otherRectangle Another rectangle to find an intersection\n * @param {Rectangle} [result] The object onto which to store the result.\n * @returns {Rectangle|undefined} The modified result parameter, a new Rectangle instance if none was provided or undefined if there is no intersection.\n */\nRectangle.intersection = function (rectangle, otherRectangle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  Check.typeOf.object(\"otherRectangle\", otherRectangle);\n  //>>includeEnd('debug');\n\n  var rectangleEast = rectangle.east;\n  var rectangleWest = rectangle.west;\n\n  var otherRectangleEast = otherRectangle.east;\n  var otherRectangleWest = otherRectangle.west;\n\n  if (rectangleEast < rectangleWest && otherRectangleEast > 0.0) {\n    rectangleEast += CesiumMath.TWO_PI;\n  } else if (otherRectangleEast < otherRectangleWest && rectangleEast > 0.0) {\n    otherRectangleEast += CesiumMath.TWO_PI;\n  }\n\n  if (rectangleEast < rectangleWest && otherRectangleWest < 0.0) {\n    otherRectangleWest += CesiumMath.TWO_PI;\n  } else if (otherRectangleEast < otherRectangleWest && rectangleWest < 0.0) {\n    rectangleWest += CesiumMath.TWO_PI;\n  }\n\n  var west = CesiumMath.negativePiToPi(\n    Math.max(rectangleWest, otherRectangleWest)\n  );\n  var east = CesiumMath.negativePiToPi(\n    Math.min(rectangleEast, otherRectangleEast)\n  );\n\n  if (\n    (rectangle.west < rectangle.east ||\n      otherRectangle.west < otherRectangle.east) &&\n    east <= west\n  ) {\n    return undefined;\n  }\n\n  var south = Math.max(rectangle.south, otherRectangle.south);\n  var north = Math.min(rectangle.north, otherRectangle.north);\n\n  if (south >= north) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    return new Rectangle(west, south, east, north);\n  }\n  result.west = west;\n  result.south = south;\n  result.east = east;\n  result.north = north;\n  return result;\n};\n\n/**\n * Computes a simple intersection of two rectangles.  Unlike {@link Rectangle.intersection}, this function\n * does not attempt to put the angular coordinates into a consistent range or to account for crossing the\n * anti-meridian.  As such, it can be used for rectangles where the coordinates are not simply latitude\n * and longitude (i.e. projected coordinates).\n *\n * @param {Rectangle} rectangle On rectangle to find an intersection\n * @param {Rectangle} otherRectangle Another rectangle to find an intersection\n * @param {Rectangle} [result] The object onto which to store the result.\n * @returns {Rectangle|undefined} The modified result parameter, a new Rectangle instance if none was provided or undefined if there is no intersection.\n */\nRectangle.simpleIntersection = function (rectangle, otherRectangle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  Check.typeOf.object(\"otherRectangle\", otherRectangle);\n  //>>includeEnd('debug');\n\n  var west = Math.max(rectangle.west, otherRectangle.west);\n  var south = Math.max(rectangle.south, otherRectangle.south);\n  var east = Math.min(rectangle.east, otherRectangle.east);\n  var north = Math.min(rectangle.north, otherRectangle.north);\n\n  if (south >= north || west >= east) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    return new Rectangle(west, south, east, north);\n  }\n\n  result.west = west;\n  result.south = south;\n  result.east = east;\n  result.north = north;\n  return result;\n};\n\n/**\n * Computes a rectangle that is the union of two rectangles.\n *\n * @param {Rectangle} rectangle A rectangle to enclose in rectangle.\n * @param {Rectangle} otherRectangle A rectangle to enclose in a rectangle.\n * @param {Rectangle} [result] The object onto which to store the result.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\n */\nRectangle.union = function (rectangle, otherRectangle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  Check.typeOf.object(\"otherRectangle\", otherRectangle);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Rectangle();\n  }\n\n  var rectangleEast = rectangle.east;\n  var rectangleWest = rectangle.west;\n\n  var otherRectangleEast = otherRectangle.east;\n  var otherRectangleWest = otherRectangle.west;\n\n  if (rectangleEast < rectangleWest && otherRectangleEast > 0.0) {\n    rectangleEast += CesiumMath.TWO_PI;\n  } else if (otherRectangleEast < otherRectangleWest && rectangleEast > 0.0) {\n    otherRectangleEast += CesiumMath.TWO_PI;\n  }\n\n  if (rectangleEast < rectangleWest && otherRectangleWest < 0.0) {\n    otherRectangleWest += CesiumMath.TWO_PI;\n  } else if (otherRectangleEast < otherRectangleWest && rectangleWest < 0.0) {\n    rectangleWest += CesiumMath.TWO_PI;\n  }\n\n  var west = CesiumMath.convertLongitudeRange(\n    Math.min(rectangleWest, otherRectangleWest)\n  );\n  var east = CesiumMath.convertLongitudeRange(\n    Math.max(rectangleEast, otherRectangleEast)\n  );\n\n  result.west = west;\n  result.south = Math.min(rectangle.south, otherRectangle.south);\n  result.east = east;\n  result.north = Math.max(rectangle.north, otherRectangle.north);\n\n  return result;\n};\n\n/**\n * Computes a rectangle by enlarging the provided rectangle until it contains the provided cartographic.\n *\n * @param {Rectangle} rectangle A rectangle to expand.\n * @param {Cartographic} cartographic A cartographic to enclose in a rectangle.\n * @param {Rectangle} [result] The object onto which to store the result.\n * @returns {Rectangle} The modified result parameter or a new Rectangle instance if one was not provided.\n */\nRectangle.expand = function (rectangle, cartographic, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  Check.typeOf.object(\"cartographic\", cartographic);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Rectangle();\n  }\n\n  result.west = Math.min(rectangle.west, cartographic.longitude);\n  result.south = Math.min(rectangle.south, cartographic.latitude);\n  result.east = Math.max(rectangle.east, cartographic.longitude);\n  result.north = Math.max(rectangle.north, cartographic.latitude);\n\n  return result;\n};\n\n/**\n * Returns true if the cartographic is on or inside the rectangle, false otherwise.\n *\n * @param {Rectangle} rectangle The rectangle\n * @param {Cartographic} cartographic The cartographic to test.\n * @returns {Boolean} true if the provided cartographic is inside the rectangle, false otherwise.\n */\nRectangle.contains = function (rectangle, cartographic) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  Check.typeOf.object(\"cartographic\", cartographic);\n  //>>includeEnd('debug');\n\n  var longitude = cartographic.longitude;\n  var latitude = cartographic.latitude;\n\n  var west = rectangle.west;\n  var east = rectangle.east;\n\n  if (east < west) {\n    east += CesiumMath.TWO_PI;\n    if (longitude < 0.0) {\n      longitude += CesiumMath.TWO_PI;\n    }\n  }\n  return (\n    (longitude > west ||\n      CesiumMath.equalsEpsilon(longitude, west, CesiumMath.EPSILON14)) &&\n    (longitude < east ||\n      CesiumMath.equalsEpsilon(longitude, east, CesiumMath.EPSILON14)) &&\n    latitude >= rectangle.south &&\n    latitude <= rectangle.north\n  );\n};\n\nvar subsampleLlaScratch = new Cartographic();\n/**\n * Samples a rectangle so that it includes a list of Cartesian points suitable for passing to\n * {@link BoundingSphere#fromPoints}.  Sampling is necessary to account\n * for rectangles that cover the poles or cross the equator.\n *\n * @param {Rectangle} rectangle The rectangle to subsample.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid to use.\n * @param {Number} [surfaceHeight=0.0] The height of the rectangle above the ellipsoid.\n * @param {Cartesian3[]} [result] The array of Cartesians onto which to store the result.\n * @returns {Cartesian3[]} The modified result parameter or a new Array of Cartesians instances if none was provided.\n */\nRectangle.subsample = function (rectangle, ellipsoid, surfaceHeight, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n  surfaceHeight = defaultValue(surfaceHeight, 0.0);\n\n  if (!defined(result)) {\n    result = [];\n  }\n  var length = 0;\n\n  var north = rectangle.north;\n  var south = rectangle.south;\n  var east = rectangle.east;\n  var west = rectangle.west;\n\n  var lla = subsampleLlaScratch;\n  lla.height = surfaceHeight;\n\n  lla.longitude = west;\n  lla.latitude = north;\n  result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\n  length++;\n\n  lla.longitude = east;\n  result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\n  length++;\n\n  lla.latitude = south;\n  result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\n  length++;\n\n  lla.longitude = west;\n  result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\n  length++;\n\n  if (north < 0.0) {\n    lla.latitude = north;\n  } else if (south > 0.0) {\n    lla.latitude = south;\n  } else {\n    lla.latitude = 0.0;\n  }\n\n  for (var i = 1; i < 8; ++i) {\n    lla.longitude = -Math.PI + i * CesiumMath.PI_OVER_TWO;\n    if (Rectangle.contains(rectangle, lla)) {\n      result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\n      length++;\n    }\n  }\n\n  if (lla.latitude === 0.0) {\n    lla.longitude = west;\n    result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\n    length++;\n    lla.longitude = east;\n    result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\n    length++;\n  }\n  result.length = length;\n  return result;\n};\n\n/**\n * The largest possible rectangle.\n *\n * @type {Rectangle}\n * @constant\n */\nRectangle.MAX_VALUE = Object.freeze(\n  new Rectangle(\n    -Math.PI,\n    -CesiumMath.PI_OVER_TWO,\n    Math.PI,\n    CesiumMath.PI_OVER_TWO\n  )\n);\nexport default Rectangle;\n","import Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\n\n/**\n * A 2D Cartesian point.\n * @alias Cartesian2\n * @constructor\n *\n * @param {Number} [x=0.0] The X component.\n * @param {Number} [y=0.0] The Y component.\n *\n * @see Cartesian3\n * @see Cartesian4\n * @see Packable\n */\nfunction Cartesian2(x, y) {\n  /**\n   * The X component.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.x = defaultValue(x, 0.0);\n\n  /**\n   * The Y component.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.y = defaultValue(y, 0.0);\n}\n\n/**\n * Creates a Cartesian2 instance from x and y coordinates.\n *\n * @param {Number} x The x coordinate.\n * @param {Number} y The y coordinate.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\n */\nCartesian2.fromElements = function (x, y, result) {\n  if (!defined(result)) {\n    return new Cartesian2(x, y);\n  }\n\n  result.x = x;\n  result.y = y;\n  return result;\n};\n\n/**\n * Duplicates a Cartesian2 instance.\n *\n * @param {Cartesian2} cartesian The Cartesian to duplicate.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided. (Returns undefined if cartesian is undefined)\n */\nCartesian2.clone = function (cartesian, result) {\n  if (!defined(cartesian)) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    return new Cartesian2(cartesian.x, cartesian.y);\n  }\n\n  result.x = cartesian.x;\n  result.y = cartesian.y;\n  return result;\n};\n\n/**\n * Creates a Cartesian2 instance from an existing Cartesian3.  This simply takes the\n * x and y properties of the Cartesian3 and drops z.\n * @function\n *\n * @param {Cartesian3} cartesian The Cartesian3 instance to create a Cartesian2 instance from.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\n */\nCartesian2.fromCartesian3 = Cartesian2.clone;\n\n/**\n * Creates a Cartesian2 instance from an existing Cartesian4.  This simply takes the\n * x and y properties of the Cartesian4 and drops z and w.\n * @function\n *\n * @param {Cartesian4} cartesian The Cartesian4 instance to create a Cartesian2 instance from.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\n */\nCartesian2.fromCartesian4 = Cartesian2.clone;\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nCartesian2.packedLength = 2;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Cartesian2} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nCartesian2.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  array[startingIndex++] = value.x;\n  array[startingIndex] = value.y;\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Cartesian2} [result] The object into which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\n */\nCartesian2.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  if (!defined(result)) {\n    result = new Cartesian2();\n  }\n  result.x = array[startingIndex++];\n  result.y = array[startingIndex];\n  return result;\n};\n\n/**\n     * Flattens an array of Cartesian2s into and array of components.\n     *\n     * @param {Cartesian2[]} array The array of cartesians to pack.\n     * @param {Number[]} [result] The array onto which to store the result. If this is a typed array, it must have array.length * 2 components, else a {@link DeveloperError} will be thrown. If it is a regular array, it will be resized to have (array.length * 2) elements.\n\n     * @returns {Number[]} The packed array.\n     */\nCartesian2.packArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  var length = array.length;\n  var resultLength = length * 2;\n  if (!defined(result)) {\n    result = new Array(resultLength);\n  } else if (!Array.isArray(result) && result.length !== resultLength) {\n    throw new DeveloperError(\n      \"If result is a typed array, it must have exactly array.length * 2 elements\"\n    );\n  } else if (result.length !== resultLength) {\n    result.length = resultLength;\n  }\n\n  for (var i = 0; i < length; ++i) {\n    Cartesian2.pack(array[i], result, i * 2);\n  }\n  return result;\n};\n\n/**\n * Unpacks an array of cartesian components into and array of Cartesian2s.\n *\n * @param {Number[]} array The array of components to unpack.\n * @param {Cartesian2[]} [result] The array onto which to store the result.\n * @returns {Cartesian2[]} The unpacked array.\n */\nCartesian2.unpackArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  Check.typeOf.number.greaterThanOrEquals(\"array.length\", array.length, 2);\n  if (array.length % 2 !== 0) {\n    throw new DeveloperError(\"array length must be a multiple of 2.\");\n  }\n  //>>includeEnd('debug');\n\n  var length = array.length;\n  if (!defined(result)) {\n    result = new Array(length / 2);\n  } else {\n    result.length = length / 2;\n  }\n\n  for (var i = 0; i < length; i += 2) {\n    var index = i / 2;\n    result[index] = Cartesian2.unpack(array, i, result[index]);\n  }\n  return result;\n};\n\n/**\n * Creates a Cartesian2 from two consecutive elements in an array.\n * @function\n *\n * @param {Number[]} array The array whose two consecutive elements correspond to the x and y components, respectively.\n * @param {Number} [startingIndex=0] The offset into the array of the first element, which corresponds to the x component.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\n *\n * @example\n * // Create a Cartesian2 with (1.0, 2.0)\n * var v = [1.0, 2.0];\n * var p = Cesium.Cartesian2.fromArray(v);\n *\n * // Create a Cartesian2 with (1.0, 2.0) using an offset into an array\n * var v2 = [0.0, 0.0, 1.0, 2.0];\n * var p2 = Cesium.Cartesian2.fromArray(v2, 2);\n */\nCartesian2.fromArray = Cartesian2.unpack;\n\n/**\n * Computes the value of the maximum component for the supplied Cartesian.\n *\n * @param {Cartesian2} cartesian The cartesian to use.\n * @returns {Number} The value of the maximum component.\n */\nCartesian2.maximumComponent = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  return Math.max(cartesian.x, cartesian.y);\n};\n\n/**\n * Computes the value of the minimum component for the supplied Cartesian.\n *\n * @param {Cartesian2} cartesian The cartesian to use.\n * @returns {Number} The value of the minimum component.\n */\nCartesian2.minimumComponent = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  return Math.min(cartesian.x, cartesian.y);\n};\n\n/**\n * Compares two Cartesians and computes a Cartesian which contains the minimum components of the supplied Cartesians.\n *\n * @param {Cartesian2} first A cartesian to compare.\n * @param {Cartesian2} second A cartesian to compare.\n * @param {Cartesian2} result The object into which to store the result.\n * @returns {Cartesian2} A cartesian with the minimum components.\n */\nCartesian2.minimumByComponent = function (first, second, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"first\", first);\n  Check.typeOf.object(\"second\", second);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Math.min(first.x, second.x);\n  result.y = Math.min(first.y, second.y);\n\n  return result;\n};\n\n/**\n * Compares two Cartesians and computes a Cartesian which contains the maximum components of the supplied Cartesians.\n *\n * @param {Cartesian2} first A cartesian to compare.\n * @param {Cartesian2} second A cartesian to compare.\n * @param {Cartesian2} result The object into which to store the result.\n * @returns {Cartesian2} A cartesian with the maximum components.\n */\nCartesian2.maximumByComponent = function (first, second, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"first\", first);\n  Check.typeOf.object(\"second\", second);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Math.max(first.x, second.x);\n  result.y = Math.max(first.y, second.y);\n  return result;\n};\n\n/**\n * Computes the provided Cartesian's squared magnitude.\n *\n * @param {Cartesian2} cartesian The Cartesian instance whose squared magnitude is to be computed.\n * @returns {Number} The squared magnitude.\n */\nCartesian2.magnitudeSquared = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  return cartesian.x * cartesian.x + cartesian.y * cartesian.y;\n};\n\n/**\n * Computes the Cartesian's magnitude (length).\n *\n * @param {Cartesian2} cartesian The Cartesian instance whose magnitude is to be computed.\n * @returns {Number} The magnitude.\n */\nCartesian2.magnitude = function (cartesian) {\n  return Math.sqrt(Cartesian2.magnitudeSquared(cartesian));\n};\n\nvar distanceScratch = new Cartesian2();\n\n/**\n * Computes the distance between two points.\n *\n * @param {Cartesian2} left The first point to compute the distance from.\n * @param {Cartesian2} right The second point to compute the distance to.\n * @returns {Number} The distance between two points.\n *\n * @example\n * // Returns 1.0\n * var d = Cesium.Cartesian2.distance(new Cesium.Cartesian2(1.0, 0.0), new Cesium.Cartesian2(2.0, 0.0));\n */\nCartesian2.distance = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  Cartesian2.subtract(left, right, distanceScratch);\n  return Cartesian2.magnitude(distanceScratch);\n};\n\n/**\n * Computes the squared distance between two points.  Comparing squared distances\n * using this function is more efficient than comparing distances using {@link Cartesian2#distance}.\n *\n * @param {Cartesian2} left The first point to compute the distance from.\n * @param {Cartesian2} right The second point to compute the distance to.\n * @returns {Number} The distance between two points.\n *\n * @example\n * // Returns 4.0, not 2.0\n * var d = Cesium.Cartesian2.distance(new Cesium.Cartesian2(1.0, 0.0), new Cesium.Cartesian2(3.0, 0.0));\n */\nCartesian2.distanceSquared = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  Cartesian2.subtract(left, right, distanceScratch);\n  return Cartesian2.magnitudeSquared(distanceScratch);\n};\n\n/**\n * Computes the normalized form of the supplied Cartesian.\n *\n * @param {Cartesian2} cartesian The Cartesian to be normalized.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.normalize = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var magnitude = Cartesian2.magnitude(cartesian);\n\n  result.x = cartesian.x / magnitude;\n  result.y = cartesian.y / magnitude;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (isNaN(result.x) || isNaN(result.y)) {\n    throw new DeveloperError(\"normalized result is not a number\");\n  }\n  //>>includeEnd('debug');\n\n  return result;\n};\n\n/**\n * Computes the dot (scalar) product of two Cartesians.\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @returns {Number} The dot product.\n */\nCartesian2.dot = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  return left.x * right.x + left.y * right.y;\n};\n\n/**\n * Computes the componentwise product of two Cartesians.\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.multiplyComponents = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x * right.x;\n  result.y = left.y * right.y;\n  return result;\n};\n\n/**\n * Computes the componentwise quotient of two Cartesians.\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.divideComponents = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x / right.x;\n  result.y = left.y / right.y;\n  return result;\n};\n\n/**\n * Computes the componentwise sum of two Cartesians.\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.add = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x + right.x;\n  result.y = left.y + right.y;\n  return result;\n};\n\n/**\n * Computes the componentwise difference of two Cartesians.\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.subtract = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x - right.x;\n  result.y = left.y - right.y;\n  return result;\n};\n\n/**\n * Multiplies the provided Cartesian componentwise by the provided scalar.\n *\n * @param {Cartesian2} cartesian The Cartesian to be scaled.\n * @param {Number} scalar The scalar to multiply with.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.multiplyByScalar = function (cartesian, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = cartesian.x * scalar;\n  result.y = cartesian.y * scalar;\n  return result;\n};\n\n/**\n * Divides the provided Cartesian componentwise by the provided scalar.\n *\n * @param {Cartesian2} cartesian The Cartesian to be divided.\n * @param {Number} scalar The scalar to divide by.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.divideByScalar = function (cartesian, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = cartesian.x / scalar;\n  result.y = cartesian.y / scalar;\n  return result;\n};\n\n/**\n * Negates the provided Cartesian.\n *\n * @param {Cartesian2} cartesian The Cartesian to be negated.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.negate = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = -cartesian.x;\n  result.y = -cartesian.y;\n  return result;\n};\n\n/**\n * Computes the absolute value of the provided Cartesian.\n *\n * @param {Cartesian2} cartesian The Cartesian whose absolute value is to be computed.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.abs = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Math.abs(cartesian.x);\n  result.y = Math.abs(cartesian.y);\n  return result;\n};\n\nvar lerpScratch = new Cartesian2();\n/**\n * Computes the linear interpolation or extrapolation at t using the provided cartesians.\n *\n * @param {Cartesian2} start The value corresponding to t at 0.0.\n * @param {Cartesian2} end The value corresponding to t at 1.0.\n * @param {Number} t The point along t at which to interpolate.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.lerp = function (start, end, t, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"start\", start);\n  Check.typeOf.object(\"end\", end);\n  Check.typeOf.number(\"t\", t);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  Cartesian2.multiplyByScalar(end, t, lerpScratch);\n  result = Cartesian2.multiplyByScalar(start, 1.0 - t, result);\n  return Cartesian2.add(lerpScratch, result, result);\n};\n\nvar angleBetweenScratch = new Cartesian2();\nvar angleBetweenScratch2 = new Cartesian2();\n/**\n * Returns the angle, in radians, between the provided Cartesians.\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @returns {Number} The angle between the Cartesians.\n */\nCartesian2.angleBetween = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  Cartesian2.normalize(left, angleBetweenScratch);\n  Cartesian2.normalize(right, angleBetweenScratch2);\n  return CesiumMath.acosClamped(\n    Cartesian2.dot(angleBetweenScratch, angleBetweenScratch2)\n  );\n};\n\nvar mostOrthogonalAxisScratch = new Cartesian2();\n/**\n * Returns the axis that is most orthogonal to the provided Cartesian.\n *\n * @param {Cartesian2} cartesian The Cartesian on which to find the most orthogonal axis.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The most orthogonal axis.\n */\nCartesian2.mostOrthogonalAxis = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var f = Cartesian2.normalize(cartesian, mostOrthogonalAxisScratch);\n  Cartesian2.abs(f, f);\n\n  if (f.x <= f.y) {\n    result = Cartesian2.clone(Cartesian2.UNIT_X, result);\n  } else {\n    result = Cartesian2.clone(Cartesian2.UNIT_Y, result);\n  }\n\n  return result;\n};\n\n/**\n * Compares the provided Cartesians componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartesian2} [left] The first Cartesian.\n * @param {Cartesian2} [right] The second Cartesian.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nCartesian2.equals = function (left, right) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      left.x === right.x &&\n      left.y === right.y)\n  );\n};\n\n/**\n * @private\n */\nCartesian2.equalsArray = function (cartesian, array, offset) {\n  return cartesian.x === array[offset] && cartesian.y === array[offset + 1];\n};\n\n/**\n * Compares the provided Cartesians componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {Cartesian2} [left] The first Cartesian.\n * @param {Cartesian2} [right] The second Cartesian.\n * @param {Number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\nCartesian2.equalsEpsilon = function (\n  left,\n  right,\n  relativeEpsilon,\n  absoluteEpsilon\n) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      CesiumMath.equalsEpsilon(\n        left.x,\n        right.x,\n        relativeEpsilon,\n        absoluteEpsilon\n      ) &&\n      CesiumMath.equalsEpsilon(\n        left.y,\n        right.y,\n        relativeEpsilon,\n        absoluteEpsilon\n      ))\n  );\n};\n\n/**\n * An immutable Cartesian2 instance initialized to (0.0, 0.0).\n *\n * @type {Cartesian2}\n * @constant\n */\nCartesian2.ZERO = Object.freeze(new Cartesian2(0.0, 0.0));\n\n/**\n * An immutable Cartesian2 instance initialized to (1.0, 0.0).\n *\n * @type {Cartesian2}\n * @constant\n */\nCartesian2.UNIT_X = Object.freeze(new Cartesian2(1.0, 0.0));\n\n/**\n * An immutable Cartesian2 instance initialized to (0.0, 1.0).\n *\n * @type {Cartesian2}\n * @constant\n */\nCartesian2.UNIT_Y = Object.freeze(new Cartesian2(0.0, 1.0));\n\n/**\n * Duplicates this Cartesian2 instance.\n *\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\n */\nCartesian2.prototype.clone = function (result) {\n  return Cartesian2.clone(this, result);\n};\n\n/**\n * Compares this Cartesian against the provided Cartesian componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartesian2} [right] The right hand side Cartesian.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nCartesian2.prototype.equals = function (right) {\n  return Cartesian2.equals(this, right);\n};\n\n/**\n * Compares this Cartesian against the provided Cartesian componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {Cartesian2} [right] The right hand side Cartesian.\n * @param {Number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.\n */\nCartesian2.prototype.equalsEpsilon = function (\n  right,\n  relativeEpsilon,\n  absoluteEpsilon\n) {\n  return Cartesian2.equalsEpsilon(\n    this,\n    right,\n    relativeEpsilon,\n    absoluteEpsilon\n  );\n};\n\n/**\n * Creates a string representing this Cartesian in the format '(x, y)'.\n *\n * @returns {String} A string representing the provided Cartesian in the format '(x, y)'.\n */\nCartesian2.prototype.toString = function () {\n  return \"(\" + this.x + \", \" + this.y + \")\";\n};\nexport default Cartesian2;\n"],"names":["Cartesian3","x","y","z","this","defaultValue","fromSpherical","spherical","result","Check","typeOf","object","defined","clock","cone","magnitude","radial","Math","sin","cos","fromElements","fromCartesian4","clone","cartesian","packedLength","pack","value","array","startingIndex","unpack","packArray","length","resultLength","Array","isArray","DeveloperError","i","unpackArray","number","greaterThanOrEquals","index","fromArray","maximumComponent","max","minimumComponent","min","minimumByComponent","first","second","maximumByComponent","magnitudeSquared","sqrt","distanceScratch","distance","left","right","subtract","distanceSquared","normalize","isNaN","dot","multiplyComponents","divideComponents","add","multiplyByScalar","scalar","divideByScalar","negate","abs","lerpScratch","lerp","start","end","t","angleBetweenScratch","angleBetweenScratch2","angleBetween","cosine","sine","cross","atan2","mostOrthogonalAxisScratch","mostOrthogonalAxis","f","UNIT_X","UNIT_Z","UNIT_Y","projectVector","a","b","equals","equalsArray","offset","equalsEpsilon","relativeEpsilon","absoluteEpsilon","CesiumMath","leftX","leftY","leftZ","rightX","rightY","rightZ","midpoint","fromDegrees","longitude","latitude","height","ellipsoid","toRadians","fromRadians","scratchN","scratchK","wgs84RadiiSquared","radiiSquared","cosLatitude","gamma","fromDegreesArray","coordinates","fromRadiansArray","fromDegreesArrayHeights","fromRadiansArrayHeights","ZERO","Object","freeze","prototype","toString","scaleToGeodeticSurfaceIntersection","scaleToGeodeticSurfaceGradient","scaleToGeodeticSurface","oneOverRadii","oneOverRadiiSquared","centerToleranceSquared","positionX","positionY","positionZ","oneOverRadiiX","oneOverRadiiY","oneOverRadiiZ","x2","y2","z2","squaredNorm","ratio","intersection","isFinite","undefined","oneOverRadiiSquaredX","oneOverRadiiSquaredY","oneOverRadiiSquaredZ","gradient","func","xMultiplier","yMultiplier","zMultiplier","xMultiplier2","yMultiplier2","zMultiplier2","lambda","correction","EPSILON12","Cartographic","cartesianToCartographicN","cartesianToCartographicP","cartesianToCartographicH","wgs84OneOverRadii","wgs84OneOverRadiiSquared","wgs84CenterToleranceSquared","EPSILON1","initialize","_radii","_radiiSquared","_radiiToTheFourth","_oneOverRadii","_oneOverRadiiSquared","_minimumRadius","_maximumRadius","_centerToleranceSquared","_squaredXOverSquaredZ","Ellipsoid","fromCartesian","p","n","h","asin","sign","toCartesian","cartographic","epsilon","defineProperties","radii","get","radiiToTheFourth","minimumRadius","maximumRadius","fromCartesian3","WGS84","UNIT_SPHERE","MOON","LUNAR_RADIUS","geocentricSurfaceNormal","geodeticSurfaceNormalCartographic","geodeticSurfaceNormal","cartographicToCartesianNormal","cartographicToCartesianK","cartographicToCartesian","k","cartographicArrayToCartesianArray","cartographics","Rectangle","west","south","east","north","cartesianToCartographic","cartesianArrayToCartographicArray","cartesians","scaleToGeocentricSurface","beta","transformPositionToScaledSpace","position","transformPositionFromScaledSpace","getSurfaceNormalIntersectionWithZAxis","buffer","EPSILON15","greaterThan","squaredXOverSquaredZ","width","computeWidth","computeHeight","rectangle","TWO_PI","fromCartographicArray","Number","MAX_VALUE","westOverIDL","eastOverIDL","len","lonAdjusted","PI","fromCartesianArray","other","validate","PI_OVER_TWO","lessThanOrEquals","southwest","northwest","northeast","southeast","center","negativePiToPi","otherRectangle","rectangleEast","rectangleWest","otherRectangleEast","otherRectangleWest","simpleIntersection","union","convertLongitudeRange","expand","contains","EPSILON14","subsampleLlaScratch","Cartesian2","subsample","surfaceHeight","lla","acosClamped"],"mappings":"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"}